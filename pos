<?php
// =================== LINKLY CLOUD NOTIFY (ASYNC MODE) ===================
// MUST be before session_start() / auth_check.php
if (isset($_GET['action']) && $_GET['action'] === 'linkly_notify') {
    header('Content-Type: application/json; charset=UTF-8');
    ignore_user_abort(true);
    @set_time_limit(5);

    // Linkly will POST JSON notifications here
    if (strtoupper($_SERVER['REQUEST_METHOD'] ?? '') !== 'POST') {
        http_response_code(200);
        echo json_encode(['ok' => false, 'error' => 'method_not_allowed']);
        exit;
    }

    require_once __DIR__ . '/db_connect.php'; // $conn
    if (!isset($conn) || !($conn instanceof PDO)) {
        http_response_code(200);
        echo json_encode(['ok' => false, 'error' => 'db']);
        exit;
    }
    $conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    $conn->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC);

    $bizIdFromQuery = (int)($_GET['biz'] ?? 0);

    // Read raw POST body
    $rawBody  = file_get_contents('php://input') ?: '';
    $jsonBody = substr($rawBody, 0, 8000); // safety limit

    // Parse Linkly notification format: { SessionId, ResponseType, Response:{...} }
    $payload = json_decode($rawBody, true);

    $sidFromBody     = '';
    $typeFromBody    = '';
    $txnRefFromBody  = '';
    $amountFromBody  = 0;
    $txnCodeFromBody = '';

    if (is_array($payload)) {
        $sidFromBody  = strtolower(trim((string)($payload['SessionId'] ?? $payload['sessionId'] ?? '')));
        $typeFromBody = strtolower(trim((string)($payload['ResponseType'] ?? $payload['responseType'] ?? '')));

        // Unwrap Response/response for TxnRef / AmtPurchase / TxnType
        $respNode = [];
        if (isset($payload['Response']) && is_array($payload['Response'])) {
            $respNode = $payload['Response'];
        } elseif (isset($payload['response']) && is_array($payload['response'])) {
            $respNode = $payload['response'];
        }

        if ($respNode) {
            $txnRefFromBody  = (string)($respNode['TxnRef']      ?? $respNode['txnRef']      ?? '');
            $amountFromBody  = (int)   ($respNode['AmtPurchase'] ?? $respNode['amtPurchase'] ?? 0);
            $txnCodeFromBody = (string)($respNode['TxnType']     ?? $respNode['txnType']     ?? '');
        }
    }


    // Fallbacks (but the body is the source of truth)
    $sidFromQuery  = strtolower(trim((string)($_GET['sid'] ?? $_GET['sessionId'] ?? $_GET['sessionid'] ?? '')));
    $typeFromQuery = strtolower(trim((string)($_GET['type'] ?? $_GET['responseType'] ?? '')));

    $sessionId = $sidFromBody ?: $sidFromQuery;
    $type      = $typeFromBody ?: ($typeFromQuery ?: 'notify');

    try {
        $stmt = $conn->prepare("
            INSERT INTO linkly_cloud_logs
                (business_id,
                 queue_id,
                 environment,
                 cloud_username,
                 session_id,
                 txn_type,
                 txn_ref,
                 amount_cents,
                 currency,
                 http_code,
                 request_json,
                 response_json,
                 created_at)
            VALUES
                (:biz,
                 :qid,
                 '',
                 '',
                 :sid,
                 :type,
                 :txn_ref,
                 :amount_cents,
                 'AUD',
                 200,
                 NULL,
                 :resp,
                 NOW())
        ");
        $stmt->execute([
            ':biz'          => $bizIdFromQuery ?: 0,
            ':qid'          => $bizIdFromQuery ?: 0,
            ':sid'          => $sessionId,
            ':type'         => $type, // 'display' / 'receipt' / 'transaction'
            ':txn_ref'      => $txnRefFromBody !== '' ? $txnRefFromBody : null,
            ':amount_cents' => $amountFromBody,
            ':resp'         => $jsonBody,
        ]);
    } catch (Throwable $e) {
        error_log('Linkly notify log failed: ' . $e->getMessage());
    }


    // Always 200 so Linkly is happy
    http_response_code(200);
    echo json_encode(['ok' => true]);
    exit;
}


// =================== PAGE + INLINE JSON ENDPOINTS ===================
session_start();
include_once 'auth_check.php';
include_once 'update_subscription_features.php';
require_once __DIR__ . '/db_connect.php'; // provides $conn (PDO)

if (!isset($_SESSION['user_queue_id'])) {
    http_response_code(400);
    die("User queue ID not set.");
}
$userQueueId = (int)$_SESSION['user_queue_id'];

if (!isset($conn) || !($conn instanceof PDO)) {
    http_response_code(500);
    die("Database connection error.");
}
$conn->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
$conn->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC);
customer_ensure_meta_columns($conn);


const CUST_TBL = 'customers_time_capsule';

/* ---------- Helpers (immutability for paid rows; controlled reuse for pending/void) ---------- */
function pc_recalc_totals(array $items): array {
    $subtotal = 0;
    foreach ($items as $it) {
        $qty   = max(1, (int)($it['qty'] ?? 1));
        $price = (int)($it['price_cents'] ?? $it['variation_price_amount'] ?? 0);
        $subtotal += $qty * $price;
    }
    $tax = 0; // Inject tax logic here if required
    return [$subtotal, $tax, $subtotal + $tax];
}


/** Return latest NON-PAID cart (pending/void) for a customer+queue (never returns paid). */
function pc_get_cart(PDO $conn, int $bizId, int $custId, int $queueId) {
    $s = $conn->prepare("
        SELECT *
          FROM payment_collected
         WHERE business_id = ?
           AND customer_id = ?
           AND queue_id    = ?
           AND status IN ('pending','void')
         ORDER BY updated_at DESC, id DESC
         LIMIT 1
    ");
    $s->execute([$bizId, $custId, $queueId]);
    $row = $s->fetch(PDO::FETCH_ASSOC);
    if ($row) { $row['items_json'] = json_decode($row['items_json'], true) ?: []; }
    return $row ?: null;
}



/** Latest paid record for customer+queue (for the 2-hour “allow new” decision). */
function pc_get_latest_paid(PDO $conn, int $bizId, int $custId, int $queueId) {
    $s = $conn->prepare("
        SELECT *
          FROM payment_collected
         WHERE business_id = ?
           AND customer_id = ?
           AND queue_id    = ?
           AND status = 'paid'
         ORDER BY paid_at DESC, id DESC
         LIMIT 1
    ");
    $s->execute([$bizId, $custId, $queueId]);
    $row = $s->fetch(PDO::FETCH_ASSOC);
    if ($row) { $row['items_json'] = json_decode($row['items_json'], true) ?: []; }
    return $row ?: null;
}

/** True if there is no paid row, or the latest paid is older than 2 hours. */
function pc_allow_new_sale(?array $latestPaid): bool {
    if (!$latestPaid || empty($latestPaid['paid_at'])) return true;
    return (strtotime($latestPaid['paid_at']) < (time() - 2*3600));
}

/** Quick Sale variant: only pending/void carts (never returns paid). */
function pc_get_quicksale(PDO $conn, int $bizId, int $qid) {
    $s = $conn->prepare("
        SELECT *
          FROM payment_collected
         WHERE business_id = ?
           AND (queue_id = ? OR queue_id IS NULL OR queue_id = 0)
           AND (customer_id IS NULL OR customer_id = 0)
           AND status IN ('pending','void')
         ORDER BY updated_at DESC, id DESC
         LIMIT 1
    ");
    $s->execute([$bizId, $qid]);
    $row = $s->fetch(PDO::FETCH_ASSOC);
    if ($row) { $row['items_json'] = json_decode($row['items_json'], true) ?: []; }
    return $row ?: null;
}

// ---- Footer logo helpers/fetch ----
function media_abs_url(string $p): string {
    $p = trim($p);
    if ($p === '') return '';
    if (preg_match('~^https?://~i', $p)) return $p;
    return ($p[0] === '/' ? 'https://lineupz.ai'.$p : 'https://lineupz.ai/'.$p);
}

$footerLogoUrl  = '';
$footerBizName  = '';
$eftposProvider = '';   // 'square' or 'linkly'
$linklyCfg      = [];
$squareCfg      = [];

try {
    $st = $conn->prepare("
        SELECT
          business_name,
          logo_pic,
          COALESCE(preferred_eftpos,'')          AS preferred_eftpos,
          COALESCE(linkly_cloud_env,'')          AS linkly_cloud_env,
          COALESCE(linkly_cloud_username,'')     AS linkly_cloud_username,
          COALESCE(linkly_cloud_password,'')     AS linkly_cloud_password,
          COALESCE(linkly_cloud_secret,'')       AS linkly_cloud_secret,
          COALESCE(linkly_cloud_last_error,'')   AS linkly_cloud_last_error,
          COALESCE(square_access_token,'')       AS square_access_token,
          COALESCE(square_terminal_device_id,'') AS square_terminal_device_id
        FROM businesses
        WHERE id = ?
        LIMIT 1
    ");
    $st->execute([$userQueueId]);
    if ($row = $st->fetch(PDO::FETCH_ASSOC)) {
        $footerBizName = (string)($row['business_name'] ?? '');
        $footerLogoUrl = media_abs_url((string)($row['logo_pic'] ?? ''));

        $eftposProvider = strtolower(trim((string)($row['preferred_eftpos'] ?? '')));

        $linklyCfg = [
            'env'      => trim((string)($row['linkly_cloud_env'] ?? '')),
            'username' => trim((string)($row['linkly_cloud_username'] ?? '')),
            'password' => trim((string)($row['linkly_cloud_password'] ?? '')),
            'secret'   => trim((string)($row['linkly_cloud_secret'] ?? '')),
        ];

        $squareCfg = [
            'access_token' => trim((string)($row['square_access_token'] ?? '')),
            'device_id'    => trim((string)($row['square_terminal_device_id'] ?? '')),
        ];
    }
} catch (Throwable $e) {
    // ignore footer/EFTPOS errors; UI will just show "no EFTPOS connected"
}


/* ===== Ensure single barcode column on services_items_pos (idempotent) ===== */
function svc_ensure_barcode_column(PDO $conn){
  static $done = false; if ($done) return; $done = true;
  try {
    $have = [];
    $q = $conn->query("
      SELECT COLUMN_NAME
      FROM INFORMATION_SCHEMA.COLUMNS
      WHERE TABLE_SCHEMA = DATABASE()
        AND TABLE_NAME   = 'services_items_pos'
    ");
    foreach ($q->fetchAll(PDO::FETCH_COLUMN) as $c) $have[$c] = true;
    if (!isset($have['barcode'])) {
      $conn->exec("ALTER TABLE `services_items_pos` ADD COLUMN `barcode` VARCHAR(64) NULL");
    }
  } catch (Throwable $e) { /* best-effort; never block */ }
}


/* ===== Ensure reporting columns exist on payment_collected (idempotent) ===== */
function pc_ensure_reporting_columns(PDO $conn){
  static $done = false;
  if ($done) return; $done = true;

  try {
    $need = [
      'check_in_type'        => "VARCHAR(32) NULL",
      'is_new_client'        => "TINYINT(1) NULL DEFAULT 0",
      'customer_first_name'  => "VARCHAR(255) NULL",
      'customer_phone'       => "VARCHAR(64) NULL",
      // NEW: allow attributing QS/normal payments to a staff member
      'staff_user_id'        => "INT NULL",
      'staff_name'           => "VARCHAR(255) NULL"
    ];

    $have = [];
    $q = $conn->query("
      SELECT COLUMN_NAME
      FROM INFORMATION_SCHEMA.COLUMNS
      WHERE TABLE_SCHEMA = DATABASE()
        AND TABLE_NAME   = 'payment_collected'
    ");
    foreach ($q->fetchAll(PDO::FETCH_COLUMN) as $c) $have[$c] = true;

    foreach ($need as $col => $def) {
      if (!isset($have[$col])) {
        $conn->exec("ALTER TABLE `payment_collected` ADD COLUMN `{$col}` {$def}");
      }
    }
  } catch (Throwable $e) {
    // don't break checkout even if ALTER isn't permitted
  }
}

/* ===== Ensure family columns on customers (idempotent) ===== */
function family_ensure_columns(PDO $conn){
  static $done=false; if ($done) return; $done=true;
  try {
    $cols = [];
    $q = $conn->query("
      SELECT COLUMN_NAME
      FROM INFORMATION_SCHEMA.COLUMNS
      WHERE TABLE_SCHEMA = DATABASE()
        AND TABLE_NAME   = 'customers'
    ");
    foreach ($q->fetchAll(PDO::FETCH_COLUMN) as $c) $cols[$c]=true;

    if (!isset($cols['family_key']))   { $conn->exec("ALTER TABLE `customers` ADD COLUMN `family_key`   VARCHAR(64)  NULL"); }
    if (!isset($cols['family_label'])) { $conn->exec("ALTER TABLE `customers` ADD COLUMN `family_label` VARCHAR(255) NULL"); }

    // best-effort index for lookups
    try {
      $idx = $conn->query("SHOW INDEX FROM `customers` WHERE Key_name = 'idx_family_key'");
      if (!$idx || !$idx->fetch()) { @$conn->exec("ALTER TABLE `customers` ADD INDEX `idx_family_key` (`family_key`)"); }
    } catch(Throwable $e){ /* ignore */ }

  } catch(Throwable $e){ /* ignore */ }
}

/* ===== Ensure soft-delete/finish columns on customers (idempotent) ===== */
function customer_ensure_meta_columns(PDO $conn){
  static $done=false; if ($done) return; $done=true;
  try {
    $have = [];
    $q = $conn->query("
      SELECT COLUMN_NAME
      FROM INFORMATION_SCHEMA.COLUMNS
      WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'customers'
    ");
    foreach ($q->fetchAll(PDO::FETCH_COLUMN) as $c) $have[$c]=true;
    if (!isset($have['deleted_by_staff'])) $conn->exec("ALTER TABLE `customers` ADD COLUMN `deleted_by_staff` DATETIME NULL");
    if (!isset($have['finished']))        $conn->exec("ALTER TABLE `customers` ADD COLUMN `finished` TINYINT(1) NULL DEFAULT 0");
    if (!isset($have['finished_at']))     $conn->exec("ALTER TABLE `customers` ADD COLUMN `finished_at` DATETIME NULL");
  } catch (Throwable $e) { /* no-op: don’t block the page if ALTER isn’t permitted */ }
}

/* ===== EFTPOS provider + Linkly Cloud helpers (server-side) ===== */

/**
 * Map linkly_cloud_env -> auth / rest base URLs.
 */
function linkly_env_urls(string $env): array {
    $env = strtolower(trim($env));
    if ($env === 'sandbox' || $env === 'test' || $env === 'dev') {
        return [
            'auth' => 'https://auth.sandbox.cloud.pceftpos.com',
            'rest' => 'https://rest.pos.sandbox.cloud.pceftpos.com',
        ];
    }
    // default to production
    return [
        'auth' => 'https://auth.cloud.pceftpos.com',
        'rest' => 'https://rest.pos.cloud.pceftpos.com',
    ];
}

/**
 * Persist last Linkly error onto the business row (best-effort only).
 */
function linkly_set_last_error(PDO $conn, int $bizId, string $msg): void {
    try {
        $short = function_exists('mb_substr') ? mb_substr($msg, 0, 250) : substr($msg, 0, 250);
        $stmt = $conn->prepare("UPDATE businesses SET linkly_cloud_last_error = :e WHERE id = :id LIMIT 1");
        $stmt->execute([
            ':e'  => $short,
            ':id' => $bizId,
        ]);
    } catch (Throwable $e) {
        // ignore; never block POS
    }
}

/**
/**
 * Get (or refresh) a Linkly auth token for the current business.
 * Uses linkly_cloud_secret from $linklyCfg and caches the token in the PHP session.
 */
function linkly_get_token(array $cfg): ?string {
    if (session_status() === PHP_SESSION_NONE) {
        session_start();
    }

    $now    = time();
    $tokKey = 'linkly_cloud_token';
    $expKey = 'linkly_cloud_token_expires';

    // reuse token if still valid (with 30s safety window)
    if (!empty($_SESSION[$tokKey]) && !empty($_SESSION[$expKey]) && $_SESSION[$expKey] > ($now + 30)) {
        return (string)$_SESSION[$tokKey];
    }

    $secret = trim($cfg['secret'] ?? '');
    $env    = trim($cfg['env'] ?? '');
    if ($secret === '' || $env === '') {
        return null;
    }

    // Stable posId per PHP session (so we don't random_bytes() every time)
    if (empty($_SESSION['linkly_cloud_pos_id'])) {
        try {
            $_SESSION['linkly_cloud_pos_id'] = bin2hex(random_bytes(16));
        } catch (Throwable $e) {
            // Fallback if CSPRNG fails for some reason
            $_SESSION['linkly_cloud_pos_id'] = bin2hex(random_bytes(8));
        }
    }
    $posId = (string)$_SESSION['linkly_cloud_pos_id'];

    $urls    = linkly_env_urls($env);
    $authUrl = rtrim($urls['auth'], '/') . '/v1/tokens/cloudpos';

    $payload = [
        'secret'      => $secret,
        'posName'     => 'LineUpzPOS',
        'posVersion'  => '1.0.0',
        'posId'       => $posId,        // stable per POS session
        'posVendorId' => 'lineupz-pos',
    ];

    $ch = curl_init($authUrl);
    curl_setopt_array($ch, [
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_POST           => true,
        CURLOPT_HTTPHEADER     => [
            'Content-Type: application/json',
            'Accept: application/json',
        ],
        CURLOPT_POSTFIELDS     => json_encode($payload),
        CURLOPT_TIMEOUT        => 25,
    ]);
    $resp = curl_exec($ch);
    $http = curl_getinfo($ch, CURLINFO_HTTP_CODE);
    $err  = curl_error($ch);
    curl_close($ch);

    if ($resp === false || $http >= 400) {
        error_log('Linkly token error http='.$http.' err='.$err.' body='.substr((string)$resp, 0, 500));
        return null;
    }

    $data = json_decode($resp, true);
    if (!is_array($data) || empty($data['token'])) {
        error_log('Linkly token decode error: '.substr((string)$resp, 0, 500));
        return null;
    }

    $expirySeconds = (int)($data['expirySeconds'] ?? 0);
    if ($expirySeconds <= 0) {
        $expirySeconds = 3600;
    }

    $_SESSION[$tokKey] = (string)$data['token'];
    $_SESSION[$expKey] = $now + $expirySeconds - 10; // 10s buffer

    return (string)$data['token'];
}




/* ---------- Inline endpoints ---------- */
if (isset($_GET['action'])) {
    header('Content-Type: application/json');

    try {
        /* ===== Services list (grid-ready from services_items_pos) ===== */
        if ($_GET['action'] === 'services') {
          svc_ensure_barcode_column($conn);
          $stmt = $conn->prepare("
            SELECT
              id,
              item_name,
              COALESCE(variation_price_amount,0) AS variation_price_amount,
              COALESCE(grid_index, NULL)         AS grid_index,
              COALESCE(color_hex,'#EFEFEF')      AS color_hex,
              COALESCE(is_primary,0)             AS is_primary,
              COALESCE(is_upsell,0)              AS is_upsell,
              COALESCE(is_discount,0)            AS is_discount,
              COALESCE(is_retail,0)              AS is_retail,
              COALESCE(active,1)                 AS active,
              COALESCE(sort_order,0)             AS sort_order,
              COALESCE(discount_type,'none')     AS discount_type,
              COALESCE(discount_value,0)         AS discount_value,
              COALESCE(discount_qtokens,0)       AS discount_qtokens,
              COALESCE(barcode,'')               AS barcode
            FROM services_items_pos
            WHERE business_id = :bid
            ORDER BY active DESC, sort_order ASC, id ASC
          ");
          $stmt->execute([':bid' => $userQueueId]);
          $rows = $stmt->fetchAll(PDO::FETCH_ASSOC);
          foreach ($rows as &$r) { $r['variation_price_amount'] = (int)$r['variation_price_amount']; }
          echo json_encode(['ok' => true, 'services' => $rows]); exit;
        }
        
        /* ===== Barcode lookup (keyboard-wedge scanners) ===== */
        if ($_GET['action'] === 'barcode_lookup') {
          header('Content-Type: application/json');
          try {
            svc_ensure_barcode_column($conn);
            $code = trim((string)($_GET['code'] ?? $_POST['code'] ?? ''));
            if ($code === '') { echo json_encode(['ok'=>true, 'matches'=>[]]); exit; }
        
            $stmt = $conn->prepare("
              SELECT
                id, item_name,
                COALESCE(variation_price_amount,0) AS variation_price_amount,
                COALESCE(is_discount,0)            AS is_discount,
                COALESCE(discount_type,'none')     AS discount_type,
                COALESCE(discount_value,0)         AS discount_value,
                COALESCE(discount_qtokens,0)       AS discount_qtokens,
                COALESCE(barcode,'')               AS barcode
              FROM services_items_pos
              WHERE business_id = :bid
                AND barcode = :code
              ORDER BY is_retail DESC, sort_order ASC, id ASC
              LIMIT 15
            ");
            $stmt->execute([':bid'=>$userQueueId, ':code'=>$code]);
            echo json_encode(['ok'=>true, 'matches'=>$stmt->fetchAll(PDO::FETCH_ASSOC) ?: []]); exit;
          } catch(Throwable $e){
            http_response_code(500);
            echo json_encode(['ok'=>false, 'error'=>'server error']); exit;
          }
        }


        /* ===== Staff list (POS picker) — only open sessions; include break info ===== */
        if ($_GET['action'] === 'staff_list') {
          header('Content-Type: application/json; charset=UTF-8');
          try {
            $utcNow = (new DateTime('now', new DateTimeZone('UTC')))->format('Y-m-d H:i:s');
        
            $sql = "
              SELECT b.id, b.name,
                     (t.last_break_at IS NOT NULL) AS on_break,
                     CASE WHEN t.last_break_at IS NOT NULL
                          THEN TIMESTAMPDIFF(SECOND, t.last_break_at, NOW())
                          ELSE 0
                     END AS break_for_seconds
              FROM businesses b
              JOIN (
                SELECT staff_id, MAX(id) AS sid
                FROM timesheet_sessions
                WHERE business_id = :bid
                  AND end_at IS NULL                              -- **open session only**
                  AND start_at <= :utcNow
                GROUP BY staff_id

              ) x   ON x.staff_id = b.id
              JOIN timesheet_sessions t ON t.id = x.sid
              WHERE b.user_queue_id = :uqid
                AND b.subscription_status IN ('subscribed1','subscribed2','subscribed3','staff')
              ORDER BY b.name
            ";
            $stmt = $conn->prepare($sql);
            $stmt->execute([
              ':bid'    => $userQueueId,
              ':uqid'   => $userQueueId,
              ':utcNow' => $utcNow,
            ]);
        
            echo json_encode(['ok'=>true, 'staff'=>$stmt->fetchAll(PDO::FETCH_ASSOC) ?: []]); exit;
          } catch (Throwable $e) {
            http_response_code(500);
            echo json_encode(['ok'=>false, 'staff'=>[]]); exit;
          }
        }

        /* ===== Upsell options list (all POS upsell services) ===== */
        if ($_GET['action'] === 'upsell_options') {
          header('Content-Type: application/json; charset=UTF-8');
          try {
            $st = $conn->prepare("
              SELECT
                id,
                item_name,
                COALESCE(variation_price_amount,0) AS variation_price_amount
              FROM services_items_pos
              WHERE business_id = :bid
                AND COALESCE(is_upsell,0) = 1
                AND COALESCE(active,1) = 1
              ORDER BY sort_order ASC, item_name ASC
            ");
            $st->execute([':bid' => $userQueueId]);
            $rows = $st->fetchAll(PDO::FETCH_ASSOC) ?: [];
            echo json_encode(['ok' => true, 'services' => $rows]);
          } catch (Throwable $e) {
            http_response_code(500);
            echo json_encode(['ok' => false, 'error' => 'server']);
          }
          exit;
        }

        /* ===== Upsell GET (current add-ons for this customer today) ===== */
        if ($_GET['action'] === 'upsell_get') {
          header('Content-Type: application/json; charset=UTF-8');
          $cid = (int)($_GET['customer_id'] ?? 0);
          if ($cid <= 0) {
            echo json_encode(['ok' => false, 'error' => 'bad params']); exit;
          }
          try {
            $st = $conn->prepare("
              SELECT service_id
              FROM kiosk_upsell_events
              WHERE business_id = :bid
                AND customer_id = :cid
                AND DATE(created_at) = CURDATE()
            ");
            $st->execute([
              ':bid' => $userQueueId,
              ':cid' => $cid,
            ]);
            $ids = $st->fetchAll(PDO::FETCH_COLUMN) ?: [];
            $ids = array_values(array_unique(array_map('intval', $ids)));
            echo json_encode(['ok' => true, 'service_ids' => $ids]);
          } catch (Throwable $e) {
            http_response_code(500);
            echo json_encode(['ok' => false, 'error' => 'server']);
          }
          exit;
        }

        /* ===== Upsell SET (replace today's add-ons for this customer) ===== */
        if ($_GET['action'] === 'upsell_set') {
          header('Content-Type: application/json; charset=UTF-8');
          $p   = json_decode(file_get_contents('php://input'), true) ?: [];
          $cid = (int)($p['customer_id'] ?? 0);
          $ids = array_values(array_unique(array_map('intval', (array)($p['service_ids'] ?? []))));
          if ($cid <= 0) {
            echo json_encode(['ok' => false, 'error' => 'bad params']); exit;
          }

          try {
            $conn->beginTransaction();

            // 1) Clear existing upsell events for this visit (today) for this customer
            $del = $conn->prepare("
              DELETE FROM kiosk_upsell_events
              WHERE business_id = :bid
                AND customer_id = :cid
                AND DATE(created_at) = CURDATE()
            ");
            $del->execute([
              ':bid' => $userQueueId,
              ':cid' => $cid,
            ]);

            // 2) Insert updated selection (one row per service)
            if ($ids) {
              $ins = $conn->prepare("
                INSERT INTO kiosk_upsell_events
                  (business_id, customer_id, service_id, source, created_at)
                VALUES
                  (:bid, :cid, :sid, 'kiosk', NOW())
              ");
              foreach ($ids as $sid) {
                if ($sid <= 0) continue;
                $ins->execute([
                  ':bid' => $userQueueId,
                  ':cid' => $cid,
                  ':sid' => $sid,
                ]);
              }
            }

            $conn->commit();
            echo json_encode(['ok' => true, 'service_ids' => $ids]);
          } catch (Throwable $e) {
            if ($conn->inTransaction()) $conn->rollBack();
            http_response_code(500);
            echo json_encode(['ok' => false, 'error' => 'server']);
          }
          exit;
        }

        
        /* ===== Delete customer (picked staff) ===== */
        if ($_GET['action'] === 'delete_customer_staff') {
            $p = json_decode(file_get_contents('php://input'), true) ?: [];
            $customerId = (int)($p['customer_id'] ?? 0);
            $staffId    = (int)($p['staff_id'] ?? 0);
            if ($customerId<=0 || $staffId<=0) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }

            try {
                // Fetch staff name (staff live in `businesses` table)
                $st = $conn->prepare('SELECT name FROM businesses WHERE id = ? LIMIT 1');
                $st->execute([$staffId]);
                $srow = $st->fetch(PDO::FETCH_ASSOC);
                if (!$srow) { echo json_encode(['ok'=>false,'error'=>'staff not found']); exit; }
                $staffName = (string)($srow['name'] ?? '');

                // Ensure audit cols exist (best-effort)
                try {
                    $cols = [];
                    $q = $conn->query("
                      SELECT COLUMN_NAME
                        FROM INFORMATION_SCHEMA.COLUMNS
                       WHERE TABLE_SCHEMA = DATABASE()
                         AND TABLE_NAME   = 'customers'
                    ");
                    foreach ($q->fetchAll(PDO::FETCH_COLUMN) as $cname) $cols[$cname] = true;
                    if (!isset($cols['deleted_by_staff_id']))   { $conn->exec("ALTER TABLE `customers` ADD COLUMN `deleted_by_staff_id` INT NULL"); }
                    if (!isset($cols['deleted_by_staff_name'])) { $conn->exec("ALTER TABLE `customers` ADD COLUMN `deleted_by_staff_name` VARCHAR(255) NULL"); }
                } catch (Throwable $ignore) {}

                $conn->beginTransaction();
                $u = $conn->prepare("
                   UPDATE customers
                      SET deleted_by_staff      = NOW(),
                          deleted_by_staff_id   = :sid,
                          deleted_by_staff_name = :sn,
                          staff_user_id         = :sid,
                          staff_name            = :sn
                    WHERE id = :cid
                ");
                $u->execute([':sid'=>$staffId, ':sn'=>$staffName, ':cid'=>$customerId]);
                $conn->commit();

                echo json_encode(['ok'=>true, 'staff_name'=>$staffName]); exit;

            } catch (Throwable $e) {
                if ($conn->inTransaction()) $conn->rollBack();
                http_response_code(500);
                echo json_encode(['ok'=>false,'error'=>'server error']); exit;
            }
        }



        /* ===== Served list: refresh staff_name from live customers table ===== */
        if ($_GET['action'] === 'served_staff_refresh') {
          $idsRaw = trim((string)($_GET['ids'] ?? ''));
          if ($idsRaw === '') {
            echo json_encode(['ok' => true, 'map' => []]); 
            exit;
          }

          $ids = array_values(array_unique(array_filter(
            array_map('intval', explode(',', $idsRaw))
          )));
          if (!$ids) {
            echo json_encode(['ok' => true, 'map' => []]); 
            exit;
          }

          $place = implode(',', array_fill(0, count($ids), '?'));

          $stmt = $conn->prepare("
            SELECT id, staff_name
            FROM customers
            WHERE id IN ($place) AND queue_id = ?
          ");
          $stmt->execute(array_merge($ids, [$userQueueId]));

          $map = [];
          while ($r = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $cid = (int)$r['id'];
            $map[$cid] = (string)($r['staff_name'] ?? '');
          }

          echo json_encode(['ok' => true, 'map' => $map]); 
          exit;
        }

        /* ===== Assign staff to a customer ===== */
        if ($_GET['action'] === 'assign_staff') {
            // Support both JSON and form-encoded payloads
            $raw = file_get_contents('php://input');
            $p   = json_decode($raw, true);
            if (!is_array($p) || empty($p)) {
                // Fallback to normal POST (used by offline replay via sendOrQueueAjax)
                $p = $_POST;
            }

            $customerId = isset($p['customer_id']) ? (int)$p['customer_id'] : 0;
            $staffId    = isset($p['staff_id'])    ? (int)$p['staff_id']    : 0;

            if ($customerId <= 0 || $staffId <= 0) {
                echo json_encode(['ok' => false, 'error' => 'bad params']); 
                exit;
            }

            $stmt = $conn->prepare('SELECT name FROM businesses WHERE id = ? LIMIT 1');
            $stmt->execute([$staffId]);
            $staffRow = $stmt->fetch(PDO::FETCH_ASSOC);
            if (!$staffRow) {
                echo json_encode(['ok' => false, 'error' => 'staff not found']); 
                exit;
            }

            $u = $conn->prepare('UPDATE customers SET staff_name = ?, staff_user_id = ? WHERE id = ?');
            $u->execute([$staffRow['name'], $staffId, $customerId]);

            echo json_encode([
                'ok'          => true,
                'staff_name'  => $staffRow['name'],
                'staff_user_id' => $staffId
            ]);
            exit;
        }

        
        /* ===== Families: assign a new family to selected customers ===== */
        if ($_GET['action'] === 'family_assign') {
          family_ensure_columns($conn);
          $p = json_decode(file_get_contents('php://input'), true) ?: [];
          $ids   = array_values(array_unique(array_map('intval', (array)($p['customer_ids'] ?? []))));
          $label = trim((string)($p['label'] ?? ''));
          if (count($ids) < 2) { echo json_encode(['ok'=>false,'error'=>'need_at_least_two']); exit; }
        
          // only operate on this business's customers
          $place = implode(',', array_fill(0, count($ids), '?'));
          $chk = $conn->prepare("SELECT id FROM customers WHERE id IN ($place) AND queue_id = ?");
          $chk->execute(array_merge($ids, [$userQueueId]));
          $valid = $chk->fetchAll(PDO::FETCH_COLUMN);
          if (count($valid) < 2) { echo json_encode(['ok'=>false,'error'=>'not_found_in_business']); exit; }
        
          $key = 'fam_'.bin2hex(random_bytes(5));
          $conn->beginTransaction();
          try {
            $u = $conn->prepare("UPDATE customers SET family_key = :k, family_label = :l WHERE id = :id AND queue_id = :qid");
            foreach ($valid as $cid) {
              $u->execute([':k'=>$key, ':l'=>($label !== '' ? $label : null), ':id'=>(int)$cid, ':qid'=>$userQueueId]);
            }
            $conn->commit();
            echo json_encode(['ok'=>true, 'family_key'=>$key, 'label'=>$label]); exit;
          } catch(Throwable $e){
            if ($conn->inTransaction()) $conn->rollBack();
            http_response_code(500); echo json_encode(['ok'=>false,'error'=>'server']); exit;
          }
        }
        
        /* ===== Families: list family info for a set of ids ===== */
        if ($_GET['action'] === 'family_list_for') {
          family_ensure_columns($conn);
          $idsRaw = trim((string)($_GET['ids'] ?? ''));
          if ($idsRaw === '') { echo json_encode(['ok'=>true,'map'=>[]]); exit; }
          $ids = array_values(array_unique(array_filter(array_map('intval', explode(',', $idsRaw)))));
          if (!$ids) { echo json_encode(['ok'=>true,'map'=>[]]); exit; }
          $place = implode(',', array_fill(0, count($ids), '?'));
        
          $stmt = $conn->prepare("
            SELECT id, family_key, family_label
            FROM customers
            WHERE id IN ($place) AND queue_id = ?
          ");
          $stmt->execute(array_merge($ids, [$userQueueId]));
          $map = [];
          while ($r = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $cid = (int)$r['id'];
            $map[$cid] = [
              'key'   => (string)($r['family_key']   ?? ''),
              'label' => (string)($r['family_label'] ?? '')
            ];
          }
          echo json_encode(['ok'=>true,'map'=>$map]); exit;
        }
        
        /* ===== Families: remove a single member from their family ===== */
        if ($_GET['action'] === 'family_remove_member') {
          family_ensure_columns($conn);
          $p = json_decode(file_get_contents('php://input'), true) ?: [];
          $cid = (int)($p['customer_id'] ?? 0);
          if ($cid <= 0) { echo json_encode(['ok'=>false,'error'=>'bad_params']); exit; }
          $u = $conn->prepare("UPDATE customers SET family_key=NULL, family_label=NULL WHERE id = :id AND queue_id = :qid");
          $u->execute([':id'=>$cid, ':qid'=>$userQueueId]);
          echo json_encode(['ok'=>true]); exit;
        }
        /* ===== Families: fetch all members for a family key (names included) ===== */
        if ($_GET['action'] === 'family_members') {
          family_ensure_columns($conn);
          $key = trim((string)($_GET['family_key'] ?? ''));
          if ($key === '') { echo json_encode(['ok'=>false,'error'=>'bad_params']); exit; }
        
          $st = $conn->prepare("
            SELECT id, firstName, phone, family_label
            FROM customers
            WHERE queue_id = ? AND family_key = ?
            ORDER BY firstName, id
          ");
          $st->execute([$userQueueId, $key]);
          $rows = $st->fetchAll(PDO::FETCH_ASSOC) ?: [];
        
          // pick the first non-empty label as the canonical label
          $label = '';
          foreach ($rows as $r) { if (!empty($r['family_label'])) { $label = (string)$r['family_label']; break; } }
        
          echo json_encode(['ok'=>true, 'members'=>$rows, 'label'=>$label]); exit;
        }

        /* ===== Families: update membership for an existing family key ===== */
        if ($_GET['action'] === 'family_update_members') {
          family_ensure_columns($conn);
          $p = json_decode(file_get_contents('php://input'), true) ?: [];
          $key   = trim((string)($p['family_key'] ?? ''));
          $add   = array_values(array_unique(array_map('intval', (array)($p['add_ids'] ?? []))));
          $rem   = array_values(array_unique(array_map('intval', (array)($p['remove_ids'] ?? []))));
          $label = trim((string)($p['label'] ?? ''));
        
          if ($key === '') { echo json_encode(['ok'=>false,'error'=>'bad_params']); exit; }
        
          // Validate ids belong to this business
          $checkIds = array_merge($add, $rem);
          if ($checkIds) {
            $ph = implode(',', array_fill(0, count($checkIds), '?'));
            $stmt = $conn->prepare("SELECT id FROM customers WHERE id IN ($ph) AND queue_id = ?");
            $stmt->execute(array_merge($checkIds, [$userQueueId]));
            $valid = array_map('intval', $stmt->fetchAll(PDO::FETCH_COLUMN));
            $validSet = array_flip($valid);
            $add = array_values(array_filter($add, fn($i)=>isset($validSet[$i])));
            $rem = array_values(array_filter($rem, fn($i)=>isset($validSet[$i])));
          }
        
          // If label empty, keep current label (if any)
          if ($label === '') {
            $st = $conn->prepare("SELECT family_label FROM customers WHERE queue_id = ? AND family_key = ? AND family_label IS NOT NULL AND family_label <> '' LIMIT 1");
            $st->execute([$userQueueId, $key]);
            $label = (string)($st->fetchColumn() ?: '');
          }
        
          $conn->beginTransaction();
          try {
            if ($rem) {
              $ph = implode(',', array_fill(0, count($rem), '?'));
              $u = $conn->prepare("UPDATE customers SET family_key = NULL, family_label = NULL WHERE id IN ($ph) AND queue_id = ?");
              $u->execute(array_merge($rem, [$userQueueId]));
            }
            if ($add) {
              $ph = implode(',', array_fill(0, count($add), '?'));
              $u = $conn->prepare("UPDATE customers SET family_key = ?, family_label = ? WHERE id IN ($ph) AND queue_id = ?");
              $params = array_merge([$key, ($label !== '' ? $label : null)], $add, [$userQueueId]);
              $u->execute($params);
            }
            // Normalize label across this business for that key (optional but tidy)
            if ($label !== '') {
              $u2 = $conn->prepare("UPDATE customers SET family_label = ? WHERE queue_id = ? AND family_key = ?");
              $u2->execute([$label, $userQueueId, $key]);
            }
        
            $conn->commit();
            echo json_encode(['ok'=>true, 'family_key'=>$key, 'label'=>$label]); exit;
          } catch(Throwable $e){
            if ($conn->inTransaction()) $conn->rollBack();
            http_response_code(500);
            echo json_encode(['ok'=>false,'error'=>'server']); exit;
          }
        }



        /* ===== Customer cart status (non-paid active cart; plus allow_new from last paid) ===== */
        if ($_GET['action'] === 'cart_status') {
            $customerId = (int)($_GET['customer_id'] ?? 0);
            $queueId    = (int)($_GET['queue_id'] ?? 0);
            if ($customerId <= 0 || $queueId <= 0) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }

            $active     = pc_get_cart($conn, $userQueueId, $customerId, $queueId);       // pending/void only
            $latestPaid = pc_get_latest_paid($conn, $userQueueId, $customerId, $queueId); // paid only
            $allowNew   = pc_allow_new_sale($latestPaid);

            echo json_encode(['ok'=>true, 'cart'=>$active ?: null, 'allow_new'=>$allowNew]); exit;
        }

        /* ===== Add/merge items (customer) ===== */
        if ($_GET['action'] === 'cart_add_items') {
            try {
                $payload    = json_decode(file_get_contents('php://input'), true) ?: [];
                $customerId = (int)($payload['customer_id'] ?? 0);
                $queueId    = (int)($payload['queue_id'] ?? 0);
                $itemsIn    = $payload['items'] ?? [];
                if ($customerId<=0 || $queueId<=0 || !is_array($itemsIn)) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }

                /* --- REDO rule: only allow adding a "Redo" discount if last visit ≤ 7 days (Sydney) --- */
                if (!empty($itemsIn)) {
                  // Collect candidate service IDs
                  $sidList = [];
                  foreach ($itemsIn as $it) {
                    $sid = (int)($it['service_id'] ?? $it['id'] ?? 0);
                    if ($sid > 0) $sidList[] = $sid;
                  }
                  if ($sidList) {
                    $ph = implode(',', array_fill(0, count($sidList), '?'));
                    $chk = $conn->prepare("
                      SELECT id, COALESCE(is_discount,0) AS is_discount, item_name
                      FROM services_items_pos
                      WHERE business_id = ? AND id IN ($ph)
                    ");
                    $chk->execute(array_merge([$userQueueId], $sidList));

                    $redoAttempt = false;
                    while ($r = $chk->fetch(PDO::FETCH_ASSOC)) {
                      if ((int)$r['is_discount'] === 1 && stripos((string)$r['item_name'], 'redo') !== false) {
                        $redoAttempt = true; break;
                      }
                    }

                    if ($redoAttempt) {
                      $tz  = new DateTimeZone('Australia/Sydney');

                      // "Last visit" = the *previous* served (second most recent)
                      $h = $conn->prepare("
                        SELECT change_time
                        FROM status_history
                        WHERE customer_id = ?
                          AND queue_status = 'served'
                        ORDER BY change_time DESC
                        LIMIT 2
                      ");
                      $h->execute([$customerId]);
                      $times = $h->fetchAll(PDO::FETCH_COLUMN);

                        $allowed = false;
                        $refIdx = (count($times) >= 2) ? 1 : 0;   // use previous if available, else most recent
                        if (isset($times[$refIdx])) {
                          $last = new DateTime($times[$refIdx], $tz);
                          $now  = new DateTime('now', $tz);
                          $allowed = (($now->getTimestamp() - $last->getTimestamp()) <= 7 * 86400);
                        }


                      if (!$allowed) {
                        http_response_code(409);
                        echo json_encode([
                          'ok'      => false,
                          'error'   => 'redo_window',
                          'message' => 'Redo is only available within 7 days of last visit.'
                        ]);
                        exit;
                      }
                    }
                  }
                }

                $conn->beginTransaction();

                // LOCK current cart row before merging (prevents two tabs from stomping each other)
                $lock = $conn->prepare("
                  SELECT id, items_json
                  FROM payment_collected
                  WHERE business_id = ? AND customer_id = ? AND queue_id = ?
                    AND status IN ('pending','void')
                  ORDER BY updated_at DESC, id DESC
                  LIMIT 1
                  FOR UPDATE
                ");
                $lock->execute([$userQueueId, $customerId, $queueId]);
                $existing = $lock->fetch(PDO::FETCH_ASSOC);
                if ($existing) { $existing['items_json'] = json_decode($existing['items_json'] ?? '[]', true) ?: []; }
                
                $latestPaid = pc_get_latest_paid($conn, $userQueueId, $customerId, $queueId);
                $allowNew   = pc_allow_new_sale($latestPaid);


                // merge items
                $merged = [];
                if ($existing && !empty($existing['items_json'])) {
                    foreach ($existing['items_json'] as $it) {
                        $sid = (int)$it['service_id'];
                        $merged[$sid] = [
                            'service_id'  => $sid,
                            'name'        => $it['name'],
                            'price_cents' => (int)$it['price_cents'],
                            'qty'         => (int)$it['qty'],
                        ];
                    }
                }
                foreach ($itemsIn as $it) {
                    $sid = (int)($it['service_id'] ?? $it['id'] ?? 0);
                    if ($sid <= 0) continue;
                    $name  = (string)($it['name'] ?? $it['item_name'] ?? '');
                    $price = (int)($it['price_cents'] ?? $it['variation_price_amount'] ?? 0);
                    $qty   = max(1, (int)($it['qty'] ?? 1));
                    if (isset($merged[$sid])) { $merged[$sid]['qty'] += $qty; }
                    else { $merged[$sid] = ['service_id'=>$sid,'name'=>$name,'price_cents'=>$price,'qty'=>$qty]; }
                }
                $itemsArr = array_values($merged);
                [$subtotal,$tax,$total] = pc_recalc_totals($itemsArr);

                if ($existing) {
                    // Update pending/void cart
                    $u = $conn->prepare("UPDATE payment_collected
                        SET items_json=:j, subtotal_cents=:sub, tax_cents=:tax, total_cents=:tot,
                            updated_at=NOW(), status='pending'
                      WHERE id=:id AND status IN ('pending','void')");
                    $u->execute([
                        ':j'=>json_encode($itemsArr), ':sub'=>$subtotal, ':tax'=>$tax, ':tot'=>$total,
                        ':id'=>$existing['id']
                    ]);
                    $id = (int)$existing['id'];
                } else {
                    // Insert a fresh OPEN cart for this (biz, customer, queue)
                    $i = $conn->prepare("INSERT INTO payment_collected
                      (business_id, customer_id, queue_id, quicksale, status, items_json,
                       subtotal_cents, tax_cents, total_cents, currency, created_at, updated_at)
                      VALUES (:b, :c, :q, 0, 'pending', :j, :sub, :tax, :tot, 'AUD', NOW(), NOW())");
                    $i->execute([
                      ':b'=>$userQueueId, ':c'=>$customerId, ':q'=>$queueId,
                      ':j'=>json_encode($itemsArr), ':sub'=>$subtotal, ':tax'=>$tax, ':tot'=>$total
                    ]);
                    $id = (int)$conn->lastInsertId();
                }

                $conn->commit();
                echo json_encode(['ok'=>true,'id'=>$id,'subtotal_cents'=>$subtotal,'total_cents'=>$total,'items'=>$itemsArr]); exit;

            } catch (Throwable $e) {
                if ($conn->inTransaction()) $conn->rollBack();
                http_response_code(500);
                header('Content-Type: application/json');
                error_log($e);
                echo json_encode(['ok'=>false,'error'=>'server error']);
                exit;
            }
        }


        /* ===== Remove items (customer) [refund Q-tokens for removed discount lines] ===== */
        if ($_GET['action'] === 'cart_remove_items') {
            $p = json_decode(file_get_contents('php://input'), true) ?: [];
            $customerId = (int)($p['customer_id'] ?? 0);
            $queueId    = (int)($p['queue_id'] ?? 0);
            $serviceIds = $p['service_ids'] ?? [];
            if ($customerId<=0 || $queueId<=0 || !is_array($serviceIds) || !count($serviceIds)) {
                echo json_encode(['ok'=>false,'error'=>'bad params']); exit;
            }
        
            $removeSet = array_map('intval', $serviceIds);
        
            $conn->beginTransaction();
            $cart = pc_get_cart($conn, $userQueueId, $customerId, $queueId);
            if (!$cart) { $conn->commit(); echo json_encode(['ok'=>true,'state'=>'empty']); exit; }
        
            // Partition keep/remove & compute potential token refund
            $keep = [];
            $toRemove = [];
            foreach ($cart['items_json'] as $it) {
                if (in_array((int)$it['service_id'], $removeSet, true)) $toRemove[] = $it;
                else $keep[] = $it;
            }
        
            // How many Q-tokens to refund for removed discount lines
            $refundTokens = 0;
            if ($toRemove) {
                $sidList = array_values(array_unique(array_map(function($it){ return (int)($it['service_id'] ?? 0); }, $toRemove)));
                if ($sidList) {
                    $ph = implode(',', array_fill(0, count($sidList), '?'));
                    $st = $conn->prepare("
                        SELECT id, COALESCE(is_discount,0) AS is_discount, COALESCE(discount_qtokens,0) AS discount_qtokens
                          FROM services_items_pos
                         WHERE business_id = ? AND id IN ($ph)
                    ");
                    $st->execute(array_merge([$userQueueId], $sidList));
                    $meta = [];
                    while ($r = $st->fetch(PDO::FETCH_ASSOC)) {
                        $meta[(int)$r['id']] = ['is_discount'=>(int)$r['is_discount'], 'qt'=>(int)$r['discount_qtokens']];
                    }
                    foreach ($toRemove as $it) {
                        $sid = (int)($it['service_id'] ?? 0);
                        $qty = max(1, (int)($it['qty'] ?? 1));
                        if (!empty($meta[$sid]) && $meta[$sid]['is_discount'] === 1 && $meta[$sid]['qt'] > 0) {
                            $refundTokens += $meta[$sid]['qt'] * $qty;
                        }
                    }
                }
            }
        
            if (!count($keep)) {
                // Delete the cart entirely
                $d = $conn->prepare("DELETE FROM payment_collected WHERE id=? AND status IN ('pending','void')");
                $d->execute([$cart['id']]);
        
                if ($refundTokens > 0) {
                    $uT = $conn->prepare("UPDATE customers SET Q_token = Q_token + :a WHERE id = :cid");
                    $uT->execute([':a'=>$refundTokens, ':cid'=>$customerId]);
                }
        
                $conn->commit();
                echo json_encode(['ok'=>true,'state'=>'empty','refund_qtokens'=>$refundTokens]); exit;
            } else {
                // Update remaining items + totals
                [$sub,$tax,$tot] = pc_recalc_totals($keep);
                $u = $conn->prepare("UPDATE payment_collected
                    SET items_json=:j, subtotal_cents=:sub, tax_cents=:tax, total_cents=:tot, updated_at=NOW()
                  WHERE id=:id AND status IN ('pending','void')");
                $u->execute([':j'=>json_encode($keep), ':sub'=>$sub, ':tax'=>$tax, ':tot'=>$tot, ':id'=>$cart['id']]);
        
                if ($refundTokens > 0) {
                    $uT = $conn->prepare("UPDATE customers SET Q_token = Q_token + :a WHERE id = :cid");
                    $uT->execute([':a'=>$refundTokens, ':cid'=>$customerId]);
                }
        
                $conn->commit();
                echo json_encode(['ok'=>true,'state'=>'pending','subtotal_cents'=>$sub,'total_cents'=>$tot,'refund_qtokens'=>$refundTokens]); exit;
            }
        }


        /* ===== Clear cart (customer) [refund Q-tokens for any discount lines] ===== */
        if ($_GET['action'] === 'cart_clear') {
            $p = json_decode(file_get_contents('php://input'), true) ?: [];
            $customerId = (int)($p['customer_id'] ?? 0);
            $queueId    = (int)($p['queue_id'] ?? 0);
            if ($customerId<=0 || $queueId<=0) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }
        
            $conn->beginTransaction();
        
            // Fetch all open carts for this tuple (normally 1)
            $s = $conn->prepare("
                SELECT id, items_json
                  FROM payment_collected
                 WHERE business_id = ? AND customer_id = ? AND queue_id = ?
                   AND status IN ('pending','void')
                 FOR UPDATE
            ");
            $s->execute([$userQueueId, $customerId, $queueId]);
            $rows = $s->fetchAll(PDO::FETCH_ASSOC) ?: [];
        
            // Aggregate service ids & quantities to compute token refund
            $sidQty = []; // sid => total qty removed
            foreach ($rows as $r) {
                $items = json_decode($r['items_json'] ?? '[]', true) ?: [];
                foreach ($items as $it) {
                    $sid = (int)($it['service_id'] ?? 0);
                    $qty = max(1, (int)($it['qty'] ?? 1));
                    if ($sid > 0) $sidQty[$sid] = ($sidQty[$sid] ?? 0) + $qty;
                }
            }
        
            $refundTokens = 0;
            if ($sidQty) {
                $sids = array_keys($sidQty);
                $ph = implode(',', array_fill(0, count($sids), '?'));
                $m = $conn->prepare("
                    SELECT id, COALESCE(is_discount,0) AS is_discount, COALESCE(discount_qtokens,0) AS discount_qtokens
                      FROM services_items_pos
                     WHERE business_id = ? AND id IN ($ph)
                ");
                $m->execute(array_merge([$userQueueId], $sids));
                while ($r = $m->fetch(PDO::FETCH_ASSOC)) {
                    $sid = (int)$r['id'];
                    $qt  = (int)$r['discount_qtokens'];
                    if ((int)$r['is_discount'] === 1 && $qt > 0) {
                        $refundTokens += $qt * (int)($sidQty[$sid] ?? 0);
                    }
                }
            }
        
            // Delete carts
            $d = $conn->prepare("DELETE FROM payment_collected
                                  WHERE business_id=? AND customer_id=? AND queue_id=? AND status IN ('pending','void')");
            $d->execute([$userQueueId, $customerId, $queueId]);
        
            // Refund tokens if needed
            if ($refundTokens > 0) {
                $uT = $conn->prepare("UPDATE customers SET Q_token = Q_token + :a WHERE id = :cid");
                $uT->execute([':a'=>$refundTokens, ':cid'=>$customerId]);
            }
        
            $conn->commit();
            echo json_encode(['ok'=>true,'state'=>'empty','refund_qtokens'=>$refundTokens]); exit;
        }


        /* ===== Mark paid (customer) ===== */
        if ($_GET['action'] === 'cart_mark_paid') {
            $p = json_decode(file_get_contents('php://input'), true) ?: [];
            $customerId = (int)($p['customer_id'] ?? 0);
            $queueId    = (int)($p['queue_id'] ?? 0);
            $method     = (string)($p['payment_method'] ?? 'cash');
            $external   = (string)($p['external_ref'] ?? '');
            $txnGroup   = (string)($p['txn_group'] ?? '');
            if ($customerId<=0 || $queueId<=0) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }
        
            $conn->beginTransaction();
        
            // make sure columns exist (one-time per php process)
            pc_ensure_reporting_columns($conn);
        
            // Load the open cart
            $cart = pc_get_cart($conn, $userQueueId, $customerId, $queueId);
            if (!$cart) { $conn->rollBack(); echo json_encode(['ok'=>false,'error'=>'no cart']); exit; }
        
            // 1) mark the cart as paid
            $u = $conn->prepare("
              UPDATE payment_collected
                 SET status='paid',
                     payment_method=:m,
                     external_ref=:x,
                     paid_at=NOW(),
                     txn_group=:g
               WHERE id=:id
                 AND status IN ('pending','void')
            ");
            $u->execute([':m'=>$method, ':x'=>$external, ':g'=>$txnGroup ?: null, ':id'=>$cart['id']]);
        
            // 2) enrich the paid row with check-in type + new-client flag + some customer info
            $ci = $conn->prepare("
              SELECT `check-in_type` AS checkin, Total_Visits, firstName, phone
                FROM customers
               WHERE id = ?
               LIMIT 1
            ");
            $ci->execute([$customerId]);
            $cinfo = $ci->fetch(PDO::FETCH_ASSOC) ?: ['checkin'=>null,'Total_Visits'=>null,'firstName'=>null,'phone'=>null];
        
            $isNew = null;
            if ($cinfo && $cinfo['Total_Visits'] !== null) {
              $isNew = ((int)$cinfo['Total_Visits'] <= 1) ? 1 : 0;
            }
        
            $upx = $conn->prepare("
              UPDATE payment_collected
                 SET check_in_type       = :t,
                     is_new_client       = :n,
                     customer_first_name = :fn,
                     customer_phone      = :ph
               WHERE id = :id
            ");
            $upx->execute([
              ':t'  => ($cinfo['checkin'] ?? null),
              ':n'  => $isNew,
              ':fn' => ($cinfo['firstName'] ?? null),
              ':ph' => ($cinfo['phone'] ?? null),
              ':id' => $cart['id']
            ]);
        
            // 3) roll customer lifetime value, last-paid timestamp
            $updC = $conn->prepare("
              UPDATE customers
                 SET lifetime_value_cents = lifetime_value_cents + :inc,
                     last_paid_at         = NOW()
               WHERE id = :cid
            ");
            $updC->execute([':inc'=>(int)$cart['total_cents'], ':cid'=>$customerId]);

            // 4) Award Q-tokens per dollar spent (only if Q_token feature is ON for this business)
            try {
                // ⚠️ If your column has a different name, change loyalty_points_per_dollar here & below
                $bizStmt = $conn->prepare("
                    SELECT Q_token, loyalty_points_per_dollar
                    FROM businesses
                    WHERE id = ?
                    LIMIT 1
                ");
                $bizStmt->execute([$userQueueId]);
                if ($bizRow = $bizStmt->fetch(PDO::FETCH_ASSOC)) {
                    $qFlag     = (int)($bizRow['Q_token'] ?? 0);                   // 1 = Q-tokens ON
                    $perDollar = (int)($bizRow['loyalty_points_per_dollar'] ?? 0); // points per $1

                    // Only award if feature is ON, config > 0, and this is a real customer (not Quick Sale)
                    if ($qFlag === 1 && $perDollar > 0 && $customerId > 0) {
                        $totalCents   = max(0, (int)$cart['total_cents']);
                        $wholeDollars = (int) floor($totalCents / 100);            // 1 point-per-dollar on whole dollars
                        $pointsToAdd  = $wholeDollars * $perDollar;

                        if ($pointsToAdd > 0) {
                            $qUpd = $conn->prepare("
                                UPDATE customers
                                SET Q_token = COALESCE(Q_token, 0) + :pts
                                WHERE id = :cid
                            ");
                            $qUpd->execute([
                                ':pts' => $pointsToAdd,
                                ':cid' => $customerId,
                            ]);
                        }
                    }
                }
            } catch (Throwable $e) {
                // Best-effort only: never block checkout if loyalty fails
                // error_log('POS Q-token award failed: '.$e->getMessage());
            }
        
            $conn->commit();
            echo json_encode([
                'ok'               => true,
                'paid_total_cents' => (int)$cart['total_cents'],
                'txn_group'        => $txnGroup ?: null
            ]);
            exit;
        }
                /* ===== Linkly Cloud (EFTPOS) — "ready?" probe for POS checkout ===== */
        if ($_GET['action'] === 'linkly_ready') {
            global $eftposProvider, $linklyCfg, $userQueueId, $conn;

            // Only report ready if this store is actually set to use Linkly
            $provider = strtolower((string)($eftposProvider ?? ''));
            $isLinkly = (strpos($provider, 'linkly') !== false);

            if (!$isLinkly) {
                // POS is set to Square or nothing
                echo json_encode([
                    'ok'     => true,
                    'ready'  => false,
                    'error'  => 'not_linkly',
                    'provider' => $provider,
                ]);
                exit;
            }

            // Must have env + secret configured in businesses table
            if (empty($linklyCfg['env']) || empty($linklyCfg['secret'])) {
                echo json_encode([
                    'ok'    => true,
                    'ready' => false,
                    'error' => 'not_configured',
                ]);
                exit;
            }

            // Try to obtain/reuse a token as a connectivity check
            $token = linkly_get_token($linklyCfg);
            if (!$token) {
                linkly_set_last_error($conn, $userQueueId, 'TOKEN_FAILED_READY');
                echo json_encode([
                    'ok'    => true,
                    'ready' => false,
                    'error' => 'token_failed',
                ]);
                exit;
            }

            echo json_encode([
                'ok'    => true,
                'ready' => true,
            ]);
            exit;
        }

        /* ===== Linkly Cloud – prefetch token to avoid first-sale lag ===== */
        if ($_GET['action'] === 'linkly_prefetch_token') {
            global $eftposProvider, $linklyCfg, $userQueueId, $conn;

            $provider = strtolower((string)($eftposProvider ?? ''));
            $isLinkly = (strpos($provider, 'linkly') !== false);

            if (!$isLinkly || empty($linklyCfg['env']) || empty($linklyCfg['secret'])) {
                echo json_encode(['ok' => false, 'ready' => false]);
                exit;
            }

            // This will hit Linkly once, then cache the token in $_SESSION
            $tok = linkly_get_token($linklyCfg);
            if (!$tok) {
                linkly_set_last_error($conn, $userQueueId, 'TOKEN_PREFETCH_FAILED');
                echo json_encode(['ok' => false, 'ready' => true, 'token' => false]);
                exit;
            }

            echo json_encode(['ok' => true, 'ready' => true, 'token' => true]);
            exit;
        }


        
        /* ===== Linkly Cloud (EFTPOS) — simple async purchase for POS checkout ===== */

        if ($_GET['action'] === 'linkly_purchase') {
            header('Content-Type: application/json');

            global $eftposProvider, $linklyCfg, $userQueueId, $conn;

            $provider = strtolower((string)($eftposProvider ?? ''));
            if (strpos($provider, 'linkly') === false) {
                echo json_encode(['ok' => false, 'error' => 'not_linkly']); exit;
            }

            $body        = json_decode(file_get_contents('php://input'), true) ?: [];
            $amountCents = (int)($body['amount_cents'] ?? 0);
            $txnGroup    = trim((string)($body['txn_group'] ?? ''));

            if ($amountCents <= 0) {
                echo json_encode(['ok' => false, 'error' => 'bad_amount']); exit;
            }
            if (empty($linklyCfg['env']) || empty($linklyCfg['secret'])) {
                echo json_encode(['ok' => false, 'error' => 'not_configured']); exit;
            }

            $token = linkly_get_token($linklyCfg);
            if (!$token) {
                linkly_set_last_error($conn, $userQueueId, 'TOKEN_FAILED');
                echo json_encode(['ok' => false, 'error' => 'token_failed']); exit;
            }

            $urls      = linkly_env_urls($linklyCfg['env']);
            $sessionId = strtolower(bin2hex(random_bytes(16)));
            $restUrl   = rtrim($urls['rest'], '/') . '/v1/sessions/' . $sessionId . '/transaction?async=true';

            // <=16-char TxnRef from txn_group or fallback timestamp (YYMMDDHHMMSS)
            $fallbackRef = date('ymdHis');
            $sanitized   = preg_replace('/[^A-Za-z0-9]/', '', $txnGroup);
            $txnRef      = substr($sanitized !== '' ? $sanitized : $fallbackRef, 0, 16);

            // Build Notification.Uri pointing back to this script
            $scheme = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') ? 'https' : 'http';
            $host   = $_SERVER['HTTP_HOST']    ?? 'lineupz.ai';
            $script = $_SERVER['SCRIPT_NAME']  ?? '/pos.php';

            // Force HTTPS (callback URLs are expected to be HTTPS)
            $host   = $_SERVER['HTTP_HOST']   ?? 'lineupz.ai';
            $script = $_SERVER['SCRIPT_NAME'] ?? '/pos.php';
            
            $scheme = 'https';
            if (!empty($_SERVER['HTTP_X_FORWARDED_PROTO'])) {
                $scheme = (stripos($_SERVER['HTTP_X_FORWARDED_PROTO'], 'https') !== false) ? 'https' : 'http';
            }
            
            // Don't rely on {{type}} in query string.
            // We read SessionId + ResponseType from the JSON payload in linkly_notify.
            $notifyUri = $scheme.'://'.$host.$script
                       . '?action=linkly_notify'
                       . '&biz='.$userQueueId
                       . '&sid='.$sessionId;


            $request = [
                'Request' => [
                    'Merchant'         => '00',
                    'TxnType'          => 'P',          // purchase
                    'AmtPurchase'      => $amountCents, // cents
                    'TxnRef'           => $txnRef,
                    'CurrencyCode'     => 'AUD',
                    'CutReceipt'       => '0',          // LineUpz prints the receipt
                    'ReceiptAutoPrint' => '0',
                    'Application'      => '00',
                ],
                'Notification' => [
                    'Uri' => $notifyUri,
                    // 'AuthorizationHeader' => 'Bearer your-shared-secret', // optional
                ],
            ];

            $ch = curl_init($restUrl);
            curl_setopt_array($ch, [
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_POST           => true,
                CURLOPT_HTTPHEADER     => [
                    'Content-Type: application/json',
                    'Accept: application/json',
                    'Authorization: Bearer ' . $token,
                ],
                CURLOPT_POSTFIELDS     => json_encode($request),
                CURLOPT_TIMEOUT        => 15,  // just long enough to get "accepted"
            ]);
            $resp = curl_exec($ch);
            $http = curl_getinfo($ch, CURLINFO_HTTP_CODE);
            $err  = curl_error($ch);
            curl_close($ch);

            // Log initial request/response (best-effort)
            try {
                $logStmt = $conn->prepare("
                    INSERT INTO linkly_cloud_logs
                        (business_id,
                         queue_id,
                         environment,
                         cloud_username,
                         session_id,
                         txn_type,
                         txn_ref,
                         amount_cents,
                         currency,
                         http_code,
                         request_json,
                         response_json,
                         created_at)
                    VALUES
                        (:biz,
                         :qid,
                         :env,
                         :user,
                         :session_id,
                         :txn_type,
                         :txn_ref,
                         :amount_cents,
                         :currency,
                         :http_code,
                         :request_json,
                         :response_json,
                         NOW())
                ");

                $logStmt->execute([
                    ':biz'          => $userQueueId,
                    ':qid'          => $userQueueId,
                    ':env'          => (string)($linklyCfg['env']      ?? ''),
                    ':user'         => (string)($linklyCfg['username'] ?? ''),
                    ':session_id'   => $sessionId,
                    ':txn_type'     => 'purchase_init',
                    ':txn_ref'      => $txnRef,
                    ':amount_cents' => $amountCents,
                    ':currency'     => 'AUD',
                    ':http_code'    => (int)$http,
                    ':request_json' => json_encode($request),
                    ':response_json'=> ($resp === false || $resp === '' ? null : (string)$resp),

                ]);
            } catch (Throwable $logEx) {
                error_log('Linkly log insert failed (init): '.$logEx->getMessage());
            }

            if ($resp === false) {
                linkly_set_last_error($conn, $userQueueId, 'curl_error: '.$err);
                echo json_encode(['ok' => false, 'error' => 'curl_error', 'detail' => $err]); exit;
            }
            if ($http >= 400) {
                linkly_set_last_error($conn, $userQueueId, 'http_'.$http.': '.substr((string)$resp, 0, 500));
                echo json_encode(['ok' => false, 'error' => 'http_'.$http]); exit;
            }

            // We don't interpret ApiResponse here; the real result comes via Notification.
            echo json_encode([
                'ok'         => true,
                'mode'       => 'async',
                'session_id' => $sessionId,
            ]);
            exit;
        }

        /* ===== Linkly Cloud — poll session status (async, with REST fallback) ===== */
        if ($_GET['action'] === 'linkly_poll') {
            header('Content-Type: application/json; charset=UTF-8');

            $sessionId = strtolower(trim((string)($_GET['session_id'] ?? $_GET['sid'] ?? '')));
            if ($sessionId === '') {
                echo json_encode(['ok' => false, 'error' => 'bad_session']);
                exit;
            }

            $raw = null;

            // 1) First try to read the notification we logged in linkly_cloud_logs
            try {
                $st = $conn->prepare("
                    SELECT response_json
                      FROM linkly_cloud_logs
                     WHERE business_id = :biz
                       AND session_id  = :sid
                       AND txn_type    = 'transaction'
                     ORDER BY id DESC
                     LIMIT 1
                ");
                $st->execute([
                    ':biz' => $userQueueId,
                    ':sid' => $sessionId,
                ]);
                $raw = $st->fetchColumn();
            } catch (Throwable $e) {
                http_response_code(500);
                echo json_encode(['ok' => false, 'error' => 'db']);
                exit;
            }

            // 2) If no notification yet, fall back to Linkly "transaction status" REST call
            if ($raw === false || $raw === null || $raw === '') {
                try {
                    // Need env + secret to hit Linkly
                    $env    = trim((string)($linklyCfg['env']    ?? ''));
                    $secret = trim((string)($linklyCfg['secret'] ?? ''));
                    if ($env === '' || $secret === '') {
                        // Mis-configured: just keep showing "pending" and let UI time out nicely
                        echo json_encode(['ok' => true, 'state' => 'pending']);
                        exit;
                    }

                    $token = linkly_get_token($linklyCfg);
                    if (!$token) {
                        linkly_set_last_error($conn, $userQueueId, 'STATUS_TOKEN_FAILED');
                        echo json_encode(['ok' => true, 'state' => 'pending']);
                        exit;
                    }

                    $urls      = linkly_env_urls($env);
                    $statusUrl = rtrim($urls['rest'], '/') . '/v1/sessions/' . rawurlencode($sessionId) . '/transaction';


                    $ch = curl_init($statusUrl);
                    curl_setopt_array($ch, [
                        CURLOPT_RETURNTRANSFER => true,
                        CURLOPT_HTTPHEADER     => [
                            'Accept: application/json',
                            'Authorization: Bearer ' . $token,
                        ],
                        CURLOPT_TIMEOUT        => 10,
                    ]);
                    $respBody = curl_exec($ch);
                    $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
                    $err      = curl_error($ch);
                    curl_close($ch);

                    if ($respBody === false) {
                        linkly_set_last_error($conn, $userQueueId, 'STATUS_CURL:' . $err);
                        echo json_encode(['ok' => true, 'state' => 'pending']);
                        exit;
                    }

                    // 202 = still in progress → keep polling
                    if ($httpCode === 202) {
                        echo json_encode(['ok' => true, 'state' => 'pending']);
                        exit;
                    }

                    // 4xx/5xx → treat as a hard failure for this session
                    if ($httpCode >= 400) {
                        linkly_set_last_error(
                            $conn,
                            $userQueueId,
                            'STATUS_HTTP_' . $httpCode . ': ' . substr((string)$respBody, 0, 200)
                        );
                        echo json_encode([
                            'ok'            => true,
                            'state'         => 'done',
                            'approved'      => false,
                            'response_code' => 'HTTP_' . $httpCode,
                            'response_text' => 'Linkly status error (HTTP ' . $httpCode . ')',
                            'rrn'           => '',
                            'rfn'           => '',
                            'host_ref'      => '',
                        ]);
                        exit;
                    }

                    // http 200 with JSON body → use this as our "transaction" response
                    $raw = $respBody;

                    // Best-effort: persist this status so subsequent polls use DB instead of Linkly
                    try {
                        $logStmt = $conn->prepare("
                            INSERT INTO linkly_cloud_logs
                                (business_id,
                                 queue_id,
                                 environment,
                                 cloud_username,
                                 session_id,
                                 txn_type,
                                 txn_ref,
                                 amount_cents,
                                 currency,
                                 http_code,
                                 request_json,
                                 response_json,
                                 created_at)
                            VALUES
                                (:biz,
                                 :qid,
                                 :env,
                                 :user,
                                 :sid,
                                 'transaction',
                                 NULL,
                                 0,
                                 'AUD',
                                 :code,
                                 NULL,
                                 :resp,
                                 NOW())
                        ");
                        $logStmt->execute([
                            ':biz'  => $userQueueId,
                            ':qid'  => $userQueueId,
                            ':env'  => (string)($linklyCfg['env']      ?? ''),
                            ':user' => (string)($linklyCfg['username'] ?? ''),
                            ':sid'  => $sessionId,
                            ':code' => (int)$httpCode,
                            ':resp' => (string)$respBody,
                        ]);
                    } catch (Throwable $logEx) {
                        error_log('Linkly status log insert failed: ' . $logEx->getMessage());
                    }

                } catch (Throwable $e) {
                    // Any failure in the fallback → just stay "pending"
                    echo json_encode(['ok' => true, 'state' => 'pending']);
                    exit;
                }
            }

            // 3) Parse the JSON we now have in $raw (either DB notification or REST status)
            $data = json_decode((string)$raw, true);
            if (!is_array($data)) {
                echo json_encode(['ok' => false, 'error' => 'bad_json']);
                exit;
            }

            // Unwrap ApiResponse → Response
            if (isset($data['Response']) && is_array($data['Response'])) {
                $r = $data['Response'];
            } elseif (isset($data['response']) && is_array($data['response'])) {
                $r = $data['response'];
            } else {
                echo json_encode(['ok' => false, 'error' => 'bad_response']);
                exit;
            }

            $success  = !empty($r['Success']) || (!empty($r['success']) && $r['success'] === true);
            $respCode = trim((string)($r['ResponseCode']  ?? $r['responseCode']  ?? ''));
            $respText = trim((string)($r['ResponseText']  ?? $r['responseText']  ?? ''));
            $rrn      = trim((string)($r['RRN']           ?? $r['rrn']           ?? ''));

            // PurchaseAnalysisData casing differs
            $pad = [];
            if (!empty($r['PurchaseAnalysisData']) && is_array($r['PurchaseAnalysisData'])) {
                $pad = $r['PurchaseAnalysisData'];
            } elseif (!empty($r['purchaseAnalysisData']) && is_array($r['purchaseAnalysisData'])) {
                $pad = $r['purchaseAnalysisData'];
            }

            $rfn     = isset($pad['RFN']) ? trim((string)$pad['RFN'])
                                          : (isset($pad['rfn']) ? trim((string)$pad['rfn']) : '');
            $hostRef = isset($pad['REF']) ? trim((string)$pad['REF'])
                                          : (isset($pad['ref']) ? trim((string)$pad['ref']) : '');

            $approved = ($success && ($respCode === '' || $respCode === '00'));

            echo json_encode([
                'ok'            => true,
                'state'         => 'done',
                'approved'      => $approved,
                'response_code' => $respCode,
                'response_text' => $respText,
                'rrn'           => $rrn,
                'rfn'           => $rfn,
                'host_ref'      => $hostRef,
            ]);
            exit;
        }



        
        /* ===== SQUARE TERMINAL (EFTPOS) — BEGIN ===== */

        /* Ready? (do we have token + device_id saved) */
        if ($_GET['action'] === 'sq_ready') {
          $st = $conn->prepare("SELECT square_access_token, square_terminal_device_id FROM businesses WHERE id = ? LIMIT 1");
          $st->execute([$userQueueId]);
          $row = $st->fetch(PDO::FETCH_ASSOC);
          $ready = ($row && !empty($row['square_access_token']) && !empty($row['square_terminal_device_id']));
          echo json_encode(['ok'=>true, 'ready'=>$ready]); exit;
        }
        
        /* Create a Terminal checkout for the combined amount (in cents) */
        if ($_GET['action'] === 'sq_terminal_checkout') {
          header('Content-Type: application/json');
          $p = json_decode(file_get_contents('php://input'), true) ?: [];
          $amountCents = (int)($p['amount_cents'] ?? 0);
          $txnGroup    = trim((string)($p['txn_group'] ?? ''));
          if ($amountCents <= 0) { echo json_encode(['ok'=>false,'error'=>'bad_amount']); exit; }
        
          $st = $conn->prepare("SELECT square_access_token, square_terminal_device_id FROM businesses WHERE id = ? LIMIT 1");
          $st->execute([$userQueueId]);
          $row = $st->fetch(PDO::FETCH_ASSOC);
          if (!$row || empty($row['square_access_token']) || empty($row['square_terminal_device_id'])) {
            echo json_encode(['ok'=>false,'error'=>'not_ready']); exit;
          }
        
            $payload = [
              'idempotency_key' => bin2hex(random_bytes(16)),
              'checkout' => [
                'amount_money'   => ['amount' => $amountCents, 'currency' => 'AUD'],
                'reference_id'   => ($txnGroup !== '' ? $txnGroup : ('lineupz-'.substr(bin2hex(random_bytes(4)),0,8))),
                'note'           => 'LineUpz POS',
                'device_options' => [
                  'device_id' => $row['square_terminal_device_id'],
                  'skip_receipt_screen' => true   // ✅ POS prints receipt; skip on-terminal prompt
                ]
              ]
            ];

        
          $ch = curl_init('https://connect.squareup.com/v2/terminals/checkouts');
          curl_setopt_array($ch, [
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_POST           => true,
            CURLOPT_POSTFIELDS     => json_encode($payload),
            CURLOPT_HTTPHEADER     => [
              'Authorization: Bearer ' . $row['square_access_token'],
              'Square-Version: ' . (defined('SQUARE_VERSION') ? SQUARE_VERSION : '2025-10-16'),
              'Content-Type: application/json'
            ],
            CURLOPT_TIMEOUT        => 30,
          ]);
          $resp = curl_exec($ch);
          $http = curl_getinfo($ch, CURLINFO_HTTP_CODE);
          $err  = curl_error($ch);
          curl_close($ch);
        
          if ($resp === false) { echo json_encode(['ok'=>false,'error'=>'curl_error','detail'=>$err]); exit; }
          $data = json_decode($resp, true);
          if ($http >= 400) { echo json_encode(['ok'=>false,'error'=>'square_error','detail'=>$data['errors'] ?? null]); exit; }
        
          $chk = $data['checkout'] ?? [];
          echo json_encode(['ok'=>true, 'checkout_id' => $chk['id'] ?? null]); exit;
        }
        
        /* Poll Terminal checkout status */
        if ($_GET['action'] === 'sq_terminal_status') {
          header('Content-Type: application/json');
          $id = trim((string)($_GET['id'] ?? ''));
          if ($id === '') { echo json_encode(['ok'=>false,'error'=>'missing_id']); exit; }
        
          $st = $conn->prepare("SELECT square_access_token FROM businesses WHERE id = ? LIMIT 1");
          $st->execute([$userQueueId]);
          $row = $st->fetch(PDO::FETCH_ASSOC);
          if (!$row || empty($row['square_access_token'])) { echo json_encode(['ok'=>false,'error'=>'no_square_token']); exit; }
        
          $ch = curl_init("https://connect.squareup.com/v2/terminals/checkouts/$id");
          curl_setopt_array($ch, [
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_HTTPHEADER     => [
              'Authorization: Bearer ' . $row['square_access_token'],
              'Square-Version: 2025-10-16',
              'Content-Type: application/json'
            ],
            CURLOPT_TIMEOUT        => 20,
          ]);
          $resp = curl_exec($ch);
          $http = curl_getinfo($ch, CURLINFO_HTTP_CODE);
          $err  = curl_error($ch);
          curl_close($ch);
        
          if ($resp === false) { echo json_encode(['ok'=>false,'error'=>'curl_error','detail'=>$err]); exit; }
          $data = json_decode($resp, true);
          if ($http >= 400) { echo json_encode(['ok'=>false,'error'=>'square_error','detail'=>$data['errors'] ?? null]); exit; }
        
          $chk = $data['checkout'] ?? [];
          echo json_encode([
            'ok'           => true,
            'status'       => $chk['status'] ?? 'UNKNOWN',
            'payment_ids'  => $chk['payment_ids'] ?? [],
            'cancel_reason'=> $chk['cancel_reason'] ?? null
          ]); exit;
        }
        
        /* ===== SQUARE TERMINAL (EFTPOS) — END ===== */
        /* ===== Square Terminal: cancel checkout (clears amount on device) ===== */
        if ($_GET['action'] === 'sq_terminal_cancel') {
          header('Content-Type: application/json');
          $id = trim((string)($_POST['id'] ?? ''));
          if ($id === '') { echo json_encode(['ok'=>false,'error'=>'missing_id']); exit; }
        
          $st = $conn->prepare("SELECT square_access_token FROM businesses WHERE id = ? LIMIT 1");
          $st->execute([$userQueueId]);
          $row = $st->fetch(PDO::FETCH_ASSOC);
          if (!$row || empty($row['square_access_token'])) { echo json_encode(['ok'=>false,'error'=>'no_square_token']); exit; }
        
          $ch = curl_init("https://connect.squareup.com/v2/terminals/checkouts/$id/cancel");
          curl_setopt_array($ch, [
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_POST           => true,
            CURLOPT_POSTFIELDS     => json_encode(new stdClass()), // {}
            CURLOPT_HTTPHEADER     => [
              'Authorization: Bearer ' . $row['square_access_token'],
              'Square-Version: 2025-10-16',
              'Content-Type: application/json'
            ],
            CURLOPT_TIMEOUT        => 20,
          ]);
          $resp = curl_exec($ch);
          $http = curl_getinfo($ch, CURLINFO_HTTP_CODE);
          $err  = curl_error($ch);
          curl_close($ch);
        
          if ($resp === false) { echo json_encode(['ok'=>false,'error'=>'curl_error','detail'=>$err]); exit; }
          if ($http >= 400) { echo json_encode(['ok'=>false,'error'=>'square_error']); exit; }
          echo json_encode(['ok'=>true]); exit;
        }

        


        /* ====== QUICK SALE endpoints (no customer; queue_id = session) ====== */
        if ($_GET['action'] === 'qs_status') {
            $cart = pc_get_quicksale($conn, $userQueueId, $userQueueId); // pending/void only
            echo json_encode(['ok'=>true,'cart'=>$cart ?: null]); exit;
        }
        
        /* ====== QUICK SALE: add/merge items ====== */
    if ($_GET['action'] === 'qs_add_items') {
      try {
        $payload = json_decode(file_get_contents('php://input'), true) ?: [];
        $itemsIn = $payload['items'] ?? [];
        if (!is_array($itemsIn)) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }
    
        // ensure staff columns exist (no-op if already there)
        pc_ensure_reporting_columns($conn);
    
        // Optional staff selected for this QS (for attribution)
        $staffIdIn   = (int)($payload['staff_id'] ?? 0);
        $staffNameIn = null;
        if ($staffIdIn > 0) {
          $stf = $conn->prepare('SELECT name FROM businesses WHERE id = ? LIMIT 1');
          $stf->execute([$staffIdIn]);
          $staffNameIn = (string)($stf->fetchColumn() ?: '');
        }
    
        // ---- QS cannot accept token-required discounts (no wallet)
        // ---- AND cannot accept any "Redo" discount (needs customer context) ----
        if ($itemsIn) {
          $sidList = [];
          foreach ($itemsIn as $it) {
            $sid = (int)($it['service_id'] ?? $it['id'] ?? 0);
            if ($sid > 0) $sidList[] = $sid;
          }
          $sidList = array_values(array_unique($sidList));
          if ($sidList) {
            $ph = implode(',', array_fill(0, count($sidList), '?'));
            $chk = $conn->prepare("
              SELECT id,
                     COALESCE(is_discount,0)       AS is_discount,
                     COALESCE(discount_qtokens,0)  AS discount_qtokens,
                     item_name
              FROM services_items_pos
              WHERE business_id = ? AND id IN ($ph)
            ");
            $chk->execute(array_merge([$userQueueId], $sidList));
            $rules = [];
            while ($r = $chk->fetch(PDO::FETCH_ASSOC)) {
              $rules[(int)$r['id']] = [
                'is_discount' => (int)$r['is_discount'],
                'qt'          => (int)$r['discount_qtokens'],
                'is_redo'     => ((int)$r['is_discount'] === 1) &&
                                 (stripos((string)$r['item_name'], 'redo') !== false),
              ];
            }
            $filtered = [];
            foreach ($itemsIn as $it) {
              $sid = (int)($it['service_id'] ?? $it['id'] ?? 0);
              $rule = $rules[$sid] ?? null;
              // Drop if token-required discount OR a "Redo" discount
              if ($rule && ( ($rule['is_discount'] === 1 && $rule['qt'] > 0) || $rule['is_redo'] )) {
                continue;
              }
              $filtered[] = $it;
            }
            $itemsIn = $filtered;
          }
        }
    
        $conn->beginTransaction();
    
        $existing = pc_get_quicksale($conn, $userQueueId, $userQueueId);
    
        // Merge items
        $merged = [];
        if ($existing && !empty($existing['items_json'])) {
          foreach ($existing['items_json'] as $it) {
            $sid = (int)$it['service_id'];
            $merged[$sid] = [
              'service_id'  => $sid,
              'name'        => $it['name'],
              'price_cents' => (int)$it['price_cents'],
              'qty'         => (int)$it['qty'],
            ];
          }
        }
        foreach ($itemsIn as $it) {
          $sid = (int)($it['service_id'] ?? $it['id'] ?? 0);
          if ($sid <= 0) continue;
          $name  = (string)($it['name'] ?? $it['item_name'] ?? '');
          $price = (int)($it['price_cents'] ?? $it['variation_price_amount'] ?? 0);
          $qty   = max(1, (int)($it['qty'] ?? 1));
          if (isset($merged[$sid])) $merged[$sid]['qty'] += $qty;
          else $merged[$sid] = ['service_id'=>$sid,'name'=>$name,'price_cents'=>$price,'qty'=>$qty];
        }
    
        $itemsArr = array_values($merged);
        [$subtotal,$tax,$total] = pc_recalc_totals($itemsArr);
    
        if ($existing) {
          // Update + (optionally) stamp staff for this QS cart
          $u = $conn->prepare("UPDATE payment_collected
              SET items_json=:j, subtotal_cents=:sub, tax_cents=:tax, total_cents=:tot,
                  updated_at=NOW(), status='pending', queue_id=0, quicksale=1,
                  staff_user_id = COALESCE(:sid, staff_user_id),
                  staff_name    = COALESCE(:sn,  staff_name)
            WHERE id=:id
              AND status IN ('pending','void')
              AND (customer_id IS NULL OR customer_id = 0)");
          $u->execute([
            ':j'=>json_encode($itemsArr), ':sub'=>$subtotal, ':tax'=>$tax, ':tot'=>$total,
            ':id'=>$existing['id'],
            ':sid'=>($staffIdIn>0 ? $staffIdIn : null),
            ':sn' =>($staffIdIn>0 ? $staffNameIn : null),
          ]);
          $id = (int)$existing['id'];
        } else {
          // Insert a fresh QS row (anchored to 0); include staff attribution when provided
          $i = $conn->prepare("INSERT INTO payment_collected
            (business_id, customer_id, queue_id, quicksale, status, items_json,
             subtotal_cents, tax_cents, total_cents, currency, created_at, updated_at,
             staff_user_id, staff_name)
            VALUES (:b, 0, 0, 1, 'pending', :j, :sub, :tax, :tot, 'AUD', NOW(), NOW(),
                    :sid, :sn)");
          $i->execute([
            ':b'=>$userQueueId,
            ':j'=>json_encode($itemsArr), ':sub'=>$subtotal, ':tax'=>$tax, ':tot'=>$total,
            ':sid'=>($staffIdIn>0 ? $staffIdIn : null),
            ':sn' =>($staffIdIn>0 ? $staffNameIn : null),
          ]);
          $id = (int)$conn->lastInsertId();
        }
    
        $conn->commit();
        echo json_encode(['ok'=>true,'id'=>$id,'subtotal_cents'=>$subtotal,'total_cents'=>$total,'items'=>$itemsArr]); exit;
    
      } catch (Throwable $e) {
        if ($conn->inTransaction()) $conn->rollBack();
        http_response_code(500);
        header('Content-Type: application/json');
        error_log($e);
        echo json_encode(['ok'=>false,'error'=>'server error']);
        exit;
      }
    }
    




        if ($_GET['action'] === 'qs_remove_items') {
            $p = json_decode(file_get_contents('php://input'), true) ?: [];
            $serviceIds = $p['service_ids'] ?? [];
            if (!is_array($serviceIds) || !count($serviceIds)) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }

            $conn->beginTransaction();
            $cart = pc_get_quicksale($conn, $userQueueId, $userQueueId);
            if (!$cart) { $conn->commit(); echo json_encode(['ok'=>true,'state'=>'empty']); exit; }

            $keep = [];
            $removeSet = array_map('intval', $serviceIds);
            foreach ($cart['items_json'] as $it) {
                if (!in_array((int)$it['service_id'], $removeSet, true)) $keep[] = $it;
            }

            if (!count($keep)) {
                $d = $conn->prepare("DELETE FROM payment_collected
                  WHERE id = ?
                    AND status IN ('pending','void')
                    AND (queue_id = ? OR queue_id IS NULL OR queue_id = 0)
                    AND (customer_id IS NULL OR customer_id = 0)");
                $d->execute([$cart['id'], $userQueueId]);
                $conn->commit();
                echo json_encode(['ok'=>true,'state'=>'empty']); exit;
            } else {
                [$sub,$tax,$tot] = pc_recalc_totals($keep);
                $u = $conn->prepare("UPDATE payment_collected
                    SET items_json=:j, subtotal_cents=:sub, tax_cents=:tax, total_cents=:tot, updated_at=NOW(), queue_id=0
                  WHERE id=:id
                    AND status IN ('pending','void')
                    AND (customer_id IS NULL OR customer_id = 0)");
                $u->execute([
                    ':j'=>json_encode($keep), ':sub'=>$sub, ':tax'=>$tax, ':tot'=>$tot,
                    ':id'=>$cart['id']
                ]);

                $conn->commit();
                echo json_encode(['ok'=>true,'state'=>'pending','subtotal_cents'=>$sub,'total_cents'=>$tot]); exit;
            }
        }

        if ($_GET['action'] === 'qs_clear') {
            $d = $conn->prepare("DELETE FROM payment_collected
              WHERE business_id = ?
                AND status IN ('pending','void')
                AND (queue_id = ? OR queue_id IS NULL OR queue_id = 0)
                AND (customer_id IS NULL OR customer_id = 0)");
            $d->execute([$userQueueId, $userQueueId]);
            echo json_encode(['ok'=>true,'state'=>'empty']); exit;
        }

        if ($_GET['action'] === 'qs_mark_paid') {
          $p = json_decode(file_get_contents('php://input'), true) ?: [];
          $method   = (string)($p['payment_method'] ?? 'cash');
          $external = (string)($p['external_ref'] ?? '');
          $txnGroup = (string)($p['txn_group'] ?? '');
        
          // ensure staff columns exist
          pc_ensure_reporting_columns($conn);
        
          // Optional: staff attribution on payment
          $staffIdIn   = (int)($p['staff_id'] ?? 0);
          $staffNameIn = null;
          if ($staffIdIn > 0) {
            $stf = $conn->prepare('SELECT name FROM businesses WHERE id = ? LIMIT 1');
            $stf->execute([$staffIdIn]);
            $staffNameIn = (string)($stf->fetchColumn() ?: '');
          }
        
          $conn->beginTransaction();
          $cart = pc_get_quicksale($conn, $userQueueId, $userQueueId);
          if (!$cart) { $conn->rollBack(); echo json_encode(['ok'=>false,'error'=>'no cart']); exit; }
        
          $u = $conn->prepare("UPDATE payment_collected
             SET status='paid',
                 payment_method=:m,
                 external_ref=:x,
                 paid_at=NOW(),
                 txn_group=:g,
                 queue_id=:q,
                 staff_user_id = COALESCE(:sid, staff_user_id),
                 staff_name    = COALESCE(:sn,  staff_name)
           WHERE id=:id
             AND status='pending'
             AND (queue_id = :q OR queue_id IS NULL OR queue_id = 0)
             AND (customer_id IS NULL OR customer_id = 0)");
          $u->execute([
            ':m'=>$method, ':x'=>$external, ':g'=>$txnGroup ?: null, ':q'=>$userQueueId, ':id'=>$cart['id'],
            ':sid'=>($staffIdIn>0 ? $staffIdIn : null),
            ':sn' =>($staffIdIn>0 ? $staffNameIn : null),
          ]);
        
          $conn->commit();
          echo json_encode(['ok'=>true,'paid_total_cents'=>(int)$cart['total_cents'], 'txn_group'=>$txnGroup ?: null]); exit;
        }


        /* ===== Customer Profile API (inline) ===== */

        // Calculate profile header (interval-based reminders etc.)
        // Calculate profile header (interval-based reminders etc.)
        function profile_calc_header(PDO $conn, int $customerId, int $userQueueId): array {
            $stmt1 = $conn->prepare("SELECT change_time FROM status_history WHERE customer_id = ? ORDER BY change_time");
            $stmt1->execute([$customerId]);
            $rows = $stmt1->fetchAll(PDO::FETCH_ASSOC);

            $intervals = [];
            $previous = null;
            foreach ($rows as $r) {
                if ($previous) {
                    $cur = new DateTime($r['change_time']);
                    $diff = $previous->diff($cur);
                    $intervals[] = $diff->days;
                }
                $previous = new DateTime($r['change_time']);
            }

            if (count($intervals) > 2) {
                sort($intervals);
                array_pop($intervals);
                array_shift($intervals);
            }

            $avg = 0;
            if (count($intervals) > 0) {
                $avg = array_sum($intervals) / count($intervals);
            }

            $max1=6*7; $max2=12*7; $max3=18*7;
            $rem1 = $max1;
            if ($avg > 0) { $rem1 = round($avg); if ($rem1 > $max1) $rem1 = $max1; }
            $today = new DateTime();
            $remDate1 = (clone $today)->add(new DateInterval("P".$rem1."D"));
            $rem2 = min(2*$rem1, $max2);
            $remDate2 = (clone $today)->add(new DateInterval("P".$rem2."D"));
            $rem3 = min(3*$rem1, $max3);
            $remDate3 = (clone $today)->add(new DateInterval("P".$rem3."D"));

            $sv = $conn->prepare("
              SELECT change_time
              FROM status_history
              WHERE customer_id = ?
                AND queue_status = 'served'
              ORDER BY change_time DESC
              LIMIT 2
            ");
            $sv->execute([$customerId]);
            $svRows = $sv->fetchAll(PDO::FETCH_COLUMN);
            
            // previous visit (second-most), if it exists
            $lastServedPrevISO = (count($svRows) >= 2) ? $svRows[1] : null;
            // most recent served (first-most), if it exists
            $lastServedAnyISO  = $svRows[0] ?? null;
            // anchor used for Redo logic: previous if available, otherwise most recent
            $redoAnchorISO     = $lastServedPrevISO ?: $lastServedAnyISO;


            $stmt4 = $conn->prepare("SELECT change_time FROM status_history WHERE customer_id = ? ORDER BY change_time DESC LIMIT 2");
            $stmt4->execute([$customerId]);
            $vis = $stmt4->fetchAll(PDO::FETCH_ASSOC);
            $secondMost = "New Client";
            if (count($vis) >= 2) {
                $secondRow = $vis[1];
                $d = new DateTime($secondRow['change_time']);
                $secondMost = $d->format('D d F Y');
            }

            $totalVisits = count($rows);

            return [
                'reminder_in_days'     => $rem1,
                'reminder_date'        => $remDate1->format('Y-m-d H:i:s'),
                'reminder_date2'       => $remDate2->format('Y-m-d H:i:s'),
                'reminder_date3'       => $remDate3->format('Y-m-d H:i:s'),
                'second_most_recent'   => $secondMost,
                'total_visits'         => $totalVisits,
                'last_served_prev_iso' => $lastServedPrevISO, // <-- used by client to enable/disable Redo
                'redo_anchor_iso'      => $redoAnchorISO   // <-- add this
            ];
        }


        if ($_GET['action'] === 'customer_profile_data') {
            $customerId = (int)($_GET['customer_id'] ?? 0);
            if ($customerId <= 0) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }

            $stmt = $conn->prepare("SELECT id, firstName, phone, sms_notification, Q_token, Notes, image_url1, image_url2, image_url3 FROM customers WHERE id=? LIMIT 1");
            $stmt->execute([$customerId]);
            $cust = $stmt->fetch(PDO::FETCH_ASSOC);
            if (!$cust) { echo json_encode(['ok'=>false,'error'=>'not found']); exit; }

            $stmtB = $conn->prepare("
                SELECT
                  business_name,
                  Q_token,
                  Debranding,
                  plus_qtokens,
                  COALESCE(pos,0) AS pos,
                  COALESCE(loyalty_program_name, 'Q-tokens') AS loyalty_program_name
                FROM businesses
                WHERE id = ?
                LIMIT 1
            ");
            $stmtB->execute([$userQueueId]);
            $biz = $stmtB->fetch(PDO::FETCH_ASSOC) ?: [
                'Q_token'              => 0,
                'Debranding'           => 0,
                'plus_qtokens'         => 0,
                'business_name'        => '',
                'pos'                  => 0,
                'loyalty_program_name' => 'Q-tokens'
            ];
            
                        

            $hdr = profile_calc_header($conn, $customerId, $userQueueId);

            $images = [];
            foreach (['image_url1','image_url2','image_url3'] as $k) {
                if (!empty($cust[$k])) $images[] = $cust[$k];
            }

            echo json_encode(['ok'=>true, 'customer'=>[
                'id'=>$cust['id'],
                'firstName'=>$cust['firstName'],
                'phone'=>$cust['phone'],
                'sms_notification'=>(int)$cust['sms_notification'],
                'Q_token'=>(int)$cust['Q_token'],
                'Notes'=>$cust['Notes'],
                'images'=>$images
            ], 'business'=>$biz, 'header'=>$hdr]); exit;
        }
        
        /* ===== Customer reviews (all, newest first) ===== */
        if ($_GET['action'] === 'customer_reviews') {
            $customerId = (int)($_GET['customer_id'] ?? 0);
            if ($customerId <= 0) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }
        
            $stmt = $conn->prepare("
              SELECT
                created_at_utc                 AS ts_utc,
                staff_name,
                COALESCE(store_star_review,0)  AS store_star,
                COALESCE(staff_star_review,0)  AS staff_star,
                store_review,
                staff_review
              FROM reviews
              WHERE queue_id = :qid
                AND customer_id = :cid
              ORDER BY created_at_utc DESC
              LIMIT 200
            ");
            $stmt->execute([':qid' => $userQueueId, ':cid' => $customerId]);
            $rows = $stmt->fetchAll(PDO::FETCH_ASSOC) ?: [];
            
            /* UTC → Australia/Sydney for display */
            $tzSyd = new DateTimeZone('Australia/Sydney');
            foreach ($rows as &$r) {
              $u = $r['ts_utc'] ?? null;
              if ($u) {
                $dt = new DateTime($u, new DateTimeZone('UTC'));
                $dt->setTimezone($tzSyd);
                $r['ts'] = $dt->format('Y-m-d H:i:s');
              } else {
                $r['ts'] = null;
              }
              unset($r['ts_utc']);
            }
            unset($r);
            
            echo json_encode(['ok'=>true, 'reviews'=>$rows]); exit;

        }


        if ($_GET['action'] === 'customer_notes_save') {
            $p = json_decode(file_get_contents('php://input'), true) ?: [];
            $customerId = (int)($p['customer_id'] ?? 0);
            $notes      = (string)($p['notes'] ?? '');
            if ($customerId<=0) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }
            $u = $conn->prepare("UPDATE customers SET Notes = :n WHERE id = :id");
            $u->execute([':n'=>$notes, ':id'=>$customerId]);
            echo json_encode(['ok'=>true]); exit;
        }

        if ($_GET['action'] === 'customer_sms_toggle') {
            $p = json_decode(file_get_contents('php://input'), true) ?: [];
            $customerId = (int)($p['customer_id'] ?? 0);
            $status     = (int)($p['status'] ?? 0) ? 1 : 0;
            if ($customerId<=0) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }
            $u = $conn->prepare("UPDATE customers SET sms_notification = :s WHERE id = :id");
            $u->execute([':s'=>$status, ':id'=>$customerId]);
            echo json_encode(['ok'=>true]); exit;
        }

        if ($_GET['action'] === 'customer_qtokens_add') {
            $p = json_decode(file_get_contents('php://input'), true) ?: [];
            $customerId = (int)($p['customer_id'] ?? 0);
            $amount     = max(0, (int)($p['amount'] ?? 0));
            if ($customerId<=0 || $amount<=0) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }
            $u = $conn->prepare("UPDATE customers SET Q_token = Q_token + :a WHERE id = :id");
            $u->execute([':a'=>$amount, ':id'=>$customerId]);
            echo json_encode(['ok'=>true]); exit;
        }

        if ($_GET['action'] === 'customer_qtokens_claim') {
            $p = json_decode(file_get_contents('php://input'), true) ?: [];
            $customerId = (int)($p['customer_id'] ?? 0);
            $amount     = max(0, (int)($p['amount'] ?? 0));
            if ($customerId<=0 || $amount<=0) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }
            $conn->beginTransaction();
            $s = $conn->prepare("SELECT Q_token FROM customers WHERE id = ? FOR UPDATE");
            $s->execute([$customerId]);
            $cur = (int)($s->fetchColumn() ?: 0);
            if ($cur < $amount) { $conn->rollBack(); echo json_encode(['ok'=>false,'error'=>'insufficient']); exit; }
            $u = $conn->prepare("UPDATE customers SET Q_token = Q_token - :a WHERE id = :id");
            $u->execute([':a'=>$amount, ':id'=>$customerId]);
            $conn->commit();
            echo json_encode(['ok'=>true]); exit;
        }
        
        /* ===== Finish Service (record duration, TZ-safe; cooldown enforced in DB) ===== */
        if ($_GET['action'] === 'finish_service') {
            try {
                // Accept both JSON body and normal POST form (for offline queue replay)
                $p = json_decode(file_get_contents('php://input'), true);
                $customerId = 0;
        
                if (is_array($p)) {
                    $customerId = (int)($p['customer_id'] ?? 0);
                }
                if ($customerId <= 0) {
                    $customerId = (int)($_POST['customer_id'] ?? $_GET['customer_id'] ?? 0);
                }
        
        
                
                // Cooldown in DB timezone
                $chk = $conn->prepare("
                    SELECT TIMESTAMPDIFF(SECOND, created_at, NOW()) AS age_secs
                      FROM service_time
                     WHERE customer_id = ?
                     ORDER BY created_at DESC
                     LIMIT 1
                ");
                $chk->execute([$customerId]);
                $age = $chk->fetchColumn();
                if ($age !== false && $age !== null && (int)$age < 7200) {
                    http_response_code(409);
                    echo json_encode(['ok'=>false,'error'=>'cooldown','retry_after_secs'=>7200 - (int)$age]); exit;
                }
        
                // Who served + when service started (Sydney)
                $s = $conn->prepare("SELECT staff_user_id, served_by_staff FROM customers WHERE id = ? LIMIT 1");
                $s->execute([$customerId]);
                $row = $s->fetch(PDO::FETCH_ASSOC);
                if (!$row) { echo json_encode(['ok'=>false,'error'=>'not found']); exit; }
        
                $tz = new DateTimeZone('Australia/Sydney');
                $now = new DateTime('now', $tz);
        
                $staffId     = (int)($row['staff_user_id'] ?? 0);
                $servedAtStr = $row['served_by_staff'] ?? null;
        
                $secs = 0;
                if (!empty($servedAtStr) && $servedAtStr !== '0000-00-00 00:00:00') {
                    $servedAt = DateTime::createFromFormat('Y-m-d H:i:s', $servedAtStr, $tz) ?: new DateTime($servedAtStr, $tz);
                    if ($servedAt instanceof DateTime) {
                        $secs = max(0, $now->getTimestamp() - $servedAt->getTimestamp());
                    }
                }
                if ($secs === 0) {
                    $h = $conn->prepare("SELECT change_time FROM status_history WHERE customer_id = ? AND queue_status = 'served' ORDER BY change_time DESC LIMIT 1");
                    $h->execute([$customerId]);
                    $hist = $h->fetchColumn();
                    if ($hist) {
                        $servedAt2 = DateTime::createFromFormat('Y-m-d H:i:s', $hist, $tz) ?: new DateTime($hist, $tz);
                        if ($servedAt2 instanceof DateTime) {
                            $secs = max(0, $now->getTimestamp() - $servedAt2->getTimestamp());
                        }
                    }
                }
                if ($staffId <= 0 && !empty($_SESSION['user_id'])) {
                    $staffId = (int)$_SESSION['user_id'];
                }
        
                // Persist: INSERT service_time + mark customer as finished=1
                $conn->beginTransaction();
        
                $i = $conn->prepare("INSERT INTO service_time (customer_id, staff_id, served_time_seconds, created_at)
                                     VALUES (?,?,?, NOW())");
                $i->execute([$customerId, $staffId, $secs]);
        
                // <<< NEW: mark finished >>>
                $u = $conn->prepare("UPDATE customers SET finished = 1, finished_at = NOW() WHERE id = :cid");
                $u->execute([':cid' => $customerId]);
        
                $conn->commit();
        
                echo json_encode(['ok'=>true, 'served_time_seconds'=>$secs]); exit;
        
            } catch (Throwable $e) {
                if ($conn->inTransaction()) $conn->rollBack();
                http_response_code(500);
                echo json_encode(['ok'=>false,'error'=>'server error']); exit;
            }
        }



        /* ===== Finish Service status (cooldown check - DB does the math) ===== */
        if ($_GET['action'] === 'finish_service_status') {
            try {
                $customerId = (int)($_GET['customer_id'] ?? 0);
                if ($customerId <= 0) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }
        
                // Get age in seconds of the last finish record using DB time
                $s = $conn->prepare("
                    SELECT TIMESTAMPDIFF(SECOND, created_at, NOW()) AS age_secs
                      FROM service_time
                     WHERE customer_id = ?
                     ORDER BY created_at DESC
                     LIMIT 1
                ");
                $s->execute([$customerId]);
                $age = $s->fetchColumn();
                if ($age === false || $age === null) {
                    echo json_encode(['ok'=>true, 'allowed'=>true, 'retry_after_secs'=>0]); exit;
                }
        
                $age = (int)$age;
                if ($age >= 7200) {
                    echo json_encode(['ok'=>true, 'allowed'=>true, 'retry_after_secs'=>0]); exit;
                } else {
                    echo json_encode(['ok'=>true, 'allowed'=>false, 'retry_after_secs'=>7200 - $age]); exit;
                }
        
            } catch (Throwable $e) {
                http_response_code(500);
                echo json_encode(['ok'=>false,'error'=>'server error']); exit;
            }
        }
        
        /* ===== Customer email (get) ===== */
        if ($_GET['action'] === 'customer_email_get') {
            $cid = (int)($_GET['customer_id'] ?? 0);
            if ($cid <= 0) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }
            $s = $conn->prepare("SELECT email FROM customers WHERE id = ? LIMIT 1");
            $s->execute([$cid]);
            $email = (string)($s->fetchColumn() ?: '');
            echo json_encode(['ok'=>true, 'email'=>$email]); exit;
        }
        
        /* ===== Customer email (save) ===== */
        if ($_GET['action'] === 'customer_email_save') {
            $p = json_decode(file_get_contents('php://input'), true) ?: [];
            $cid   = (int)($p['customer_id'] ?? 0);
            $email = trim((string)($p['email'] ?? ''));
            if ($cid <= 0) { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }
            // (optional) super-light validation
            if ($email !== '' && !filter_var($email, FILTER_VALIDATE_EMAIL)) {
                echo json_encode(['ok'=>false,'error'=>'invalid email']); exit;
            }
            $u = $conn->prepare("UPDATE customers SET email = :e WHERE id = :id");
            $u->execute([':e'=>$email, ':id'=>$cid]);
            echo json_encode(['ok'=>true]); exit;
        }
        
        /* ===== Email combined receipt for a txn group (one email only) ===== */
        if ($_GET['action'] === 'email_receipts') {
            $p = json_decode(file_get_contents('php://input'), true) ?: [];
            $txnGroup = trim((string)($p['txn_group'] ?? ''));
            $fallback = trim((string)($p['fallback_email'] ?? '')); // optional: green-box email
        
            if ($txnGroup === '') { echo json_encode(['ok'=>false,'error'=>'missing txn_group']); exit; }
        
            // Pull all paid rows in the group (customer + quick sale)
            $st = $conn->prepare("
              SELECT pc.id, pc.customer_id, pc.total_cents, pc.items_json, pc.payment_method, pc.paid_at, pc.currency,
                     c.email AS customer_email, c.firstName AS customer_name,
                     b.business_name, b.logo_pic
                FROM payment_collected pc
           LEFT JOIN customers  c ON c.id = pc.customer_id
           LEFT JOIN businesses b ON b.id = pc.business_id
               WHERE pc.business_id = :bid
                 AND pc.status = 'paid'
                 AND pc.txn_group = :g
            ");
            $st->execute([':bid'=>$userQueueId, ':g'=>$txnGroup]);
            $rows = $st->fetchAll(PDO::FETCH_ASSOC);
        
            if (!$rows) { echo json_encode(['ok'=>true,'sent'=>0,'skipped'=>1,'debug'=>[['reason'=>'no rows in group']]]); exit; }
        
            // ---------- choose recipient ----------
            $emails = [];
            foreach ($rows as $r) {
                $e = trim((string)($r['customer_email'] ?? ''));
                if ($e !== '' && filter_var($e, FILTER_VALIDATE_EMAIL)) { $emails[$e] = true; }
            }
            $to = '';
            if ($fallback !== '' && filter_var($fallback, FILTER_VALIDATE_EMAIL)) {
                $to = $fallback;
            } elseif (count($emails) === 1) {
                $to = array_keys($emails)[0];
            } else {
                // ambiguous or none: require fallback
                echo json_encode(['ok'=>true,'sent'=>0,'skipped'=>1,'debug'=>[['reason'=>'no single recipient (add fallback_email)']]]); exit;
            }
        
            // ---------- helpers ----------
            $fmt = function(int $c){ return '$'.number_format($c/100, 2); };
            $absLogo = function($path){
                $p = trim((string)$path);
                if ($p === '') return '';
                if (preg_match('~^https?://~i', $p)) return $p;
                // make absolute using lineupz.ai
                if ($p[0] === '/') return 'https://lineupz.ai'.$p;
                return 'https://lineupz.ai/'.$p;
            };

            // ---------- business branding ----------
            $bizName = $rows[0]['business_name'] ?: 'Receipt';
            $logoUrl = $absLogo($rows[0]['logo_pic'] ?? '');
            $hasLogo = ($logoUrl !== '');
            
            $titleBlock = $hasLogo
              ? "<div><div style=\"font-size:12px;color:#666;\">Tax invoice — Group "
                  . htmlspecialchars($txnGroup)
                  . "</div></div>"
              : "<div>
                   <div style=\"font-size:18px;font-weight:700;\">"
                     . htmlspecialchars($bizName)
                     . "</div>
                   <div style=\"font-size:12px;color:#666;\">Tax invoice — Group "
                     . htmlspecialchars($txnGroup)
                     . "</div>
                 </div>";

        
            // ---------- aggregate items across ALL orders ----------
            $agg = []; // key: name|price_cents => ['name','price','qty']
            $grandTotal = 0;
            foreach ($rows as $r) {
                $grandTotal += (int)$r['total_cents'];
                $items = json_decode($r['items_json'] ?? '[]', true) ?: [];
                foreach ($items as $it) {
                    $name = (string)($it['name'] ?? 'Item');
                    $price= (int)($it['price_cents'] ?? 0);
                    $qty  = (int)($it['qty'] ?? 1);
                    $key  = $name.'|'.$price;
                    if (!isset($agg[$key])) $agg[$key] = ['name'=>$name,'price'=>$price,'qty'=>0];
                    $agg[$key]['qty'] += $qty;
                }
            }
            ksort($agg);
            $linesHtml = '';
            foreach ($agg as $row) {
                $line = $row['qty'] * $row['price'];
                $linesHtml .= "
                  <tr>
                    <td style='padding:6px 8px;border-bottom:1px solid #eee;'>".htmlspecialchars($row['name'])."</td>
                    <td style='padding:6px 8px;text-align:center;border-bottom:1px solid #eee;'>{$row['qty']}</td>
                    <td style='padding:6px 8px;text-align:right;border-bottom:1px solid #eee;'>{$fmt($row['price'])}</td>
                    <td style='padding:6px 8px;text-align:right;border-bottom:1px solid #eee;'>{$fmt($line)}</td>
                  </tr>";
            }
        
            // ---------- simple sub-order breakdown ----------
            $ordersHtml = '';
            foreach ($rows as $r) {
                $who   = ($r['customer_id'] ? ($r['customer_name'] ?: 'Customer') : 'Quick Sale');
                $amt   = (int)$r['total_cents'];
                $meth  = strtoupper((string)($r['payment_method'] ?: 'CASH'));
                $ordersHtml .= "
                  <tr>
                    <td style='padding:4px 8px;border-bottom:1px solid #eee;'>#{$r['id']}</td>
                    <td style='padding:4px 8px;border-bottom:1px solid #eee;'>".htmlspecialchars($who)."</td>
                    <td style='padding:4px 8px;border-bottom:1px solid #eee;'>".htmlspecialchars($meth)."</td>
                    <td style='padding:4px 8px;border-bottom:1px solid #eee;text-align:right;'>{$fmt($amt)}</td>
                  </tr>";
            }
        
            // GST component of GST-inclusive total
            $gstCents  = (int)round($grandTotal / 11);
            $exclCents = max(0, $grandTotal - $gstCents);
        
            // time (AEST) – use newest paid_at in group for the header timestamp
            $latestPaid = max(array_map(fn($r)=>strtotime($r['paid_at'] ?: 'now'), $rows));
            $dt = new DateTime('@'.$latestPaid); $dt->setTimezone(new DateTimeZone('Australia/Sydney'));
            $whenAEST = $dt->format('D d M Y, h:i A (AEST)');
        
            $subject = "Tax invoice – {$bizName} – Group {$txnGroup}";
            $html = "<!doctype html><html><body style='font-family:Arial,Helvetica,sans-serif;color:#111;margin:0;padding:0;background:#f7f7f9;'>
              <div style='max-width:720px;margin:0 auto;padding:16px 12px;'>
                <div style='background:#fff;border:1px solid #e9ecf2;border-radius:12px;overflow:hidden;'>
                  <div style='padding:16px 18px;border-bottom:1px solid #e9ecf2;display:flex;align-items:center;gap:12px;'>
                    ".($hasLogo
                        ? "<img src=\"".htmlspecialchars($logoUrl)."\" alt=\"".htmlspecialchars($bizName)." logo\" style=\"height:44px;\">"
                        : ""
                      )."
                    {$titleBlock}

                    <div style='margin-left:auto;text-align:right;font-size:12px;color:#444;'>
                      <div>{$whenAEST}</div>
                    </div>
                  </div>
        
                  <div style='padding:14px 18px;'>
                    <h3 style='margin:0 0 8px;font-size:16px;'>Items </h3>
                    <table width='100%' cellspacing='0' cellpadding='0' style='border-collapse:collapse;font-size:14px;'>
                      <thead>
                        <tr>
                          <th align='left'  style='padding:6px 8px;border-bottom:2px solid #e9ecf2;'>Item</th>
                          <th align='center' style='padding:6px 8px;border-bottom:2px solid #e9ecf2;'>Qty</th>
                          <th align='right' style='padding:6px 8px;border-bottom:2px solid #e9ecf2;'>Unit</th>
                          <th align='right' style='padding:6px 8px;border-bottom:2px solid #e9ecf2;'>Line</th>
                        </tr>
                      </thead>
                      <tbody>{$linesHtml}</tbody>
                    </table>
        
                    <div style='margin-top:12px;border-top:1px dashed #e5e8ef;padding-top:10px;display:flex;gap:12px;flex-wrap:wrap;align-items:flex-end;'>
                      <div style='flex:1 1 auto;color:#444;font-size:12px;'>Prices shown <strong>include GST</strong>.</div>
                      <div style='flex:0 0 300px;margin-left:auto;'>
                        <table width='100%' cellspacing='0' cellpadding='0' style='font-size:14px;'>
                          <tr><td style='padding:4px 8px;color:#666;'>Subtotal (excl. GST):</td><td align='right' style='padding:4px 8px;'>{$fmt($exclCents)}</td></tr>
                          <tr><td style='padding:4px 8px;color:#666;'>GST (10% incl.):</td><td align='right' style='padding:4px 8px;'>{$fmt($gstCents)}</td></tr>
                          <tr><td style='padding:6px 8px;border-top:1px solid #e9ecf2;font-weight:700;'>Total paid:</td><td align='right' style='padding:6px 8px;border-top:1px solid #e9ecf2;font-weight:700;'>{$fmt($grandTotal)}</td></tr>
                        </table>
                      </div>
                    </div>
        
                    <h3 style='margin:18px 0 6px;font-size:16px;'>Orders included (".count($rows).")</h3>
                    <table width='100%' cellspacing='0' cellpadding='0' style='border-collapse:collapse;font-size:13px;'>
                      <thead>
                        <tr>
                          <th align='left'  style='padding:6px 8px;border-bottom:2px solid #e9ecf2;'>Order #</th>
                          <th align='left'  style='padding:6px 8px;border-bottom:2px solid #e9ecf2;'>Customer</th>
                          <th align='left'  style='padding:6px 8px;border-bottom:2px solid #e9ecf2;'>Method</th>
                          <th align='right' style='padding:6px 8px;border-bottom:2px solid #e9ecf2;'>Amount</th>
                        </tr>
                      </thead>
                      <tbody>{$ordersHtml}</tbody>
                    </table>
        
                    <div style='margin-top:12px;font-size:11px;color:#8891a1;'>Thank you for your business.</div>
                  </div>
                </div>
              </div>
            </body></html>";
        
            // headers
            $fromDomain = $_SERVER['SERVER_NAME'] ?? 'example.com';
            $fromEmail  = "no-reply@lineupz.ai"; // use a domain you control
            $headers  = "MIME-Version: 1.0\r\n";
            $headers .= "Content-type: text/html; charset=UTF-8\r\n";
            $headers .= "From: ".mb_encode_mimeheader($bizName)." <{$fromEmail}>\r\n";
            $headers .= "Reply-To: {$fromEmail}\r\n";
        
            $ok = @mail($to, $subject, $html, $headers);
            if (!$ok) {
                error_log("Mail failed for txn_group={$txnGroup} to={$to}");
            }

            if ($ok) echo json_encode(['ok'=>true,'sent'=>1,'skipped'=>0,'to'=>$to]); 
            else     echo json_encode(['ok'=>true,'sent'=>0,'skipped'=>1,'to'=>$to,'debug'=>[['reason'=>'mail_failed']]]); 
            exit;
        }
        
        /* ===== Staff insights (today) ===== */
        if ($_GET['action'] === 'staff_stats') {
            header('Content-Type: application/json; charset=UTF-8');
            try {
                /* ===== Australia/Sydney “today” (match report page) ===== */
                $tzSyd = new DateTimeZone('Australia/Sydney');
                $today = (new DateTime('now', $tzSyd))->format('Y-m-d');
        
                /* UTC window that corresponds to “today” in Sydney (for reviews) */
                $startSyd = new DateTime('today', $tzSyd);
                $endSyd   = (clone $startSyd)->modify('+1 day');
                $utcFrom  = (clone $startSyd)->setTimezone(new DateTimeZone('UTC'))->format('Y-m-d H:i:s');
                $utcTo    = (clone $endSyd)->setTimezone(new DateTimeZone('UTC'))->format('Y-m-d H:i:s');
        
                /* ===== Pull day-scope from the time capsule (for wait + cancellations) ===== */
                $stmt = $conn->prepare("
                  SELECT
                    id, firstName, staff_name, wait_time,
                    served_by_staff, deleted_by_staff, delete_by_customer, added_to_queue
                  FROM ".CUST_TBL."
                  WHERE queue_id = :qid
                    AND DATE(COALESCE(served_by_staff, deleted_by_staff, delete_by_customer, added_to_queue)) = :d
                  ORDER BY added_to_queue
                ");
                $stmt->execute([':qid'=>$userQueueId, ':d'=>$today]);
                $rows = $stmt->fetchAll(PDO::FETCH_ASSOC) ?: [];
        
                /* ===== Buckets (wait & cancellations only) ===== */
                $canceledByStaffPerHr = array_fill(0, 24, 0);
                $canceledByCustPerHr  = array_fill(0, 24, 0);
                $waitSumPerHour       = array_fill(0, 24, 0);
                $waitCountPerHour     = array_fill(0, 24, 0);
        
                foreach ($rows as $c) {
                    // Checked-in hour for wait averaging
                    if (!empty($c['added_to_queue']) && substr($c['added_to_queue'], 0, 4) !== '0000') {
                        $added = new DateTime($c['added_to_queue'], $tzSyd);
                        $hAdded = (int)$added->format('G');
                        if ($c['wait_time'] !== null) {
                            $waitSumPerHour[$hAdded]   += (int)$c['wait_time'];
                            $waitCountPerHour[$hAdded] += 1;
                        }
                    }
        
                    // Staff-cancelled
                    if (!empty($c['deleted_by_staff']) && substr($c['deleted_by_staff'], 0, 4) !== '0000') {
                        $dts = new DateTime($c['deleted_by_staff'], $tzSyd);
                        if ($dts->format('Y-m-d') === $today) {
                            $hs = (int)$dts->format('G');
                            $canceledByStaffPerHr[$hs]++;
                        }
                    }
        
                    // Customer-cancelled
                    if (!empty($c['delete_by_customer']) && substr($c['delete_by_customer'], 0, 4) !== '0000') {
                        $dtc = new DateTime($c['delete_by_customer'], $tzSyd);
                        if ($dtc->format('Y-m-d') === $today) {
                            $hc = (int)$dtc->format('G');
                            $canceledByCustPerHr[$hc]++;
                        }
                    }
                }
        
                /* ===== Average wait per hour ===== */
                $avgWaitPerHr = [];
                for ($i = 0; $i < 24; $i++) {
                    $avgWaitPerHr[$i] = $waitCountPerHour[$i]
                        ? round($waitSumPerHour[$i] / $waitCountPerHour[$i], 1)
                        : 0.0;
                }
        
        /* ===== Turnover per staff per hour (from payment_collected) ===== */
        $turnoverByStaff = [];        // staff_name => [24] cents
        $turnoverTotals  = [];        // staff_name => total cents (for pie)
        
        // Use the same Sydney → UTC window you use in business_report.php
        $stmtRev = $conn->prepare("
          SELECT
            COALESCE(pc.staff_name, c.staff_name, '') AS staff_name,
            pc.paid_at,
            pc.total_cents
          FROM payment_collected pc
          LEFT JOIN customers c ON c.id = pc.customer_id
          WHERE pc.business_id = :bid
            AND pc.status = 'paid'
            AND pc.paid_at >= :from
            AND pc.paid_at <  :to
        ");
        $stmtRev->execute([
          ':bid'  => $userQueueId,
          ':from' => $utcFrom,  // same as compute_business_report
          ':to'   => $utcTo,
        ]);
        
        while ($r = $stmtRev->fetch(PDO::FETCH_ASSOC)) {
            $sn    = trim((string)($r['staff_name'] ?? '')) ?: '—';
            $cents = (int)($r['total_cents'] ?? 0);
            $paid  = $r['paid_at'] ?? null;
            if ($cents <= 0 || !$paid) continue;
        
            // Convert paid_at (UTC) -> Sydney hour bucket 0–23
            $dt = new DateTime($paid, new DateTimeZone('UTC'));
            $dt->setTimezone($tzSyd);
            $h = (int)$dt->format('G');  // 0–23 in Australia/Sydney
        
            if ($h < 0 || $h > 23) continue;
        
            if (!isset($turnoverByStaff[$sn])) {
                $turnoverByStaff[$sn] = array_fill(0, 24, 0);
            }
            $turnoverByStaff[$sn][$h] += $cents;
        
            if (!isset($turnoverTotals[$sn])) $turnoverTotals[$sn] = 0;
            $turnoverTotals[$sn] += $cents;
        }

        
                /* Build pie list: turnover by staff (cents) */
                $turnoverPie = [];
                foreach ($turnoverTotals as $name => $cents) {
                    if ($cents <= 0) continue;
                    $turnoverPie[] = [
                        'staff_name'      => $name,
                        'turnover_cents'  => $cents
                    ];
                }
                usort($turnoverPie, function($a, $b) {
                    return $b['turnover_cents'] <=> $a['turnover_cents'];
                });
        
                /* ===== Trim to active hours window ===== */
                $labels = [];
                for ($i = 0; $i < 24; $i++) {
                    $labels[] = sprintf('%02d:00', $i);
                }
        
                $active = array_fill(0, 24, 0);
        
                // Mark hours that have any turnover
                foreach ($turnoverByStaff as $arr) {
                    for ($i = 0; $i < 24; $i++) {
                        if (!empty($arr[$i])) {
                            $active[$i] = 1;
                        }
                    }
                }
        
                // Mark hours with cancellations or wait
                for ($i = 0; $i < 24; $i++) {
                    if ($canceledByStaffPerHr[$i] + $canceledByCustPerHr[$i] > 0 || $avgWaitPerHr[$i] > 0) {
                        $active[$i] = 1;
                    }
                }
        
                $first = null;
                $last  = null;
                for ($i = 0; $i < 24; $i++) {
                    if ($active[$i] > 0) { $first = $i; break; }
                }
                for ($i = 23; $i >= 0; $i--) {
                    if ($active[$i] > 0) { $last = $i; break; }
                }
        
                /* ===== Build hourly series (turnover in dollars) ===== */
                $series = [];
                // Sort staff by total turnover desc
                uasort($turnoverByStaff, function($a, $b) {
                    return array_sum($b) <=> array_sum($a);
                });
        
                if ($first !== null && $last !== null && $last >= $first) {
                    $len    = $last - $first + 1;
                    $labels = array_slice($labels, $first, $len);
        
                    foreach ($turnoverByStaff as $name => $arr) {
                        $sliceCents = array_slice($arr, $first, $len);
                        $series[] = [
                            'label' => $name,
                            // convert cents → dollars for the chart
                            'data'  => array_map(function($c) { return round($c / 100, 2); }, $sliceCents),
                        ];
                    }
        
                    $cancelStaffPerHr = array_slice($canceledByStaffPerHr, $first, $len);
                    $cancelCustPerHr  = array_slice($canceledByCustPerHr,  $first, $len);
                    $avgWaitPerHr     = array_slice($avgWaitPerHr,         $first, $len);
                } else {
                    $labels           = [];
                    $series           = [];
                    $cancelStaffPerHr = [];
                    $cancelCustPerHr  = [];
                    $avgWaitPerHr     = [];
                }
        
                $hourly = [
                    'labels'          => $labels,
                    'series'          => $series,              // turnover per staff per hour (in dollars)
                    'cancel_staff'    => $cancelStaffPerHr,    // per hour (count)
                    'cancel_customer' => $cancelCustPerHr,     // per hour (count)
                    'avg_wait'        => $avgWaitPerHr         // minutes
                ];
        
                /* ===== Pies: 5★ reviews by staff (unchanged) ===== */
                $stmtFive = $conn->prepare("
                  SELECT staff_name, COUNT(*) AS reviews
                  FROM reviews
                  WHERE queue_id = :qid
                    AND created_at_utc >= :f AND created_at_utc < :t
                    AND staff_star_review = 5
                  GROUP BY staff_name
                  ORDER BY reviews DESC
                ");
                $stmtFive->execute([':qid'=>$userQueueId, ':f'=>$utcFrom, ':t'=>$utcTo]);
                $reviews = $stmtFive->fetchAll(PDO::FETCH_ASSOC) ?: [];
        
                /* ===== Detail lists (cancellations & feedback) ===== */
                $stmtCancels = $conn->prepare("
                  SELECT c.id, c.firstName, c.staff_name, c.service_item_name,
                         c.deleted_by_staff AS ts, 'staff' AS who
                  FROM ".CUST_TBL." c
                  WHERE c.queue_id = :qid
                    AND c.deleted_by_staff IS NOT NULL
                    AND DATE(c.deleted_by_staff) = :d
        
                  UNION ALL
        
                  SELECT c.id, c.firstName, c.staff_name, c.service_item_name,
                         c.delete_by_customer AS ts, 'customer' AS who
                  FROM ".CUST_TBL." c
                  WHERE c.queue_id = :qid
                    AND c.delete_by_customer IS NOT NULL
                    AND DATE(c.delete_by_customer) = :d
        
                  ORDER BY ts DESC
                  LIMIT 40
                ");
                $stmtCancels->execute([':qid'=>$userQueueId, ':d'=>$today]);
                $cancels = $stmtCancels->fetchAll(PDO::FETCH_ASSOC) ?: [];
        
                $stmtFb = $conn->prepare("
                  SELECT
                    customer_name,
                    staff_name,
                    COALESCE(store_star_review,0)  AS store_star,
                    COALESCE(staff_star_review,0)  AS staff_star,
                    store_review,
                    staff_review,
                    created_at_utc                 AS ts_utc
                  FROM reviews
                  WHERE queue_id = :qid
                    AND created_at_utc >= :f AND created_at_utc < :t
                  ORDER BY created_at_utc DESC
                  LIMIT 40
                ");
                $stmtFb->execute([':qid'=>$userQueueId, ':f'=>$utcFrom, ':t'=>$utcTo]);
                $feedback = $stmtFb->fetchAll(PDO::FETCH_ASSOC) ?: [];
        
                /* Convert UTC → Australia/Sydney for display */
                $tzSyd = new DateTimeZone('Australia/Sydney');
                foreach ($feedback as &$r) {
                  $u = $r['ts_utc'] ?? null;
                  if ($u) {
                    $dt = new DateTime($u, new DateTimeZone('UTC'));
                    $dt->setTimezone($tzSyd);
                    $r['ts'] = $dt->format('Y-m-d H:i:s');
                  } else {
                    $r['ts'] = null;
                  }
                  unset($r['ts_utc']);
                }
                unset($r);
        
                echo json_encode([
                    'ok'            => true,
                    'date'          => $today,
                    'turnover'      => $turnoverPie,    // ⬅️ pie data (per staff total)
                    'reviews'       => $reviews,
                    'hourly'        => $hourly,
                    'cancellations' => $cancels,
                    'feedback'      => $feedback
                ]); exit;
        
            } catch (Throwable $e) {
                http_response_code(500);
                echo json_encode(['ok' => false]); exit;
            }
        }

        
                
        /* ===== Timesheets: today’s roster + status ===== */
        if ($_GET['action'] === 'ts_rostered_today') {
          // TODAY in server time; if you prefer Sydney, use CONVERT_TZ in SQL or PHP DateTimeZone.
          $tzSyd = new DateTimeZone('Australia/Sydney');
          $today = (new DateTime('today', $tzSyd))->format('Y-m-d');

        
          // Staff rostered today (from roster_shifts) + their current session status
          // Fall back to staff list if roster table is empty.
            $sql = "
              SELECT b.id AS staff_id,
                     b.name AS staff_name,
                     rs.start_time AS roster_start,
                     rs.end_time   AS roster_end
              FROM roster_shifts rs
              JOIN businesses b ON b.id = rs.staff_id
              WHERE rs.business_id = :bid
                AND rs.shift_date  = :d
              ORDER BY b.name
            ";

          $stmt = $conn->prepare($sql);
          $stmt->execute([':bid'=>$userQueueId, ':d'=>$today]);
          $rows = $stmt->fetchAll(PDO::FETCH_ASSOC);
        
          if (!$rows) {
            // fallback: all active staff
            $alt = $conn->prepare("
              SELECT id AS staff_id, name AS staff_name
              FROM businesses
              WHERE user_queue_id = :uqid
                AND subscription_status IN ('subscribed1','subscribed2','subscribed3','staff')
              ORDER BY name
            ");
            $alt->execute([':uqid'=>$userQueueId]);
            $rows = $alt->fetchAll(PDO::FETCH_ASSOC);
          }
        
          // attach status from open session (if any)
            $stat = $conn->prepare("
              SELECT id, start_at, end_at, last_break_at, break_seconds
              FROM timesheet_sessions
              WHERE business_id=:bid AND staff_id=:sid
                AND (end_at IS NULL OR shift_date = :d)   -- prefer any open shift, else today
              ORDER BY (end_at IS NULL) DESC, id DESC
              LIMIT 1
            ");
            
                    
            foreach ($rows as &$r) {
              $stat->execute([':bid'=>$userQueueId, ':sid'=>$r['staff_id'], ':d'=>$today]);
              $ts = $stat->fetch(PDO::FETCH_ASSOC);
            
              if ($ts) {
                $on_shift  = !empty($ts['start_at']) && empty($ts['end_at']);
                $on_break  = $on_shift && !empty($ts['last_break_at']);
                $r['session'] = [
                  'id'            => (int)$ts['id'],
                  'on_shift'      => $on_shift,
                  'on_break'      => $on_break,
                  'start_at'      => $ts['start_at'],
                  'end_at'        => $ts['end_at'],
                  'break_seconds' => (int)$ts['break_seconds'],
                ];
              } else {
                $r['session'] = null;
              }
            
              // ensure roster fields exist (null if no roster)
              $r['roster_start'] = $r['roster_start'] ?? null;
              $r['roster_end']   = $r['roster_end']   ?? null;
            }

          echo json_encode(['ok'=>true, 'date'=>$today, 'staff'=>$rows]); exit;
        }
        
        /* ===== Timesheets: punch (start / break_start / break_end / end) ===== */
        if ($_GET['action'] === 'ts_punch') {
          $p = json_decode(file_get_contents('php://input'), true) ?: [];
          $sid = (int)($p['staff_id'] ?? 0);
          $op  = trim((string)($p['op'] ?? ''));
          $notes = substr(trim((string)($p['notes'] ?? '')), 0, 255);
        
          if ($sid <= 0 || !in_array($op, ['start','break_start','break_end','end'], true)) {
            echo json_encode(['ok'=>false, 'error'=>'bad params']); exit;
          }
        
          // Sydney "today" only used to stamp shift_date on START
          $tzSyd = new DateTimeZone('Australia/Sydney');
          $todaySyd = (new DateTime('today', $tzSyd))->format('Y-m-d');
        
          // Helper: fetch the *currently open* session regardless of shift_date
          $getOpen = $conn->prepare("
            SELECT *
            FROM timesheet_sessions
            WHERE business_id=:bid AND staff_id=:sid AND end_at IS NULL
            ORDER BY start_at DESC, id DESC
            LIMIT 1
          ");
        
          // Helper: fetch latest session for this staff (any)
          $getLastAny = $conn->prepare("
            SELECT *
            FROM timesheet_sessions
            WHERE business_id=:bid AND staff_id=:sid
            ORDER BY id DESC
            LIMIT 1
          ");
        
          try {
            $conn->beginTransaction();
        
            if ($op === 'start') {
              // If there is already an open shift, don't create another
              $getOpen->execute([':bid'=>$userQueueId, ':sid'=>$sid]);
              $open = $getOpen->fetch(PDO::FETCH_ASSOC);
        
              if ($open) {
                $conn->commit();
                echo json_encode(['ok'=>true, 'state'=>'already_started']); exit;
              }
        
              $i = $conn->prepare("
                INSERT INTO timesheet_sessions
                  (business_id, staff_id, shift_date, start_at, notes, created_at, updated_at, break_seconds)
                VALUES
                  (:bid, :sid, :d, NOW(), :n, NOW(), NOW(), 0)
              ");
              $i->execute([':bid'=>$userQueueId, ':sid'=>$sid, ':d'=>$todaySyd, ':n'=>$notes ?: null]);
        
              $conn->commit();
              echo json_encode(['ok'=>true]); exit;
            }
        
            // For the rest of the ops we need an open shift
            $getOpen->execute([':bid'=>$userQueueId, ':sid'=>$sid]);
            $cur = $getOpen->fetch(PDO::FETCH_ASSOC);
        
            if ($op === 'break_start') {
              if (!$cur) { throw new RuntimeException('no active shift'); }
              if (!empty($cur['last_break_at'])) { throw new RuntimeException('already on break'); }
              $u = $conn->prepare("UPDATE timesheet_sessions SET last_break_at = NOW(), updated_at = NOW() WHERE id = :id");
              $u->execute([':id'=>$cur['id']]);
              $conn->commit();
              echo json_encode(['ok'=>true]); exit;
            }
        
            if ($op === 'break_end') {
              if (!$cur) { throw new RuntimeException('no active shift'); }
              if (empty($cur['last_break_at'])) { throw new RuntimeException('not on break'); }
              $acc = $conn->prepare("
                UPDATE timesheet_sessions
                   SET break_seconds = break_seconds + TIMESTAMPDIFF(SECOND, last_break_at, NOW()),
                       last_break_at = NULL,
                       updated_at    = NOW()
                 WHERE id = :id
              ");
              $acc->execute([':id'=>$cur['id']]);
              $conn->commit();
              echo json_encode(['ok'=>true]); exit;
            }
        
            if ($op === 'end') {
              if (!$cur) {
                // If somehow there is no open shift, refuse cleanly
                throw new RuntimeException('no active shift');
              }
        
              // If currently on break, close it first
              if (!empty($cur['last_break_at'])) {
                $acc = $conn->prepare("
                  UPDATE timesheet_sessions
                     SET break_seconds = break_seconds + TIMESTAMPDIFF(SECOND, last_break_at, NOW()),
                         last_break_at = NULL
                   WHERE id = :id
                ");
                $acc->execute([':id'=>$cur['id']]);
              }
        
              $u = $conn->prepare("UPDATE timesheet_sessions SET end_at = NOW(), updated_at = NOW() WHERE id = :id");
              $u->execute([':id'=>$cur['id']]);
              $conn->commit();
              echo json_encode(['ok'=>true]); exit;
            }
        
            // Shouldn't reach here
            $conn->rollBack();
            echo json_encode(['ok'=>false, 'error'=>'unsupported op']); exit;
        
          } catch (Throwable $e) {
            if ($conn->inTransaction()) $conn->rollBack();
            http_response_code(409);
            echo json_encode(['ok'=>false, 'error'=>$e->getMessage()]); exit;
          }
        }

        
        /* ===== Timesheets: list sessions (optional UI section) ===== */
        if ($_GET['action'] === 'ts_list') {
          $tzSyd = new DateTimeZone('Australia/Sydney');
          $d = trim((string)($_GET['date'] ?? '')) ?: (new DateTime('today', $tzSyd))->format('Y-m-d');

          $stmt = $conn->prepare("
            SELECT t.*, b.name AS staff_name
            FROM timesheet_sessions t
            JOIN businesses b ON b.id = t.staff_id
            WHERE t.business_id = :bid AND t.shift_date = :d
            ORDER BY b.name, t.id DESC
          ");
          $stmt->execute([':bid'=>$userQueueId, ':d'=>$d]);
          echo json_encode(['ok'=>true, 'date'=>$d, 'rows'=>$stmt->fetchAll(PDO::FETCH_ASSOC) ?: []]); exit;
        }

        /* ===== Timesheets: attach signature to current/overlapping session ===== */
        if ($_GET['action'] === 'ts_sign') {
          $p = json_decode(file_get_contents('php://input'), true) ?: [];
          $sid  = (int)($p['staff_id'] ?? 0);
          $name = substr(trim((string)($p['signed_name'] ?? '')), 0, 120);
          $b64  = (string)($p['image_base64'] ?? '');
        
          if ($sid <= 0 || $b64 === '') { echo json_encode(['ok'=>false,'error'=>'bad params']); exit; }
        
          // Expect "data:image/png;base64,....."
          if (strpos($b64, 'base64,') !== false) $b64 = substr($b64, strpos($b64, 'base64,') + 7);
          $bin = base64_decode($b64, true);
          if ($bin === false || strlen($bin) < 200) { echo json_encode(['ok'=>false,'error'=>'invalid image']); exit; }
        
          // Sydney window for “today” (for a sensible fallback if nothing is open)
          $tzSyd   = new DateTimeZone('Australia/Sydney');
          $sydFrom = new DateTime('today', $tzSyd);
          $sydTo   = (clone $sydFrom)->modify('+1 day');
          $utcFrom = (clone $sydFrom)->setTimezone(new DateTimeZone('UTC'))->format('Y-m-d H:i:s');
          $utcTo   = (clone $sydTo)->setTimezone(new DateTimeZone('UTC'))->format('Y-m-d H:i:s');
        
          // 1) Prefer the open session
          $qOpen = $conn->prepare("
            SELECT id, end_at
            FROM timesheet_sessions
            WHERE business_id = :bid AND staff_id = :sid AND end_at IS NULL
            ORDER BY start_at DESC, id DESC
            LIMIT 1
          ");
          // 2) Otherwise, the most recent session overlapping today's Sydney window
          $qOverlap = $conn->prepare("
            SELECT id, end_at
            FROM timesheet_sessions
            WHERE business_id = :bid
              AND staff_id    = :sid
              AND start_at    < :utcTo
              AND (end_at IS NULL OR end_at > :utcFrom)
            ORDER BY end_at IS NULL DESC, id DESC
            LIMIT 1
          ");
          // 3) As a last resort, simply the latest session
          $qAny = $conn->prepare("
            SELECT id, end_at
            FROM timesheet_sessions
            WHERE business_id = :bid AND staff_id = :sid
            ORDER BY id DESC
            LIMIT 1
          ");
        
          $qOpen->execute([':bid'=>$userQueueId, ':sid'=>$sid]);
          $row = $qOpen->fetch(PDO::FETCH_ASSOC);
        
          if (!$row) {
            $qOverlap->execute([':bid'=>$userQueueId, ':sid'=>$sid, ':utcFrom'=>$utcFrom, ':utcTo'=>$utcTo]);
            $row = $qOverlap->fetch(PDO::FETCH_ASSOC);
          }
          if (!$row) {
            $qAny->execute([':bid'=>$userQueueId, ':sid'=>$sid]);
            $row = $qAny->fetch(PDO::FETCH_ASSOC);
          }
        
          if (!$row) { echo json_encode(['ok'=>false,'error'=>'no session']); exit; }
        
          // Save PNG
          $todaySyd = $sydFrom->format('Y-m-d');
          $dir = __DIR__ . '/uploads/signatures/' . $userQueueId . '/' . $todaySyd;
          if (!is_dir($dir)) { @mkdir($dir, 0775, true); }
          $fname = 'sig_' . $sid . '_' . time() . '_' . bin2hex(random_bytes(3)) . '.png';
          $path  = $dir . '/' . $fname;
          if (@file_put_contents($path, $bin) === false) {
            echo json_encode(['ok'=>false,'error'=>'write failed']); exit;
          }
        
          // Public URL helper (adjust host if needed)
          $baseUrl = (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS']==='on' ? 'https' : 'http')
                     . '://' . ($_SERVER['HTTP_HOST'] ?? 'lineupz.ai');
          $rel = 'uploads/signatures/' . $userQueueId . '/' . $todaySyd . '/' . $fname;
          $url = $baseUrl . '/' . $rel;
        
          // If the shift is ended, store in signature_path_end; else in signature_path
          $isEnd = !empty($row['end_at']);
          $col   = $isEnd ? 'signature_path_end' : 'signature_path';
        
          try {
            $u = $conn->prepare("
              UPDATE timesheet_sessions
                 SET {$col}      = :p,
                     signature_at = NOW(),
                     signed_name  = :n
               WHERE id = :id
            ");
            $u->execute([':p'=>$rel, ':n'=>($name ?: null), ':id'=>$row['id']]);
          } catch (Throwable $e) {
            // Fallback if signature_path_end column doesn't exist in older schema
            if ($isEnd) {
              $u = $conn->prepare("
                UPDATE timesheet_sessions
                   SET signature_path = :p,
                       signature_at   = NOW(),
                       signed_name    = :n
                 WHERE id = :id
              ");
              $u->execute([':p'=>$rel, ':n'=>($name ?: null), ':id'=>$row['id']]);
            } else {
              throw $e;
            }
          }
        
          echo json_encode(['ok'=>true, 'url'=>$url]); exit;
        }



        http_response_code(404);
        echo json_encode(['ok'=>false,'error'=>'unknown action']); exit;

    } catch (Throwable $e) {
        if ($conn->inTransaction()) { $conn->rollBack(); }
        http_response_code(500);
        echo json_encode(['ok'=>false,'error'=>'server error']); exit;
    }
}
?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Queue POS — Checked-in • Served • Cart</title>
  <!-- PWA manifest + theme color -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#111827">  

  <!-- CSS / JS libs -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
  <link rel="icon" type="image/png" href="images/favicon.png">
  <script src="https://code.jquery.com/jquery-3.6.0.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.3/dist/umd/popper.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

  <style>
    :root {
      --col-bg: #ffffff;
      --col-border: #e6e9ef;
      --col-shadow: 0 8px 20px rgba(20, 20, 20, .06);
      --muted: #6b7280;
      --footer-h: 56px;
      --footer-gap: 20px;
    }

    html, body { height: 100%; }
    body { background:#fcfcfc; display:flex; flex-direction:column; min-height:100vh; }
    
    /* Online/offline status pill (footer) */
    #onlineStatusBadge {
      display: inline-flex;
      align-items: center;
      padding: 3px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
      font-weight: 600;
    }
    #onlineStatusBadge.online {
      background: #16a34a;
      color: #ffffff;
    }
    #onlineStatusBadge.offline {
      background: #f97316;
      color: #ffffff;
    }
    


    .navbar-brand img { height:30px; }

    .page-wrap {
      flex: 1 1 auto;
      min-height: 0;
      padding: 12px 16px calc(var(--footer-h) + var(--footer-gap));
    }

    .three-col-wrap {
      display:grid; grid-template-columns: 1fr 1fr 0.95fr; grid-gap:16px;
      min-height:500px;
      margin-bottom: 12px;
    }
    @media (min-width:1200px) {
      .three-col-wrap {
        height: calc(100vh - 70px - var(--footer-h) - var(--footer-gap));
      }
    }
    @media (max-width:1199.98px) { .three-col-wrap { grid-template-columns:1fr; height:auto; } }

    .panel {
      background: var(--col-bg);
      border: 1px solid var(--col-border);
      border-radius: 14px;
      box-shadow: var(--col-shadow);
      display:flex; flex-direction:column; min-height:0;
    }
    .panel-header { position: sticky; top: 0; z-index: 2; background:#fff; border-bottom:1px solid var(--col-border); padding:12px 14px; display:flex; align-items:center; justify-content:space-between; }
    .panel-header h4 { margin:0; font-weight:700; }
    .panel-body { flex:1 1 auto; overflow:auto; padding:10px; background: linear-gradient(180deg, #fff 0, #fff 60%, #fafbfe 100%); }
    .panel-footer { border-top:1px solid var(--col-border); padding:12px 14px; background:#fff; }

    .queue-item { border:1px solid var(--col-border); border-radius:10px; padding:12px; margin-bottom:10px; background:#fff; }
    #offlineQueueWrap .queue-item {
      border-style: dashed;
      opacity: 0.9;
    }
    
    .service-set { background:#e6f7ff; }
    .appointment-info { font-size:.9rem; color:#555; margin-top:6px; }

    .callback-btn { background-color:orange; color:#fff; }
    .callback-btn:hover{ background-color:darkorange; }
    .callback-btn.pressed { background-color:#ffcc00; border-color:#ffcc00; }
    .btn-slim { padding:.25rem .5rem; font-size:.85rem; }
    .btn-tall { padding:.75rem 1rem; font-size:1rem; }
    .muted { color:var(--muted); }
    .badge-info { background:#69a7ff; }
    .badge-success { background:#2fb979; }

    /* Ultra-light disabled state for Add to Cart */
    .btn-add-cart.disabled,
    .btn-add-cart:disabled {
      background-color:#f5f5f5 !important;
      border-color:#f5f5f5 !important;
      color:#cccccc !important;
      opacity:0.7;
      cursor:not-allowed;
    }

    .cart-item { display:flex; justify-content:space-between; align-items:center; padding:8px 10px; border:1px solid var(--col-border); border-radius:10px; margin-bottom:8px; background:#fff; }
    .cart-title { font-weight:600; }
    .cart-empty { color: var(--muted); }
    .price { white-space:nowrap; }
    .customer-chip { display:inline-flex; align-items:center; padding:2px 8px; font-size:.8rem; border:1px solid #e4e7ee; border-radius:999px; background:#fafbfe; margin-right:6px; }
    .cart-total { font-size:1.1rem; font-weight:700; }

    .footer-bar { position:fixed; left:0; right:0; bottom:0; height:var(--footer-h); background:#fff; border-top:1px solid var(--col-border); z-index:10; }
    .footer-inner {
      max-width: 960px;
      margin: 0 auto;
      height: 100%;
      display: flex;               /* already present, but safe to repeat */
      align-items: center;         /* already present */
      justify-content: center;     /* already present */
      gap: 10px;                   /* space between logo and text */
      padding: 0 12px;             /* already present */
      text-align: center;          /* already present */
    }
    
    .footer-logo {
      height: 32px;          /* was ~24px */
      width: auto;
      object-fit: contain;
      display: inline-block;
      transform: translateY(2px); /* push logo slightly down */
    }
    @media (max-width: 480px){
      .footer-logo { height: 28px; transform: translateY(1px); }
    }


    footer { color:#98a1b2; }

    /* Staff & Profile modals styling */
    .staff-card {
      cursor: pointer; border-radius: 10px; margin-bottom: 14px; padding: 18px;
      font-size: 1.05rem; font-weight: 600; text-align: center; transition: transform 0.08s ease, box-shadow .08s ease;
      box-shadow: 0 2px 8px rgba(0,0,0,.05); border: 1px solid var(--col-border);
    }
    .staff-card:hover { transform: scale(1.015); box-shadow: 0 4px 14px rgba(0,0,0,.08); }
    .text-white { color: #fff !important; }
    .text-black { color: #000 !important; }

    .profile-grid { display:grid; grid-template-columns: 1.1fr .9fr; grid-gap:16px; }
    @media (max-width: 991.98px) { .profile-grid { grid-template-columns: 1fr; } }

    .kpi { background:#fff; border:1px solid var(--col-border); border-radius:12px; padding:12px; }
    .kpi h6 { margin:0 0 6px; font-weight:700; }
    .kpi .small { color:#6b7280; }

    .profile-card { background:#fff; border:1px solid var(--col-border); border-radius:12px; padding:12px; }
    .profile-card h6 { font-weight:700; }

    .btn-pastel-success { background-color:#C8F4D9; color:#06623B; border:none; }
    .btn-pastel-success:hover { background-color:#B3EACB; color:#054E2E; }
    .btn-pastel-danger { background-color:#FFCED3; color:#8A1C24; border:none; }
    .btn-pastel-danger:hover { background-color:#FFB9C0; color:#6C141A; }
    /* --- Actions layout for served row --- */
    /* --- Actions layout for served row (second row of each card) --- */
    .qi-subrow{
      display:flex;
      align-items:center;
      justify-content:center;   /* center the buttons */
      gap:8px;
      margin-top:6px;
      margin-bottom:8px;        /* breathing room under the buttons */
      flex-wrap:wrap;
    }
    
    /* First row (name + badge) stays neat */
    .qi-headline{ display:flex; align-items:center; justify-content:space-between; }
    .qi-name{ font-weight:600; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    
    /* Compact buttons (narrow if text allows) */
    .btn-compact{
      padding:.28rem .55rem;
      font-size:.86rem;
      line-height:1.15;
    }
    
    /* Orange primary + consistent width for Finish/Finished (no size jump) */
    .btn-orange{ background-color:#ff9800; border-color:#ff9800; color:#fff; }
    .btn-orange:hover{ background-color:#e68900; border-color:#e68900; color:#fff; }
    
    /* exact same width for both texts */
    .btn-finish{ width:140px; }    /* <- same width whether "Finish Service" or "Finished" */
    
    /* “Misted” look when finished/locked */
    .btn-finish.disabled,
    .btn-finish:disabled{
      background-color:#ff9800 !important;
      border-color:#ff9800 !important;
      color:#fff !important;
      opacity:.5;
      filter:saturate(65%);
      box-shadow:none;
      cursor:default;
    }
    
    /* ==== POS Checkout (touch-first) ==== */
    .pos-checkout .modal-dialog{max-width:560px}
    .pos-checkout .modal-body{padding-top:10px}
    .pos-checkout .customer-name{font-size:1.05rem;font-weight:700}
    .pos-checkout .total-due{font-size:1.7rem;font-weight:800}
    .pos-checkout .method-tiles{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin:10px 0}
    .pos-checkout .method-tile{
      border:2px solid #e7eaef;border-radius:14px;padding:14px;text-align:center;
      font-size:1.15rem;font-weight:700;cursor:pointer;user-select:none;
    }
    .pos-checkout .method-tile.active{border-color:#007bff;box-shadow:0 0 0 3px rgba(0,123,255,.15)}
    .pos-checkout .quick-cash{display:flex;flex-wrap:wrap;gap:8px;margin:8px 0 10px}
    .pos-checkout .qbtn{padding:8px 12px;font-size:1.05rem;border-radius:10px}
    .pos-checkout .keypad{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .pos-checkout .keypad .key{
      padding:16px;border:1px solid #e7eaef;border-radius:12px;background:#fff;
      font-size:1.35rem;font-weight:700;text-align:center;user-select:none;cursor:pointer;
    }
    .pos-checkout .tender-row{display:flex;align-items:center;gap:10px}
    .pos-checkout .tender-row input{font-size:1.35rem;height:48px;text-align:right}
    .pos-checkout .change-line{display:flex;justify-content:space-between;align-items:center;margin-top:6px}
    .pos-checkout .change-line .change-amt{font-size:1.4rem;font-weight:800}
    .pos-checkout .alert{border-radius:12px}
    .pos-checkout .alert.alert-warning{
      font-size:1.25rem;
      font-weight:800;
      padding:16px 14px;
      letter-spacing:.2px;
    }
    
    /* Big success stamp */
    .approved-stamp{
      font-size:48px;
      font-weight:900;
      letter-spacing:2px;
      text-transform:uppercase;
      margin-bottom:6px;
    }
    @media (max-width:640px){
      .approved-stamp{ font-size:34px; }
    }


    
    .pos-checkout .email-header{display:flex;justify-content:space-between;align-items:center}
    .pos-checkout .email-keypad{display:none;margin-top:8px}
    .pos-checkout .email-grid{display:grid;grid-template-columns:repeat(10,1fr);gap:6px}
    .pos-checkout .email-grid .ekey{
      padding:10px;border:1px solid #e7eaef;border-radius:10px;background:#fff;
      text-align:center;font-weight:700;cursor:pointer;user-select:none;
    }
    .pos-checkout .email-domains{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
    .pos-checkout .email-domains .badge{font-size:0.95rem;padding:8px 10px;border-radius:999px;cursor:pointer}
    /* ==== POS Checkout: fit modal to viewport (no page scroll) ==== */
    /* ==== POS Checkout: fit whole popup into the viewport (no page/body scroll) ==== */
    .pos-checkout .modal-dialog{
      max-width: 560px;
      width: calc(100% - 16px);           /* small side gutters */
      height: calc(100vh - 16px);         /* small top/bottom gutter */
      margin: 8px auto;                   /* center with small margins */
      display: flex;
      align-items: center;                 /* vertical centering */
      justify-content: center;
    }
    
    .pos-checkout .modal-content{
      border-radius: 14px;
      /* we will scale this element via JS */
      will-change: transform;
    }
    
    .pos-checkout .modal-body{
      overflow: visible !important;        /* ensure no inner scroll */
    }
    
    /* POS modal: own the centering, remove Bootstrap's extra spacers */
    .pos-checkout .modal-dialog {
      max-width: 560px;
      width: calc(100% - 16px);
      height: calc(100vh - 16px);
      margin: 8px auto !important;   /* small top/bottom gutter */
      display: flex;
      align-items: center;            /* vertical center of modal-content */
      justify-content: center;        /* horizontal center */
    }
    
    /* If "modal-dialog-centered" ever slips back in, neuter its spacer */
    .pos-checkout .modal-dialog-centered::before { display: none !important; }
    .pos-checkout .modal-dialog-centered { min-height: 0 !important; }
    
    /* Make sure body area doesn't reintroduce a scroll */
    .pos-checkout .modal-body { overflow: visible !important; }

    
    /* Tighter layout for short screens so less scaling is needed */
    @media (max-height: 760px){
      .pos-checkout .total-due{ font-size:1.5rem; }
      .pos-checkout .method-tile{ padding:10px; font-size:1.05rem; }
      .pos-checkout .keypad .key{ padding:12px; font-size:1.2rem; }
      .pos-checkout .qbtn{ padding:6px 10px; font-size:1rem; }
      .pos-checkout .tender-row input{ height:42px; font-size:1.2rem; }
      .pos-checkout .modal-header,
      .pos-checkout .modal-footer{ padding:8px 12px; }
    }
    @media (max-height: 640px){
      .pos-checkout .method-tiles{ gap:8px; }
      .pos-checkout .keypad{ gap:8px; }
      .pos-checkout hr{ margin:8px 0; }
    }
    /* Hide pre-configured tender chips and the change line before recording */
    #coQuickCash,
    .change-line { display: none !important; }
    
    /* Big change amount inside the green success block (after recording) */
    .pos-checkout .co-change-big{
      font-size: 2.2rem;
      font-weight: 800;
      line-height: 1.1;
    }
    
    /* Pre-record spacing & tidy */
    .pos-checkout .modal-header{ padding:10px 12px; }
    .pos-checkout .modal-footer{ padding:10px 12px; }
    .pos-checkout .method-tiles{ margin:12px 0 10px; }
    .pos-checkout .tender-row{ margin-bottom:8px; }
    .pos-checkout .quick-cash{ margin:4px 0 10px; }
    .pos-checkout .email-header{ margin-top:8px; }
    
    /* Hide the built-in change row until payment is recorded */
    .change-line{ display:none !important; }
    
    /* Success (green box) – BIG change + compact email kb */
    .pos-checkout .co-change-big{
      font-size:2.2rem; font-weight:800; line-height:1.1;
    }
    .pos-checkout .co-email-kb{
      display:grid; grid-template-columns:repeat(10,1fr); gap:6px; margin-top:8px;
    }
    .pos-checkout .co-ekey{
      padding:10px; border:1px solid #e7eaef; border-radius:10px; background:#fff;
      text-align:center; font-weight:700; cursor:pointer; user-select:none;
    }
    .pos-checkout .co-domains{
      display:flex; flex-wrap:wrap; gap:8px; margin-top:8px;
    }
    .pos-checkout .co-domains .badge{
      font-size:.95rem; padding:8px 10px; border-radius:999px; cursor:pointer;
    }
    
    /* Make alerts positionable (for our mini toast) */
    .pos-checkout .alert { position: relative; }
    /* Visual press feedback for number keys */
    .pos-checkout .keypad .key{
      position: relative;                  /* enables the overlay effect */
      transition: transform .06s ease, box-shadow .12s ease, background .08s ease;
    }
    .pos-checkout .keypad .key:active,
    .pos-checkout .keypad .key.pressed{
      transform: translateY(1px) scale(.985);
      background: #f7f9ff;
      box-shadow: inset 0 0 0 2px #e7eaef, inset 0 8px 16px rgba(0,0,0,.06);
    }
    /* subtle highlight “flash” */
    .pos-checkout .keypad .key::after{
      content:"";
      position:absolute; inset:0;
      border-radius:12px;
      background: radial-gradient(closest-side, rgba(0,0,0,.06), transparent 70%);
      opacity:0; transition: opacity .12s ease;
    }
    .pos-checkout .keypad .key.pressed::after{ opacity:.35; }

    /* Tiny “email sent” toast inside the green box */
    #coSuccess .mini-toast{
      position: absolute;
      right: 12px;
      top: 12px;
      z-index: 2;
      padding: 6px 10px;
      border-radius: 8px;
      font-weight: 600;
      font-size: .9rem;
      background: #28a745; /* success */
      color: #fff;
      display: none;
      box-shadow: 0 4px 14px rgba(0,0,0,.12);
    }
    #coSuccess .mini-toast.error{ background: #dc3545; } /* error red */
    
    /* Grow the first three buttons to fill the row; keep Add to Cart auto-sized */
    .qi-subrow .btn-grow { 
      flex: 1 1 0;
      min-width: 0;
    }
    
    /* On mobile, keep buttons side-by-side (two per row) for CHECKED-IN cards */
    @media (max-width: 576px){
      section[aria-label="Checked-in clients"] .qi-subrow {
        flex-wrap: wrap;                       /* still wrap if it gets tight */
      }
      section[aria-label="Checked-in clients"] .qi-subrow .btn-grow {
        flex: 1 1 calc(50% - 4px);             /* ~2 buttons per row */
      }
    }

    /* Callback pop badge */
    .callback-btn { position: relative; overflow: visible; }
    
    .callback-badge{
      position: absolute;
      top: -8px;
      right: -8px;
      z-index: 3;
      background: #ff9800;      /* orange */
      color: #fff;
      font-weight: 700;
      font-size: 10px;
      line-height: 1;
      padding: 4px 6px;
      border-radius: 999px;
      box-shadow: 0 2px 8px rgba(0,0,0,.15);
      opacity: 0;
      transform: scale(.9) translateY(-4px);
      pointer-events: none;
      transition: opacity .18s ease, transform .18s ease;
    }
    .callback-badge.show{ opacity:1; transform: scale(1) translateY(0); }
    /* persistent count bubble on the callback button */
    .callback-count{
      position: absolute;
      bottom: -8px;
      right: -8px;
      background: #111;    /* dark chip */
      color: #fff;
      font-weight: 800;
      font-size: 10px;
      line-height: 1;
      padding: 4px 6px;
      border-radius: 999px;
      box-shadow: 0 2px 8px rgba(0,0,0,.15);
    }

    
    /* optional: red badge on error */
    .callback-badge.error{ background:#e74c3c; }
    
    /* Global snack (auto-dismiss popup) */
    #snackRoot{
      position: fixed;
      top: 70px;               /* sits under your navbar */
      left: 0; right: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      z-index: 2000;           /* above panels/modals background */
      pointer-events: none;    /* clicks pass through */
    }
    .snack{
      background:#28a745;      /* success green */
      color:#fff;
      padding:10px 14px;
      border-radius:10px;
      box-shadow:0 8px 20px rgba(0,0,0,.18);
      font-weight:700;
      font-size:.95rem;
      opacity:0;
      transform: translateY(-6px);
      transition: opacity .18s ease, transform .18s ease;
    }
    .snack.error{ background:#dc3545; } /* error red */
    .snack.show{ opacity:1; transform: translateY(0); }
    
    /* Insights drawer */
    .insight-toggle{
      position: fixed;
      right: 16px;
      bottom: calc(var(--footer-h) + 18px);
      z-index: 1400;
      background:#2563eb; color:#fff; border:none;
      padding:10px 14px; border-radius:999px; box-shadow:0 8px 20px rgba(0,0,0,.18);
      font-weight:700;
    }
    .insight-toggle:focus{ outline:none; box-shadow:0 0 0 3px rgba(37,99,235,.25); }
 
    .insight-tab:focus{ outline: none; box-shadow: 0 0 0 3px rgba(37,99,235,.25); }
    
    /* --- Drawer --- */
    .insight-drawer{
      position: fixed; top: 66px; right: 0;
      bottom: calc(var(--footer-h) + 8px);
      width: 420px; max-width: calc(100vw - 32px);
      background:#fff; border-left:1px solid var(--col-border);
      box-shadow: -14px 0 28px rgba(0,0,0,.12);
      border-top-left-radius: 14px; border-bottom-left-radius: 14px;
      transform: translateX(105%); transition: transform .22s ease;
      z-index: 1350; display:flex; flex-direction:column;
    }
    .insight-drawer.open{ transform: translateX(0); }
    
    .id-header{
      padding:12px 14px; border-bottom:1px solid var(--col-border);
      display:flex; align-items:center; justify-content:space-between;
    }
    .id-close{ background:transparent; border:none; font-size:1.6rem; line-height:1; color:#666; }
    .id-body{ padding:12px 14px; overflow:auto; }
    .id-section + .id-section{ margin-top:14px; }
    .id-title{ font-weight:700; margin-bottom:8px; }
    
    /* Square canvases so pies render as circles */
    #pieCuts, #pieReviews{
      width: 100%;
      height: auto !important;
      aspect-ratio: 1 / 1;
      display: block;
    }
    #barHourly{ width:100%; height:280px !important; display:block; }
        @media (max-height:760px){ #barHourly{ height:240px !important; } }
        
    /* Two-up layout for pies */
    .id-two-up { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width: 640px){ .id-two-up { grid-template-columns: 1fr; } }
    
    .mini-list .item{
      display:flex; align-items:center; justify-content:space-between;
      padding:8px 10px; margin-bottom:6px;
      border:1px solid var(--col-border); border-radius:10px; background:#fff;
      font-size: 0.95rem;
    }
    .mini-list .meta{ color:#6b7280; font-size:.85rem; }
    .mini-list .item[role="button"] { cursor: pointer; }
    /* helps stack meta lines nicely */
    .mini-list .item .meta + .meta { margin-top: 2px; }

    .badge-pill{
      border-radius:999px; padding:3px 8px; font-weight:700; font-size:.75rem;
    }
    .badge-staff{ background:#fee2e2; color:#991b1b; }
    .badge-cust { background:#fff7ed; color:#9a3412; }
    .badge-star { background:#fef3c7; color:#92400e; }
    
    /* modal above drawers */
    .insight-drawer { z-index: 1000; }
    .modal { z-index: 2000; }
    .modal-backdrop { z-index: 1900; }
    
    /* prevent touch scrolling on the canvas */
    #tsSignCanvas { touch-action: none; display:block; width:100%; }
    
    /* Right-edge rail that holds both tabs */
    /* Right-edge rail that holds both tabs (you already have this) */
    .side-tabs{
      position: fixed;
      top: 50%;
      right: 0;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 1400;
    }
    
    /* Vertical tab with icon inline in the same vertical line */
    .side-tab{
      background: #2563eb;
      color: #fff;
      border: none;
      padding: 12px 10px;
      border-top-left-radius: 10px;
      border-bottom-left-radius: 10px;

      cursor: pointer;
      font-weight: 700;
    
      /* keep the label vertical */
      writing-mode: vertical-rl;
      text-orientation: mixed;
    
      /* ensure the content is a single inline flow, not stacked flex children */
      display: inline-block;
      line-height: 1.1;
    }
    /* Disabled state for side tabs (offline) */
    .side-tab.disabled{
      cursor: not-allowed;
    }

    
    .side-tab:focus{ outline: none; box-shadow: 0 0 0 3px rgba(37,99,235,.25); }
    
    /* the label keeps icon + text in one inline run */
    .side-tab .side-tab-label{
      display: inline;          /* stays in the same inline run (vertical) */
      white-space: nowrap;      /* optional: keep text together */
    }
    
    /* rotate the icon so it aligns visually with vertical text */
    .side-tab i{
      display: inline-block;
      transform: rotate(90deg);
      transform-origin: center;
      margin: 0 0 6px 0;        /* spacing between icon and text (vertical flow) */
      line-height: 1;
      font-size: 16px;
    }
    /* Make sure touches go to the modal and the canvas on iOS */
    #tsSignModal .modal-content { touch-action: manipulation; pointer-events: auto; }
    #tsSignCanvas {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
            
    /* ——— Service Picker (Refined, Professional) ——— */
    
    /* Scope a clean, professional font stack to the modal only */
    #servicePickerModal{
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI",
                   Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    /* Modal: roomy yet disciplined */
    #servicePickerModal .modal-dialog{
      width: min(96vw, 1200px);
      max-width: 1200px;
      margin: 12px auto;
    }
    #servicePickerModal .modal-content{
      border: 1px solid rgba(16,24,40,.08);
      border-radius: 14px;
      box-shadow:
        0 10px 24px rgba(16,24,40,.08),
        0 2px 6px rgba(16,24,40,.04);
    }
    
    /* Grid: 6-across desktop, compact rhythm */
    .svc-grid{
      display: grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap: 10px;
      padding: 0;
    }
    
    /* Placeholders keep layout only */
    .svc-cell.empty{
      visibility: hidden;
      height: 0;
      padding: 0;
      margin: 0;
      border: 0;
      box-shadow: none;
    }
    
    /* Tile: rectangular, less tall, premium surface */
    .svc-cell{
      position: relative;
      height: clamp(80px, 13.5vw, 112px);         /* ↓ shorter than before */
      border-radius: 12px;
      border: 1px solid rgba(16,24,40,.08);
      background:
        linear-gradient(180deg, rgba(255,255,255,.98) 0%, rgba(255,255,255,.94) 100%),
        var(--tile-bg, #fff);
      box-shadow:
        0 2px 6px rgba(16,24,40,.05),
        0 10px 24px rgba(16,24,40,.06);
      padding: 8px;                                /* ↓ tighter padding */
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      cursor: pointer;
      transform: translateZ(0);
      transition:
        transform .08s ease,
        box-shadow .18s ease,
        border-color .18s ease,
        background-color .18s ease;
    }
    .svc-cell:hover{
      transform: translateY(-1px);
      box-shadow:
        0 4px 12px rgba(16,24,40,.09),
        0 16px 32px rgba(16,24,40,.08);
      border-color: rgba(37,99,235,.22);
    }
    .svc-cell:active{
      transform: translateY(0);
      box-shadow:
        inset 0 0 0 1px rgba(16,24,40,.08),
        0 6px 18px rgba(16,24,40,.08);
    }
    .svc-cell:focus-visible{
      outline: none;
      box-shadow:
        0 0 0 3px rgba(37,99,235,.25),
        0 6px 18px rgba(16,24,40,.08);
      border-color: rgba(37,99,235,.5);
    }
    
    /* Contrast modes toggled via JS */
    .svc-cell.svc-dark{ color:#0f172a; }  /* slate-900 */
    .svc-cell.svc-light{ color:#fff; }
    .svc-cell.svc-light .badge{ color:#0f172a; background: rgba(255,255,255,.9); }
    
    /* Header: denser vertical rhythm */
    .svc-top{
      display:flex;
      align-items:flex-start;
      gap: 6px;
    }
    .svc-name{
      font-weight: 700;                         /* ↓ less shouty than 800 */
      font-size: .94rem;                        /* ↓ slightly smaller */
      line-height: 1.2;
      letter-spacing: .01em;
      display: -webkit-box;                     /* allow up to 2 lines */
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
      overflow: hidden;
    }
    
    /* Badges: quiet, modern “chips” (no heavy colors/shadows) */
    .svc-badges{
      margin-top: 4px;                          /* ↓ tighter */
      display:flex;
      flex-wrap:wrap;
      gap: 6px;
    }
    .svc-badges .badge{
      border-radius: 999px;
      padding: 2px 8px;                         /* ↓ slimmer */
      font-size: .66rem;                        /* ↓ smaller */
      font-weight: 600;                         /* ↓ lighter */
      line-height: 1.1;
      border: 1px solid rgba(15,23,42,.12);     /* subtle outline */
      background: rgba(15,23,42,.04);           /* soft neutral */
      color: #334155;                           /* slate-600 */
      box-shadow: none;                          /* no drop shadow */
    }
    .svc-cell.svc-light .svc-badges .badge{
      border-color: rgba(255,255,255,.45);
      background: rgba(255,255,255,.85);
      color: #0f172a;
    }
    
    /* Price: confident, compact */
    .svc-price{
      font-size: .98rem;                        /* ↓ a notch */
      font-weight: 800;
      opacity: .96;
    }
    
    /* Count chip + bin: crisp and small */
    .svc-ui{
      position: absolute;
      top: 6px;
      right: 6px;
      display: none;
      align-items: center;
      gap: 6px;
      z-index: 2;
    }
    .svc-count{
      background: rgba(17,17,17,.92);
      color: #fff;
      border-radius: 999px;
      padding: 2px 7px;                         /* ↓ tighter */
      font-weight: 800;
      font-size: .68rem;                        /* ↓ smaller */
      line-height: 1;
    }
    .svc-cell.svc-light .svc-count{ background: rgba(255,255,255,.9); color:#0f172a; }
    
    .svc-clear{
      border: 1px solid rgba(15,23,42,.12);
      background: rgba(255,255,255,.92);
      border-radius: 9px;
      padding: 3px 6px;                         /* ↓ tighter */
      line-height: 1;
      box-shadow: none;
      transition: transform .06s ease, background-color .12s ease, border-color .12s ease;
    }
    .svc-clear:hover{
      transform: translateY(-1px);
      background: #fff;
      border-color: rgba(15,23,42,.2);
    }
    .svc-clear i{ color:#0f172a; }
    
    /* Readability veil on vivid base colors */
    .svc-cell::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.06) 100%);
      pointer-events:none;
    }
    
    /* Served column spacing (unchanged) */
    .qi-subrow + .qi-headline{ margin-top: 6px; }
    
    /* Responsive: 3-across on small screens */
    @media (max-width: 900px){
      .svc-grid{
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 8px;
      }
    }
    
    /* Reduced motion support */
    @media (prefers-reduced-motion: reduce){
      .svc-cell{ transition: none; }
      .svc-cell:hover,
      .svc-cell:active{
        transform: none;
        box-shadow:
          0 2px 6px rgba(16,24,40,.05),
          0 10px 24px rgba(16,24,40,.06);
      }
    }
    
    /* Optional dark mode */
    @media (prefers-color-scheme: dark){
      #servicePickerModal .modal-content{
        background: #0b1220;
        border-color: rgba(255,255,255,.06);
        box-shadow:
          0 10px 24px rgba(0,0,0,.6),
          0 2px 6px rgba(0,0,0,.4);
      }
      .svc-cell{
        border-color: rgba(255,255,255,.06);
        background:
          linear-gradient(180deg, rgba(17,24,39,.86) 0%, rgba(17,24,39,.82) 100%),
          var(--tile-bg, #111827);
        box-shadow:
          0 2px 6px rgba(0,0,0,.55),
          0 10px 24px rgba(0,0,0,.5);
      }
      .svc-badges .badge{
        border-color: rgba(255,255,255,.18);
        background: rgba(255,255,255,.08);
        color: #e5e7eb;
      }
    }
    
    /* Timesheets tab: red badge + pulse */
    .side-tab { position: relative; } /* allow badge to anchor */
    
    #tsBadge{
      position: absolute;
      top: 6px;
      left: -8px;                /* sits on the outside edge */
      background: #ef4444;       /* red */
      color: #fff;
      border-radius: 999px;
      padding: 3px 6px;
      font-size: 11px;
      font-weight: 800;
      box-shadow: 0 2px 8px rgba(0,0,0,.15);
      display: none;             /* JS shows it */
    }
    #tsBadge.show{ display: inline-block; }
    
    /* subtle, unobtrusive pulse */
    .side-tab.pulse{
      animation: tabPulse 1.2s ease-in-out infinite;
    }
    @keyframes tabPulse{
      0%   { box-shadow: 0 0 0 0 rgba(37,99,235,.35); }
      70%  { box-shadow: 0 0 0 10px rgba(37,99,235,0); }
      100% { box-shadow: 0 0 0 0 rgba(37,99,235,0); }
    }
    .svc-cell.scan-flash{
      outline: 3px solid rgba(37,99,235,.6);
      box-shadow: 0 0 0 3px rgba(37,99,235,.18);
    }
    
    /* Card DECLINED banner */
    .pos-checkout .modal-body { position: relative; } /* anchor overlay */
    .card-declined-banner{
      position: absolute; left: 12px; right: 12px; top: 12px;
      background: #dc3545; color: #fff;
      border-radius: 12px; box-shadow: 0 8px 22px rgba(0,0,0,.25);
      font-size: 52px; font-weight: 900; letter-spacing: 2px; text-align: center;
      padding: 18px 12px; z-index: 3; text-transform: uppercase;
    }
    @media (max-width: 640px){
      .card-declined-banner{ font-size: 34px; padding: 14px 10px; }
    }
    /* grey-out staff on break + badge */
    .staff-card.on-break{ filter: grayscale(1); opacity:.6; position:relative; }
    .staff-card .break-badge{
      position:absolute; top:8px; right:8px;
      background: rgba(0,0,0,.65); color:#fff;
      font-weight:700; font-size:.75rem;
      padding:4px 8px; border-radius:999px;
    }
    /* ---- Family grouping visuals ---- */
    .queue-item.has-family { position: relative; }
    .queue-item.has-family { box-shadow: inset 6px 0 0 0 var(--fam-color, #FDE68A); }
    .queue-item .fam-chip{
      align-self: flex-start;
      margin-bottom: 6px;
      padding: 2px 10px;
      font-size: 0.8rem;
      font-weight: 700;
      background: var(--fam-color, #FDE68A);
      color: #111;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .fam-chip .x {
      font-weight: 900;
      cursor: pointer;
      opacity: .6;
    }
    .fam-chip .x:hover { opacity: 1; }
    
    .fam-chip .edit { background:transparent; border:none; padding:0; line-height:1; cursor:pointer; }
    .fam-chip .edit i { font-size:0.9rem; opacity:.8; }
    .fam-chip .edit:hover i { opacity:1; }
    
    /* Ensure Family Edit modal stacks above Profile if CSS is used without JS tweak */
    #familyEditModal { z-index: 2100; }
    
    /* Single-line header for Checked-in cards */
    .ci-line{
      display:grid;
      grid-template-columns: 1fr auto auto;  /* name | phone | right-side (wait+badge) */
      align-items:center;
      column-gap:10px;
    }
    .ci-name{
      font-weight:700;              /* only the name is bold */
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .ci-phone{
      justify-self:center;          /* sits in the middle column */
      white-space:nowrap;
    }
    .ci-right{
      justify-self:end;
      display:flex;
      align-items:center;
      gap:8px;                      /* wait just inside the badge(s) */
    }
    
    /* AI support drawer: make iframe fill the drawer */
    #aiSupportDrawer .id-body {
      padding: 0;
      overflow: hidden;
      flex: 1 1 auto;
      display: flex;
    }
    
    #aiSupportFrame {
      width: 100%;
      height: 100%;
      border: 0;
      display: block;
    }
    
    /* When AI Support drawer is open, hide the side tabs so they don't cover the chat */
    body.ai-support-open .side-tabs {
      opacity: 0;
      pointer-events: none;
    }
    
    /* On mobile, keep buttons side-by-side (two per row) for SERVED cards */
    @media (max-width: 576px){
      section[aria-label="Served clients"] .qi-subrow {
        flex-wrap: wrap;
      }
      section[aria-label="Served clients"] .qi-subrow .btn-grow {
        flex: 1 1 calc(50% - 4px);
      }
    }

        


    
                   
        

  </style>
</head>
<body>
<?php
// after session/auth and (ideally) after you've included db_connect.php
include __DIR__ . '/navbar.php';
?>

<div class="page-wrap">

<input type="hidden" id="userQueueId" value="<?php echo htmlspecialchars($userQueueId, ENT_QUOTES); ?>">

<script>
  // 'square' or 'linkly' (falls back to '' if not set)
  window.PREFERRED_EFTPOS = <?php echo json_encode(
    $eftposProvider ? strtolower($eftposProvider) : ''
  ); ?>;
</script>

<script>
  // true if this business is using an online EFTPOS (Linkly or Square)
  window.EFTPOS_NEEDS_ONLINE = ['linkly','square'].includes(
    (window.PREFERRED_EFTPOS || '').toLowerCase()
  );

  console.log('PREFERRED_EFTPOS from PHP =', window.PREFERRED_EFTPOS,
              'EFTPOS_NEEDS_ONLINE =', window.EFTPOS_NEEDS_ONLINE);
</script>

    


  <div class="three-col-wrap">

            <!-- LEFT: Checked-in -->
    <!-- LEFT: Checked-in -->
    <section class="panel" aria-label="Checked-in clients">
      <div class="panel-header">
        <h4>Checked-in Clients</h4>
        <div class="hdr-pill">
          <i class="far fa-clock"></i>
          <span id="waitEta">Live</span>
        </div>
      </div>
    
      <div class="panel-body">
        <div id="queueList"></div>
        <div id="offlineQueueWrap" class="mt-2"></div>

      </div>
    
      <div class="panel-footer">
        <button id="addQueueButton" class="btn btn-primary btn-block btn-tall">
          <i class="fas fa-user-plus mr-1"></i> Manually Check-in Client
        </button>
      </div>
    </section>


    <!-- MIDDLE: Served -->
    <section class="panel" aria-label="Served clients">
        <div class="panel-header">
          <h4>Served Clients</h4>
          <div class="hdr-pill"><i class="fas fa-check-circle"></i> Recent</div>
        </div>

      <div class="panel-body"><div id="servedList"></div></div>
        <div class="panel-footer">
          <button id="familyGroupBtn" class="btn btn-primary btn-block btn-tall">
            <i class="fas fa-users mr-1"></i> Group Family
          </button>
        </div>

    </section>


    <!-- RIGHT: Shopping Cart -->
    <section class="panel" aria-label="Shopping cart">
      <div class="panel-header">
        <h4>Shopping Cart</h4>
        <div class="hdr-pill"><i class="fas fa-shopping-cart"></i></div>
      </div>
      <div class="panel-body">
        <div id="cartItems"></div>
      </div>
      <div class="panel-footer">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <span class="cart-total-label font-weight-bold">Total</span>
          <span id="cartTotal" class="cart-total">$0.00</span>
        </div>
        <div class="d-flex">
          <button id="cartClear" class="btn btn-outline-secondary mr-2">Clear</button>
          <button id="cartAddGlobal" class="btn btn-warning mr-2 btn-tall">Add to Cart</button>
          <button id="cartCheckout" class="btn btn-primary flex-fill btn-tall">Checkout</button>
        </div>
      </div>
    </section>
  </div>
</div>

<!-- Service Picker Modal -->
<div class="modal fade" id="servicePickerModal" tabindex="-1" role="dialog" aria-labelledby="servicePickerLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 id="servicePickerLabel" class="modal-title">Add Services</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span>&times;</span></button>
      </div>
      <div class="modal-body">
        <div id="servicePickerCustomer" class="mb-2 text-muted"></div>
        <div id="servicesContainer"><div class="text-muted">Loading services…</div></div>
      </div>
      <div class="modal-footer">
        <button id="servicePickerCancel" type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
        <button id="servicePickerAdd" type="button" class="btn btn-primary">Add to Cart</button>
      </div>
    </div>
  </div>
</div>

<!-- Upsell / Add-ons Modal -->
<div class="modal fade" id="upsellModal" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Add-ons / Upsells</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span>&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <div id="upsellModalCustomer" class="mb-2 small text-muted"></div>
        <div id="upsellOptions">
          <div class="text-muted">Loading add-ons…</div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-outline-secondary" data-dismiss="modal">Cancel</button>
        <button id="upsellSaveBtn" class="btn btn-primary">Save</button>
      </div>
    </div>
  </div>
</div>

<!-- Staff Picker Modal -->
<div class="modal fade" id="staffPickerModal" tabindex="-1" role="dialog" aria-labelledby="staffPickerLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 id="staffPickerLabel" class="modal-title">Select Service Provider</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span>&times;</span></button>
      </div>
      <div class="modal-body">
        <div class="mb-2 text-muted" id="staffPickerFor"></div>
        <div id="staffPickerContainer"><div class="text-muted">Loading staff…</div></div>
      </div>
      <div class="modal-footer">
        <button id="staffPickerCancel" type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>

<!-- Family Group Modal (Create & Edit) -->
<div class="modal fade" id="familyGroupModal" tabindex="-1" role="dialog" aria-labelledby="familyGroupLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 id="familyGroupLabel" class="modal-title">Family groups</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span>&times;</span></button>
      </div>

      <div class="modal-body">
        <ul class="nav nav-tabs" id="famTabs" role="tablist">
          <li class="nav-item">
            <a class="nav-link active" id="famTabCreate" data-toggle="tab" href="#famPaneCreate" role="tab">Create Family</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" id="famTabEdit" data-toggle="tab" href="#famPaneEdit" role="tab">Edit Families</a>
          </li>
        </ul>

        <div class="tab-content pt-3">
          <!-- CREATE -->
          <div class="tab-pane fade show active" id="famPaneCreate" role="tabpanel">
            <div class="form-group">
              <label class="font-weight-bold">Family name (optional)</label>
              <input id="famNameInput" class="form-control" placeholder="e.g. The Smiths">
            </div>

            <div class="form-group">
              <label class="font-weight-bold d-block mb-2">Select people to group</label>
              <div id="famPickList" class="list-group" style="max-height: 40vh; overflow:auto"></div>
              <small class="text-muted d-block mt-2">Only people not already in a family are shown.</small>
            </div>
          </div>

          <!-- EDIT -->
          <div class="tab-pane fade" id="famPaneEdit" role="tabpanel">
            <div id="famEditInView"><div class="text-muted">Loading…</div></div>
          </div>
        </div>
      </div>

      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
        <button id="famCreateBtn" type="button" class="btn btn-primary">Create family</button>
      </div>
    </div>
  </div>
</div>


<!-- Family Edit Modal -->
<div class="modal fade" id="familyEditModal" tabindex="-1" role="dialog" aria-labelledby="familyEditLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 id="familyEditLabel" class="modal-title">Edit family</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span>&times;</span></button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label class="font-weight-bold">Family name</label>
          <input id="famEditName" class="form-control" placeholder="e.g. The Smiths">
        </div>
        <div class="form-group">
          <label class="font-weight-bold d-block mb-2">Members (in view)</label>
          <div id="famEditList" class="list-group" style="max-height:40vh; overflow:auto"></div>
          <small class="text-muted d-block mt-2">Only people currently in view are shown.</small>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" data-dismiss="modal">Cancel</button>
        <button id="famEditSaveBtn" class="btn btn-primary">Save changes</button>
      </div>
    </div>
  </div>
</div>




<!-- Target Picker Modal (global Add to Cart target) -->
<div class="modal fade" id="targetPickerModal" tabindex="-1" role="dialog" aria-labelledby="targetPickerLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 id="targetPickerLabel" class="modal-title">Add to Cart — Choose target</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span>&times;</span></button>
      </div>
      <div class="modal-body">
        <input id="targetSearch" class="form-control mb-2" placeholder="Search by name or phone…">
        <div id="targetPickerList"><div class="text-muted">Loading…</div></div>
      </div>
      <div class="modal-footer">
        <button id="targetPickCancel" type="button" class="btn btn-secondary" data-dismiss="modal">Cancel</button>
        <button id="targetPickConfirm" type="button" class="btn btn-primary">Next</button>
      </div>
    </div>
  </div>
</div>

<!-- Customer Profile Modal (embedded, no iframe) -->
<div class="modal fade" id="customerProfileModal" tabindex="-1" role="dialog" aria-labelledby="customerProfileLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-xl" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 id="customerProfileLabel" class="modal-title">Customer Profile</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span>&times;</span></button>
      </div>
      <div class="modal-body">
        <div id="customerProfileContent">
          <div class="text-muted">Loading profile…</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Manual Check-in Modal (on-page 2-step flow) -->
<div class="modal fade" id="manualCheckinModal" tabindex="-1" role="dialog" aria-labelledby="manualCheckinLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 id="manualCheckinLabel" class="modal-title">Manually Check-in Client</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span>&times;</span></button>
      </div>
      <div class="modal-body">
        <!-- STEP 1 -->
        <div class="step step-1 active">
          <div class="form-group">
            <label for="mcPhone">Phone Number</label>
            <div class="input-group">
              <input type="tel" class="form-control" id="mcPhone" placeholder="e.g. 0412 345 678 or +61 412 345 678">
              <div class="input-group-append">
                <button class="btn btn-primary" id="mcNext">Next</button>
              </div>
            </div>
            <small class="text-muted">Local numbers starting with 0 are auto-converted to +61.</small>
          </div>
          <div class="loader" id="mcLoader1" style="display:none;border:6px solid #f3f3f3;border-top:6px solid #3498db;border-radius:50%;width:44px;height:44px;animation:mcspin 1.1s linear infinite;margin:10px auto;"></div>
          <div class="text-danger small" id="mcErr1" style="display:none;"></div>
        </div>
        <!-- STEP 2 -->
        <div class="step step-2" style="display:none;">
          <div class="mb-2"><strong>Associated number:</strong> <span id="mcPhoneDisplay"></span></div>
          <div id="mcResults"></div>
          <hr>
          <h6>New Client</h6>
          <div class="form-row">
            <div class="col-8"><input type="text" class="form-control" id="mcNewName" placeholder="Client's First Name"></div>
            <div class="col-4"><button class="btn btn-success btn-block" id="mcAddNew">Add</button></div>
          </div>
          <div class="loader" id="mcLoader2" style="display:none;border:6px solid #f3f3f3;border-top:6px solid #3498db;border-radius:50%;width:44px;height:44px;animation:mcspin 1.1s linear infinite;margin:10px auto;"></div>
          <div class="text-danger small mt-2" id="mcErr2" style="display:none;"></div>
        </div>
      </div>
      <div class="modal-footer"><button class="btn btn-secondary" data-dismiss="modal">Close</button></div>
    </div>
  </div>
</div>

<!-- Checkout Modal (POS) -->
<div class="modal fade pos-checkout" id="checkoutModal" tabindex="-1" role="dialog" aria-hidden="true">
 <div class="modal-dialog" role="document">


    <div class="modal-content" id="coContent">

      <div class="modal-header">
        <div>
          <div id="coCustomerName" class="customer-name">Customer</div>
          <div class="text-muted" style="font-size:.9rem;">Group payment flow</div>
        </div>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span>&times;</span></button>
      </div>

        <div class="modal-body">
          <div id="cardDeclinedBanner" class="card-declined-banner" style="display:none;" role="alert" aria-live="assertive">
            DECLINED
          </div>
        
          <div class="d-flex justify-content-between align-items-center">
            <span class="text-muted">Total due</span>
            <span id="coTotal" data-total-cents="0" class="total-due">$0.00</span>
          </div>
        

        <!-- Method tiles -->
        <div class="method-tiles">
          <div id="tileCash" class="method-tile active" data-method="cash">
            <div><i class="fas fa-money-bill-wave"></i></div> Cash
          </div>
          <div id="tileCard" class="method-tile" data-method="card">
            <div><i class="fas fa-credit-card"></i></div> Card
          </div>
        </div>

        <!-- CASH section -->
        <div id="coCashSection">
          <div class="tender-row">
            <div class="flex-grow-1">
              <label for="coTender" class="mb-1">Tendered</label>
              <input type="number" step="0.01" class="form-control" id="coTender" placeholder="Tap keys below" readonly>
            </div>
          </div>

          <!-- Quick cash chips -->
          <div class="quick-cash" id="coQuickCash"></div>

          <!-- Keypad -->
          <div class="keypad mb-2" id="coNumKeys">
            <!-- 1..9 -->
            <div class="key" data-val="1">1</div>
            <div class="key" data-val="2">2</div>
            <div class="key" data-val="3">3</div>
            <div class="key" data-val="4">4</div>
            <div class="key" data-val="5">5</div>
            <div class="key" data-val="6">6</div>
            <div class="key" data-val="7">7</div>
            <div class="key" data-val="8">8</div>
            <div class="key" data-val="9">9</div>
            <!-- dot, 0, backspace -->
            <div class="key" data-val="00">00</div>
            <div class="key" data-val="0">0</div>
            <div class="key" data-action="back">←</div>
          </div>

          <div class="change-line">
            <span class="text-muted">Change</span>
            <span id="coChange" class="change-amt">$0.00</span>
          </div>
        </div>

        <!-- CARD section -->
        <div id="coCardAlert" class="alert alert-danger" style="display:none;">
          Error: Please connect EFTPOS terminal.
        </div>

        <hr>

        <!-- Email capture -->
        <div class="email-header">
          <label for="coEmail" class="mb-0">Email for receipt (optional)</label>
          <button class="btn btn-outline-secondary btn-sm" id="toggleEmailKeys" type="button">On-screen keyboard</button>
        </div>
        <input type="email" class="form-control mt-1" id="coEmail" placeholder="customer@email.com">

        <div class="email-keypad" id="coEmailKeypad">
          <div class="email-grid" id="coEmailGrid">
            <!-- Row 1 -->
            <div class="ekey" data-ch="q">q</div><div class="ekey" data-ch="w">w</div><div class="ekey" data-ch="e">e</div><div class="ekey" data-ch="r">r</div><div class="ekey" data-ch="t">t</div><div class="ekey" data-ch="y">y</div><div class="ekey" data-ch="u">u</div><div class="ekey" data-ch="i">i</div><div class="ekey" data-ch="o">o</div><div class="ekey" data-ch="p">p</div>
            <!-- Row 2 -->
            <div class="ekey" data-ch="a">a</div><div class="ekey" data-ch="s">s</div><div class="ekey" data-ch="d">d</div><div class="ekey" data-ch="f">f</div><div class="ekey" data-ch="g">g</div><div class="ekey" data-ch="h">h</div><div class="ekey" data-ch="j">j</div><div class="ekey" data-ch="k">k</div><div class="ekey" data-ch="l">l</div><div class="ekey" data-ch="@">@</div>
            <!-- Row 3 -->
            <div class="ekey" data-ch="z">z</div><div class="ekey" data-ch="x">x</div><div class="ekey" data-ch="c">c</div><div class="ekey" data-ch="v">v</div><div class="ekey" data-ch="b">b</div><div class="ekey" data-ch="n">n</div><div class="ekey" data-ch="m">m</div><div class="ekey" data-ch=".">.</div><div class="ekey" data-ch="_">_</div><div class="ekey" data-ch="-">-</div>
            <!-- Row 4 -->
            <div class="ekey" data-ch="1">1</div><div class="ekey" data-ch="2">2</div><div class="ekey" data-ch="3">3</div><div class="ekey" data-ch="4">4</div><div class="ekey" data-ch="5">5</div><div class="ekey" data-ch="6">6</div><div class="ekey" data-ch="7">7</div><div class="ekey" data-ch="8">8</div><div class="ekey" data-ch="9">9</div><div class="ekey" data-ch="0">0</div>
            <!-- Row 5 specials -->
            <div class="ekey" data-action="space">␣</div>
            <div class="ekey" data-ch=".com">.com</div>
            <div class="ekey" data-action="back">←</div>
            <div class="ekey" data-action="clear">CLR</div>
          </div>
          <div class="email-domains mt-2">
            <span class="badge badge-light domain-chip" data-dom="@gmail.com">@gmail.com</span>
            <span class="badge badge-light domain-chip" data-dom="@outlook.com">@outlook.com</span>
            <span class="badge badge-light domain-chip" data-dom="@yahoo.com">@yahoo.com</span>
          </div>
        </div>

        <div id="coSuccess" class="alert alert-success" style="display:none;"></div>
      </div>

        <div class="modal-footer">
          <button type="button" id="coPrimaryBtn" class="btn btn-primary btn-lg btn-block w-100">Send to Terminal</button>
        </div>

    </div>
  </div>
</div>

<!-- Signature Modal -->
<div class="modal fade" id="tsSignModal" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document" style="max-width:520px;">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title"><i class="fas fa-pen-nib mr-1"></i>Confirm with signature</h5>
        <button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>
      </div>
      <div class="modal-body">

        <!-- hide the name row; we’ll send staff_name from roster -->
        <div class="form-group" style="display:none;">
          <label>Your name</label>
          <input id="tsSignName" class="form-control">
        </div>

        <div class="border rounded" style="position:relative;">
          <div id="tsSignTimes" class="small text-muted mb-2"></div>

          <canvas id="tsSignCanvas" style="width:100%; touch-action:none; display:block;"></canvas>
          <div id="tsSignHint" class="small text-muted p-2">
            Sign inside the box to confirm.
          </div>
        </div>

        <div class="mt-2 d-flex justify-content-between">
          <button id="tsSignClear" class="btn btn-outline-secondary btn-sm" type="button">Clear</button>
          <div class="small text-muted">PNG is stored with the timesheet record.</div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn-secondary" data-dismiss="modal">Cancel</button>
        <button id="tsSignSave" class="btn btn-primary">Confirm</button>
      </div>
    </div>
  </div>
</div>





<footer class="footer-bar">
  <div class="footer-inner">
    <div class="footer-left">
      <?php if (!empty($footerLogoUrl)): ?>
        <img class="footer-logo"
             src="<?php echo htmlspecialchars($footerLogoUrl, ENT_QUOTES); ?>"
             alt="<?php echo htmlspecialchars($footerBizName ?: 'Business logo', ENT_QUOTES); ?>">
      <?php endif; ?>
      <span class="footer-powered">Powered by <strong>LineUpz.ai</strong></span>
    </div>

    <!-- Online/offline pill now lives in the footer -->
    <span id="onlineStatusBadge" class="online">Online</span>
  </div>
</footer>


<!-- Side tabs rail -->
<div class="side-tabs" aria-label="Side tabs">
  <button id="insightTab" class="side-tab" aria-expanded="false" aria-controls="insightDrawer" title="Show insights">
    <span class="side-tab-label"><i class="fas fa-chart-pie"></i> Insights</span>
  </button>

  <button id="timesheetTab" class="side-tab" aria-expanded="false" aria-controls="timesheetDrawer" title="Show timesheets">
    <span class="side-tab-label"><i class="fas fa-user-clock"></i> Timesheets</span>
    <span id="tsBadge" aria-hidden="true">0</span>
  </button>

  <!-- NEW: 24/7 AI Support tab -->
  <button
    id="aiSupportTab"
    class="side-tab"
    aria-expanded="false"
    title="Open 24/7 AI Support">
    <span class="side-tab-label">
      <i class="fas fa-robot"></i> 24/7 AI Support
    </span>
  </button>
</div>



<aside id="insightDrawer" class="insight-drawer" aria-hidden="true">
  <div class="id-header">
    <strong>Today’s Insights</strong>
    <button type="button" id="insightClose" class="id-close" aria-label="Close">&times;</button>
  </div>
    <div class="id-body">
        <div class="id-section id-two-up">
          <div>
            <div class="id-title">Turnover by staff</div>
            <canvas id="pieCuts"></canvas>
          </div>
          <div>
            <div class="id-title">5 ★ feedback</div>
            <canvas id="pieReviews"></canvas>
            <div id="reviewsNote" class="muted small mt-1"></div>
          </div>
        </div>
        
        <div class="id-section">
          <div class="id-title">Hourly — turnover by staff & wait time</div>
          <canvas id="barHourly"></canvas>
        </div>

        <div class="id-section id-two-up">
          <div>
            <div class="id-title">Cancelled services</div>
            <div id="cancelList" class="mini-list"></div>
          </div>
          <div>
            <div class="id-title">Today’s feedback</div>
            <div id="fbList" class="mini-list"></div>
          </div>
        </div>

    
      <div class="id-foot muted small mt-2" id="statDate"></div>
    </div>

</aside>


<!-- Timesheets drawer -->
<aside id="timesheetDrawer" class="insight-drawer" aria-hidden="true">
  <div class="id-header">
    <strong>Timesheets (Today)</strong>
    <button type="button" id="timesheetClose" class="id-close" aria-label="Close">&times;</button>
  </div>
  <div class="id-body">
    <div class="id-section">
      <div class="id-title">Rostered staff</div>
      <div id="tsRosterList" class="mini-list"></div>
      <div id="tsHint" class="small muted mt-2"></div>
    </div>

    <div class="id-section">
      <div class="id-title">Today’s punches</div>
      <div id="tsTodayList" class="mini-list"></div>
    </div>
  </div>
</aside>

<!-- AI Support drawer -->
<aside id="aiSupportDrawer" class="insight-drawer" aria-hidden="true">
  <div class="id-header">
    <strong>24/7 AI Support</strong>
    <button type="button" id="aiSupportClose" class="id-close" aria-label="Close">&times;</button>
  </div>
  <div class="id-body" id="aiSupportBody">
    <iframe
      id="aiSupportFrame"
      src=""
      title="LineUpz 24/7 AI Support"
      style="border:0;width:100%;height:100%;"></iframe>
  </div>
</aside>




<script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
<script>
// Disable all Chart.js tooltips globally
if (window.Chart && Chart.defaults && Chart.defaults.plugins && Chart.defaults.plugins.tooltip) {
  Chart.defaults.plugins.tooltip.enabled = false;
}
</script>


<script>
// ===== Online/offline flag & badge (PWA-friendly) =====
window.APP_ONLINE = navigator.onLine !== false;

function updateTimesheetTabState(){
  var $tsTab = $('#timesheetTab');
  var $aiTab = $('#aiSupportTab');

  if (!$tsTab.length) return;

  if (window.APP_ONLINE === false) {
    $tsTab.addClass('disabled').attr('aria-disabled', 'true');
    if ($aiTab.length) {
      $aiTab.addClass('disabled').attr('aria-disabled', 'true');
    }
  } else {
    $tsTab.removeClass('disabled').attr('aria-disabled', 'false');
    if ($aiTab.length) {
      $aiTab.removeClass('disabled').attr('aria-disabled', 'false');
    }
  }
}

function prefetchLinklyTokenIfNeeded(){
  if (window.APP_ONLINE === false) return;
  var p = (window.PREFERRED_EFTPOS || '').toLowerCase();
  if (p.indexOf('linkly') === -1) return;
  // Fire-and-forget; response is only used to warm the PHP session
  $.getJSON(window.location.pathname + '?action=linkly_prefetch_token');
}


function updateOnlineBadge() {
  var $b = $('#onlineStatusBadge');
  if (!$b.length) return;

  if (window.APP_ONLINE) {
    $b.removeClass('offline').addClass('online').text('Online');
  } else {
    // Always show the same footer message when offline
    $b
      .removeClass('online')
      .addClass('offline')
      .text('Offline – Limited functionality (check shop Wi-Fi).');
  }
}

function clearAiSupportConversationInFrame(hardReset = true) {
  try {
    var f = document.getElementById('aiSupportFrame');
    if (f && f.contentWindow) {
      // Tell iframe to reset its JS + clear server doc cache
      f.contentWindow.postMessage({ type: 'LPZ_AI_SUPPORT_CLEAR' }, window.location.origin);
    }
    // Optional hard reset: unload the iframe so it always reboots fresh next open
    if (hardReset && f) {
      f.src = 'about:blank';
    }
  } catch (e) {}
}


function toggleAiSupport(open) {
  var $dr = $('#aiSupportDrawer');
  var isOpen = (open != null) ? !!open : !$dr.hasClass('open');

  // When closing, clear the iframe conversation + optionally unload it
  if (!isOpen) {
    clearAiSupportConversationInFrame(true);
  }

  $dr.toggleClass('open', isOpen).attr('aria-hidden', !isOpen);
  $('#aiSupportTab').attr('aria-expanded', isOpen);
  $('body').toggleClass('ai-support-open', isOpen);

  if (isOpen) {
    var qid = $('#userQueueId').val() || '';
    if (!qid) return;

    var wanted = '/ai-support.php?' + encodeURIComponent(qid);
    var $frame = $('#aiSupportFrame');
    if ($frame.attr('src') !== wanted) {
      $frame.attr('src', wanted);
    }
  }
}


function openAiSupportWindow() {
  var qid = $('#userQueueId').val() || '';

  if (!qid) {
    if (typeof showSnack === 'function') {
      showSnack('Missing shop ID for AI Support.', true, 2200);
    } else {
      alert('Missing shop ID for AI Support.');
    }
    return;
  }

  if (window.APP_ONLINE === false) {
    var msg = '24/7 AI Support needs internet to talk to the AI.';
    if (typeof showSnack === 'function') {
      showSnack(msg, true, 2200);
    } else {
      alert(msg);
    }
    return;
  }

  // Open the in-page drawer instead of a popup
  toggleAiSupport(true);
}



window.addEventListener('online', function () {
  window.APP_ONLINE = true;
  updateOnlineBadge();
  updateTimesheetTabState();        // 👈 NEW

  // Refresh services list for both online picker + offline cache
  fetchServicesFresh();
  
  prefetchLinklyTokenIfNeeded();


  // 🔁 Sync any queued actions (serve, callbacks, etc.)
  replayOfflineJobs();

  // ✅ First sync check-ins; when that finishes, sync payments
  trySyncOfflineCheckins().always(function () {
    trySyncOfflinePayments();
  });
});


window.addEventListener('offline', function () {
  window.APP_ONLINE = false;
  updateOnlineBadge();
  updateTimesheetTabState();        // 👈 NEW

  // Close online-only UI when we lose connection
  if (typeof toggleInsights === 'function') {
    toggleInsights(false);
  }
  $('#familyGroupModal, #familyEditModal').modal('hide');
});



// ==== Signature canvas globals (must exist before binding) ====
let tsSignCtx = null;
let tsSignCanvas = null;

let tsSignDPR = 1;
let tsSignDrawing = false;
let tsSignStaffId = 0;
let tsSignDirty = false;
let CURRENT_PROFILE_CUSTOMER_ID = null;

// LEFT PANEL: offline "queued" check-ins (not yet in LineUpz)
function renderOfflineCheckins() {
  const $wrap = $('#offlineQueueWrap').empty();

  const queued = offlineCheckins.filter(e => (e.state || 'queued') === 'queued');

  // ✅ NEW: if we have *any* offline check-ins, remove the "No clients checked in." placeholder
  if (queued.length) {
    const $q = $('#queueList');
    const $empty = $q.find('.checkedin-empty');
    if ($empty.length) {
      // only remove that placeholder row, not any real cards
      $empty.remove();
    }
  }  
  
  if (!queued.length) {
    renderOfflineServedInPanel();   // still paint any offline-served rows
    return;
  }

  $wrap.append(
    '<div class="text-muted small mb-1">Offline check-ins (not yet saved to LineUpz)</div>'
  );

  queued.forEach(entry => {
    const name  = entry.name || 'Customer';
    const phone = formatPhoneAU(entry.phone);

    const $row = $(`
      <div class="queue-item d-flex flex-column offline-queued" data-temp-id="${entry.tempId}">
        <!-- top row: actions, same layout as online: Serve / Add to Cart / Delete -->
        <div class="qi-subrow">
          <button
            type="button"
            class="btn btn-success btn-slim btn-compact btn-grow btn-offline-serve">
            Serve
          </button>
          <button
            type="button"
            class="btn btn-outline-danger btn-slim btn-compact btn-grow btn-offline-delete">
            Delete
          </button>
        </div>


        <!-- second row: name + offline badge, like online checked-in headline -->
        <div class="ci-line">
          <span class="ci-name">${h(name)}</span>
          ${phone ? `<span class="ci-phone">${h(phone)}</span>` : '<span class="ci-phone"></span>'}
          <div class="ci-right">
            <span class="badge badge-secondary">Offline</span>
          </div>
        </div>

        <div class="muted small mt-1">
          Offline – will sync when back online
        </div>

        ${phone ? '' : ''}
      </div>
    `);

    $wrap.append($row);
  });


  // Also mirror any "served" offline clients into the Served column.
  // When we're online, renderServedList() will position them correctly;
  // here we only draw them while fully offline.
  if (window.APP_ONLINE === false) {
    renderOfflineServedInPanel();
  }
}



// MIDDLE PANEL: show offline-served customers in the Served column
function renderOfflineServedInPanel(latestOnlineMs) {
  const $wrap = $('#servedList');
  if (!$wrap.length) return;

  // Clear any old offline section
  $wrap.find('.offline-served-header, .offline-served-item').remove();

  const servedEntries = offlineCheckins.filter(e => (e.state || 'queued') === 'served');
  if (!servedEntries.length) return;

  // Remove the "no served" placeholder if we now have offline-served rows
  $wrap.find('.served-empty').remove();

  // Sort offline served by servedAt/createdAt (newest first inside the block)
  const sorted = servedEntries.slice().sort((a, b) => {
    const aMs = parseLocalMs(a.servedAt || a.createdAt || '');
    const bMs = parseLocalMs(b.servedAt || b.createdAt || '');
    return (bMs || 0) - (aMs || 0);
  });

  const latestOfflineMs = sorted.length
    ? (parseLocalMs(sorted[0].servedAt || sorted[0].createdAt || '') || 0)
    : 0;

  // Decide if the offline block should sit ABOVE or BELOW the online served list
  const placeAtTop = !latestOnlineMs || latestOfflineMs >= latestOnlineMs;

  const $block = $('<div/>');

  const $hdr = $(`
    <div class="offline-served-header text-muted small mt-3 mb-1">
      Offline served (will sync when online)
    </div>
  `);
  $block.append($hdr);

  sorted.forEach(entry => {
    const tempId = entry.tempId;
    const name   = entry.name || 'Customer';
    const phone  = formatPhoneAU(entry.phone);
    const staff  = entry.staffName ? ` — ${entry.staffName}` : '';
    const isDone = !!entry.finished;
    const isPaid = !!entry.paid;

    const $row = $(`
      <div class="queue-item offline-served-item" data-temp-id="${tempId}">
        <div class="qi-subrow">
          <button
            type="button"
            class="btn btn-orange btn-compact btn-slim btn-finish-offline btn-finish"
            ${isDone ? 'disabled' : ''}>
            ${isDone ? 'Finished' : 'Finish Service'}
          </button>
          <button
            type="button"
            class="btn btn-outline-primary btn-compact btn-slim btn-grow btn-offline-addcart btn-add-cart"
            ${isPaid ? 'disabled' : ''}>
            Add to Cart
          </button>
        </div>

        <div class="qi-headline">
          <span class="qi-name font-weight-bold">${h(name)}</span>
          <div class="d-flex align-items-center">
            ${isPaid ? '<span class="badge badge-success mr-1">Paid</span>' : ''}
            <span class="badge badge-secondary">Offline</span>
          </div>
        </div>

        <div class="muted small mt-1">
          Offline – will sync when back online
        </div>

        <div class="appointment-info">
          ${h(phone)}${staff}
        </div>
      </div>
    `);

    $block.append($row);
  });

  // Put the offline block either above or below the online served rows
  if (placeAtTop) {
    $wrap.prepend($block.children());
  } else {
    $wrap.append($block.children());
  }
}



// OFFLINE: Add to cart for offline check-ins/served -> use Quick Sale under the hood
$(document).on('click', '.btn-offline-addcart', function () {
  // If it's disabled/misted, do nothing
  if ($(this).prop('disabled') || $(this).hasClass('disabled')) return;

  const $row   = $(this).closest('.queue-item');
  const tempId = $row.data('temp-id');
  if (!tempId) {
    // Safety fallback: if something is wrong, fall back to Quick Sale.
    openServicePickerForQuickSale();
    return;
  }

  const entry = offlineCheckins.find(e => e.tempId === tempId);
  if (!entry) {
    openServicePickerForQuickSale();
    return;
  }

  // Already paid offline → no more cart
  if (entry.paid) {
    if (typeof showSnack === 'function') {
      showSnack('This offline check-in has already been paid.', true, 2200);
    }
    return;
  }


  // Treat this offline check-in as its own "customer" in the picker/cart
  pickerCustomer    = {
    id:       entry.tempId,
    firstName: entry.name || 'Customer',
    queue_id: businessId   // same as your normal queue id for this POS
  };
  pickerIsQuickSale = false;   // important: NOT Quick Sale
  pickerRedoAllowed = false;   // no redo logic for offline

  $('#servicePickerCustomer').html(
    '<strong>Customer:</strong> ' +
    $('<div/>').text(entry.name || 'Customer').html() +
    ' <span class="badge badge-secondary ml-1">Offline</span>'
  );

  const isOffline = (window.APP_ONLINE === false);

  if (isOffline) {
    // Use cached services for offline cart building
    if (!cachedServices || !Array.isArray(cachedServices) || !cachedServices.length) {
      $('#servicesContainer').html(
        '<div class="text-danger">Services are only available for offline check-ins after this device has loaded them once while online.</div>'
      );
      $('#servicePickerModal').modal('show');
      return;
    }

    // No Q-token / Redo logic while offline
    pickerQTokens       = 0;
    pickerHasQFeature   = false;
    pickerTokenBudget   = 0;
    pickerTokenSelected = 0;

    // Pre-fill any local cart lines already attached to this tempId
    const existingLocal = cart.items.filter(
      it => String(it.customerId) === String(entry.tempId)
    );

    renderServiceOptions(cachedServices);

    if (existingLocal.length) {
      $('#servicesContainer .svc-cell').each(function(){
        const svc = $(this).data('svc'); if (!svc) return;
        const match = existingLocal.find(it => Number(it.serviceId) === Number(svc.id));
        if (match) {
          const q = Number(match.qty || 1);
          $(this).data('base', q).data('count', q);
          $(this).find('.svc-ui').show().find('.svc-count').text(q);
        }
      });
    }

    applyScanEntriesToPicker();
    renderScanStrip();
    $('#servicePickerModal').modal('show');
    return;
  }

  // If we happen to be back online and hit this button, treat it like a normal customer
  openServicePickerForCustomer(
    { id: entry.syncedCustomerId || entry.tempId, first_name: entry.name, queue_id: businessId },
    true
  );
});



// OFFLINE: mark a temp check-in as "served" (local only) and choose staff
$(document).on('click', '.btn-offline-serve', function () {
  const $row   = $(this).closest('.queue-item');
  const tempId = $row.data('temp-id');
  if (!tempId) return;

  const entry = offlineCheckins.find(e => e.tempId === tempId);
  if (!entry || (entry.state || 'queued') === 'served') return;

  openStaffChooser(
    'Serving: ' + $('<div/>').text(entry.name || 'Customer').html(),
    function onPicked(staff) {
      entry.state      = 'served';
      entry.staffId    = staff.id;
      entry.staffName  = staff.name;
      entry.servedAt   = new Date().toISOString();
      // New fields for offline finish
      entry.finished   = entry.finished   || false;
      entry.finishedAt = entry.finishedAt || null;
      entry.serviceSecs= entry.serviceSecs|| null;

      saveOfflineCheckins();
      renderOfflineCheckins();        // refresh left
      renderOfflineServedInPanel();   // refresh middle
      showSnack('Marked as served (offline only)', false, 1800);
    },

    function onCancel() {
      // do nothing
    }
  );
});

// OFFLINE: delete a temp check-in completely
$(document).on('click', '.btn-offline-delete', function () {
  const $row   = $(this).closest('.queue-item');
  const tempId = $row.data('temp-id');
  if (!tempId) return;

  offlineCheckins = offlineCheckins.filter(e => e.tempId !== tempId);
  saveOfflineCheckins();
  renderOfflineCheckins();
  renderOfflineServedInPanel();
});

// OFFLINE: finish service for an offline-served client (local only; sync later)
$(document).on('click', '.btn-finish-offline', function () {
  const $btn   = $(this);
  const $row   = $btn.closest('.offline-served-item');
  const tempId = $row.data('temp-id');
  if (!tempId) return;

  const entry = offlineCheckins.find(e => e.tempId === tempId);
  if (!entry || entry.finished) return;

  entry.finished   = true;
  entry.finishedAt = new Date().toISOString();

  // Optional: rough service duration based on servedAt
  if (entry.servedAt) {
    const start = Date.parse(entry.servedAt);
    if (Number.isFinite(start)) {
      entry.serviceSecs = Math.max(0, Math.floor((Date.now() - start) / 1000));
    }
  }

  saveOfflineCheckins();
  renderOfflineServedInPanel();
  showSnack('Service finished (offline only)', false, 1800);
});





function toLocalHM(ts){
  if (!ts) return '—';
  // Accepts 'YYYY-MM-DD HH:MM:SS' or ISO; treat as local if no timezone info
  // Convert safely by replacing space to 'T' so mobile Safari parses it:
  const s = String(ts).replace(' ', 'T');
  const d = new Date(s);
  if (isNaN(d)) return '—';
  return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
}

function utcToLocalHM(ts){
  if (!ts) return '—';
  const ms = Date.parse(String(ts).replace(' ', 'T') + 'Z'); // force UTC
  if (!Number.isFinite(ms)) return '—';
  return new Date(ms).toLocaleTimeString([], { hour:'2-digit', minute:'2-digit' });
}

function rangeLocalHM(startTs, endTs){
  const a = toLocalHM(startTs);
  const b = toLocalHM(endTs);
  return (a && b) ? `${a} – ${b}` : (a || b || '—');
}

    
    
/* ============================
   Persistent status (no flicker across refresh)
============================ */
const STORAGE_KEY = 'cartStatusCache_v1';
let cartStatusCache = {};
try { cartStatusCache = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}') || {}; } catch(e){ cartStatusCache = {}; }
function persistStatus() { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(cartStatusCache)); } catch(e){} }

const cartStatusInflight = new Set();
const businessId = Number($('#userQueueId').val() || 0);

// Global cache for services (used online + offline)
let cachedServices = null;


// ===== Services cache (for offline service picker) =====
const SERVICES_CACHE_KEY = `lpz_servicesCache_${businessId}`;
try {
  const raw = localStorage.getItem(SERVICES_CACHE_KEY);
  if (raw) {
    const parsed = JSON.parse(raw);
    if (Array.isArray(parsed) && parsed.length) {
      cachedServices = parsed;
    }
  }
} catch(e) {
  cachedServices = null;
}
function saveServicesCache(list) {
  cachedServices = Array.isArray(list) ? list : [];
  try { localStorage.setItem(SERVICES_CACHE_KEY, JSON.stringify(cachedServices)); } catch(e){}
}

// Always-fresh fetch for services (used online) + keeps offline cache warm
function fetchServicesFresh() {
  if (window.APP_ONLINE === false) {
    // offline → nothing to do, will use cachedServices if we have it
    return $.Deferred().resolve().promise();
  }

  return $.getJSON(window.location.pathname + '?action=services')
    .done(function (resp) {
      if (resp && resp.ok && Array.isArray(resp.services)) {
        // This keeps cachedServices + localStorage up to date for offline use
        saveServicesCache(resp.services);
      }
    })
    .fail(function () {
      // No-op: offline still works off the last cached snapshot
      console.warn('fetchServicesFresh failed (will rely on cache if present)');
    });
}


// Profile prefetch set (mark which IDs we've already pulled in this session)
const PROFILE_PREFETCHED = new Set();


// ───── Customer profile cache (for offline view-only) ─────
const PROFILE_CACHE_PREFIX = 'lpz_profileCache_' + businessId + '_';

function saveProfileCache(customerId, payload){
  try {
    localStorage.setItem(
      PROFILE_CACHE_PREFIX + String(customerId),
      JSON.stringify(payload)
    );
  } catch(e){}
}

function loadProfileCache(customerId){
  try {
    const raw = localStorage.getItem(PROFILE_CACHE_PREFIX + String(customerId));
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    return (parsed && typeof parsed === 'object') ? parsed : null;
  } catch(e){
    return null;
  }
}


function prefetchProfilesForVisible(){
  // Only prefetch when actually online
  if (window.APP_ONLINE === false) return;

  const ids = collectVisibleCids();  // Checked-in + Served
  if (!ids || !ids.length) return;

  const toFetch = [];

  for (const cid of ids) {
    const idNum = Number(cid);
    if (!idNum) continue;

    // Already prefetched in this session
    if (PROFILE_PREFETCHED.has(idNum)) continue;

    // Already have a cached snapshot in localStorage
    if (loadProfileCache(idNum)) {
      PROFILE_PREFETCHED.add(idNum);
      continue;
    }

    toFetch.push(idNum);
    if (toFetch.length >= 3) break;   // small batch per tick so we don't hammer the server
  }

  if (!toFetch.length) return;

  toFetch.forEach(function(idNum){
    PROFILE_PREFETCHED.add(idNum);

    $.getJSON(window.location.pathname + '?action=customer_profile_data', { customer_id: idNum })
      .done(function(resp){
        if (resp && resp.ok) {
          saveProfileCache(idNum, resp);
        }
      })
      .fail(function(){
        // silent: manual profile open will still try again
      });
  });
}

// Offline temp customer → real customer_id mapping
const OFFLINE_CUST_MAP_KEY = `lpz_off_cust_map_${businessId}`;
let OFFLINE_CUST_MAP = {};
try {
  OFFLINE_CUST_MAP = JSON.parse(localStorage.getItem(OFFLINE_CUST_MAP_KEY) || '{}') || {};
} catch (e) {
  OFFLINE_CUST_MAP = {};
}

function saveOfflineCustMap() {
  try { localStorage.setItem(OFFLINE_CUST_MAP_KEY, JSON.stringify(OFFLINE_CUST_MAP)); }
  catch (e) {}
}

function rememberOfflineCustomerMapping(tempId, realCustomerId, queueId) {
  if (!tempId || !realCustomerId) return;
  OFFLINE_CUST_MAP[String(tempId)] = {
    customer_id: Number(realCustomerId),
    queue_id: Number(queueId || businessId)
  };
  saveOfflineCustMap();
}


const OFFLINE_CHECKINS_KEY = `lpz_offline_checkins_${businessId}`;
let offlineCheckins = [];
try {
  offlineCheckins = JSON.parse(localStorage.getItem(OFFLINE_CHECKINS_KEY) || '[]') || [];
} catch (e) {
  offlineCheckins = [];
}
function saveOfflineCheckins() {
  try {
    localStorage.setItem(OFFLINE_CHECKINS_KEY, JSON.stringify(offlineCheckins));
  } catch (e) {}
}

/* ==== STAFF CACHE (for offline staff list) ==== */
const STAFF_CACHE_KEY = `lpz_staffCache_${businessId}`;
let STAFF_CACHE = [];
try {
  STAFF_CACHE = JSON.parse(localStorage.getItem(STAFF_CACHE_KEY) || '[]') || [];
} catch (e) {
  STAFF_CACHE = [];
}

function saveStaffCache(list) {
  STAFF_CACHE = Array.isArray(list) ? list : [];
  try {
    localStorage.setItem(STAFF_CACHE_KEY, JSON.stringify(STAFF_CACHE));
  } catch (e) {}
}

/**
 * Smart fetch for staff list:
 *  - if ONLINE: hit ?action=staff_list and cache result
 *  - if OFFLINE: return cached list (if any)
 */
function fetchStaffSmart() {
  const d = $.Deferred();

  if (window.APP_ONLINE === false) {
    // Offline → return whatever we last cached
    d.resolve({ ok: true, staff: STAFF_CACHE.slice() });
  } else {
    $.getJSON(window.location.pathname + '?action=staff_list')
      .done(function (resp) {
        if (resp && resp.ok && Array.isArray(resp.staff)) {
          saveStaffCache(resp.staff);
          d.resolve(resp);
        } else {
          d.resolve({ ok: false, staff: STAFF_CACHE.slice() });
        }
      })
      .fail(function () {
        // Server call failed – fall back to cache
        d.resolve({ ok: false, staff: STAFF_CACHE.slice() });
      });
  }

  return d.promise();
}


/* ==== OFFLINE JOB QUEUE: best-effort for queue actions (serve, callback, etc) ==== */
const OFFLINE_JOBS_KEY = `lpz_offlineJobs_${businessId}`;
let offlineJobs = [];
try {
  offlineJobs = JSON.parse(localStorage.getItem(OFFLINE_JOBS_KEY) || '[]') || [];
} catch (e) {
  offlineJobs = [];
}

function saveOfflineJobs() {
  try {
    localStorage.setItem(OFFLINE_JOBS_KEY, JSON.stringify(offlineJobs));
  } catch (e) {}
}

/* ==== OFFLINE CASH PAYMENTS (to sync when back online) ==== */
const OFFLINE_PAYMENTS_KEY = `lpz_offline_payments_${businessId}`;
let offlinePayments = [];
try {
  offlinePayments = JSON.parse(localStorage.getItem(OFFLINE_PAYMENTS_KEY) || '[]') || [];
} catch (e) {
  offlinePayments = [];
}
function saveOfflinePayments() {
  try {
    localStorage.setItem(OFFLINE_PAYMENTS_KEY, JSON.stringify(offlinePayments));
  } catch (e) {}
}

function markOfflinePaidForGroup(tempKey){
  if (!tempKey) return;
  let changed = false;

  offlineCheckins.forEach(entry => {
    if (String(entry.tempId) === String(tempKey)) {
      entry.paid   = true;
      entry.paidAt = new Date().toISOString();
      changed = true;
    }
  });

  if (changed) {
    // Treat this offline customer like a normal "paid" cart target
    cartStatusCache[String(tempKey)] = 'paid';
    persistStatus();

    saveOfflineCheckins();
    // Repaint offline queued + served to show Paid badge / misted Add to Cart
    renderOfflineCheckins();
  }
}



// Replay a single offline cash payment when we are back online
async function syncOneOfflinePayment(pay) {
  try {
    let allOk = true;

    for (const entry of (pay.customers || [])) {

      // 1) Quick Sale: recreate items then mark paid
      if (entry.type === 'qs') {
        await $.ajax({
          url: window.location.pathname + '?action=qs_add_items',
          type: 'POST',
          contentType: 'application/json',
          data: JSON.stringify({
            items:    entry.items || [],
            staff_id: entry.staff_id || null
          })
        });

        await $.ajax({
          url: window.location.pathname + '?action=qs_mark_paid',
          type: 'POST',
          contentType: 'application/json',
          data: JSON.stringify({
            payment_method: pay.method || 'cash',
            external_ref:   '',
            txn_group:      pay.txn_group || '',
            staff_id:       entry.staff_id || null
          })
        });
      }

      // 2) Normal online customer
      else if (entry.type === 'customer') {
        await $.ajax({
          url: window.location.pathname + '?action=cart_add_items',
          type: 'POST',
          contentType: 'application/json',
          data: JSON.stringify({
            customer_id: entry.customer_id,
            queue_id:    entry.queue_id,
            items:       entry.items || []
          })
        });

        await $.ajax({
          url: window.location.pathname + '?action=cart_mark_paid',
          type: 'POST',
          contentType: 'application/json',
          data: JSON.stringify({
            customer_id:    entry.customer_id,
            queue_id:       entry.queue_id,
            payment_method: pay.method || 'cash',
            external_ref:   '',
            txn_group:      pay.txn_group || ''
          })
        });
      }

      // 3) Offline temp customer: needs mapping from tempId -> real customer
      else if (entry.type === 'offline') {
        const mapping = OFFLINE_CUST_MAP && OFFLINE_CUST_MAP[String(entry.temp_id || '')];

        if (!mapping || !mapping.customer_id) {
          console.warn('Offline payment: no mapping yet for temp customer', entry.temp_id);
          // abort this whole payment; it'll stay in offlinePayments and retry next time
          allOk = false;
          break;
        }

        const cid = mapping.customer_id;
        const qid = mapping.queue_id || entry.queue_id || businessId;

        await $.ajax({
          url: window.location.pathname + '?action=cart_add_items',
          type: 'POST',
          contentType: 'application/json',
          data: JSON.stringify({
            customer_id: cid,
            queue_id:    qid,
            items:       entry.items || []
          })
        });

        await $.ajax({
          url: window.location.pathname + '?action=cart_mark_paid',
          type: 'POST',
          contentType: 'application/json',
          data: JSON.stringify({
            customer_id:    cid,
            queue_id:       qid,
            payment_method: pay.method || 'cash',
            external_ref:   '',
            txn_group:      pay.txn_group || ''
          })
        });
      }
    }

    return allOk;
  } catch (e) {
    console.warn('Offline payment sync failed', pay, e);
    return false;
  }
}




// Top-level helper: sync all queued offline payments once online
async function trySyncOfflinePayments() {
  if (window.APP_ONLINE === false || !offlinePayments.length) return;

  const pending = offlinePayments.slice();
  offlinePayments = [];
  saveOfflinePayments();

  let okCount = 0;
  let failCount = 0;

  for (const pay of pending) {
    const ok = await syncOneOfflinePayment(pay);
    if (ok) {
      okCount++;
    } else {
      failCount++;
      // keep it for next time
      offlinePayments.push(pay);
    }
  }
  if (offlinePayments.length) {
    saveOfflinePayments();
  }

  if (okCount && typeof showSnack === 'function') {
    showSnack(`Synced ${okCount} offline payment${okCount > 1 ? 's' : ''}.`, false, 2500);
  }
  if (failCount && typeof showSnack === 'function') {
    showSnack(`Could not sync ${failCount} offline payment${failCount > 1 ? 's' : ''} (will retry).`, true, 2500);
  }

  // 🔄 Clear hydration cache so cart_status is re-pulled and badges update
  if (typeof hydratedCustomers !== 'undefined' && hydratedCustomers && hydratedCustomers.clear) {
    hydratedCustomers.clear();
  }

  // Refresh live data so reports & badges reflect new payments
  fetchQueueData();
  fetchServedData();
  hydrateQuickSaleFromServer();
}





function enqueueOfflineJob(job) {
  job = job || {};
  job.id        = job.id        || ('job-' + Date.now() + '-' + Math.random().toString(36).slice(2));
  job.createdAt = job.createdAt || Date.now();
  offlineJobs.push(job);
  saveOfflineJobs();

  if (typeof showSnack === 'function') {
    showSnack('Saved offline – will sync when back online', false, 2000);
  }
}

/** Replay queued jobs when we’re back online */
function replayOfflineJobs() {
  if (window.APP_ONLINE === false || !offlineJobs.length) return;

  const jobs = offlineJobs.slice();
  offlineJobs = [];
  saveOfflineJobs();
  if (!jobs.length) return;

  function runNext(i) {
    if (i >= jobs.length) {
      if (typeof showSnack === 'function') {
        showSnack('Offline actions synced', false, 1800);
      }
      // queue/served may have changed
      fetchQueueData();
      fetchServedData();
      return;
    }
    const j = jobs[i];
    $.ajax({
      url:  j.url,
      type: j.method || 'POST',
      data: j.data || {}
    }).always(function () {
      runNext(i + 1);
    });
  }

  runNext(0);
}

    function trySyncOfflineCheckins() {
      // Turn this into a jQuery-style promise so we can chain payments AFTER check-ins
      const d = $.Deferred();
    
      if (window.APP_ONLINE === false || !offlineCheckins.length) {
        d.resolve();
        return d.promise();
      }
    
      const pending = offlineCheckins.slice();
      offlineCheckins = [];
      saveOfflineCheckins();
    
      if (!pending.length) {
        renderOfflineCheckins();
        renderOfflineServedInPanel();
        d.resolve();
        return d.promise();
      }
    
      function syncOne(idx) {
        if (idx >= pending.length) {
          // Finished pass – redraw and refresh live lists
          saveOfflineCheckins();
          renderOfflineCheckins();
          fetchQueueData();
          fetchServedData();
          if (typeof showSnack === 'function') {
            showSnack('Offline check-ins synced', false, 1800);
          }
          d.resolve();
          return;
        }

        const entry    = pending[idx];
        const rawState = entry.state || (entry.servedAt ? 'served' : 'queued');
        const isServed = (rawState === 'served');
    
        const name  = entry.name  || 'Customer';
        const phone = entry.phone;
    
        function keepAndNext(keep) {
          if (keep) {
            offlineCheckins.push(entry);
            saveOfflineCheckins();
          }
          syncOne(idx + 1);
        }
    
        // 1) look for existing client by phone (and name)
        $.ajax({
          url: 'lookup_client.php',
          type: 'POST',
          dataType: 'json',
          data: { phone: phone }
        })
        .done(function (list) {
          let existingId = null;
    
          if (Array.isArray(list) && list.length) {
            const offlineName = (entry.name || '').trim().toLowerCase();
            if (offlineName) {
              const sameName = list.filter(cl => {
                const rowName = String(cl.name || cl.firstName || '').trim().toLowerCase();
                return rowName === offlineName;
              });
              if (sameName.length) {
                const chosen = sameName[0];
                existingId = Number(chosen.id || chosen.customer_id || 0) || null;
              }
            } else {
              const first = list[0];
              existingId = Number(first.id || first.customer_id || 0) || null;
            }
          }
    
          // 2) ensure a real customer row exists (add_client.php returns customer_id)
          const addPayload = {
            name:         name,
            phone:        phone,
            queue_status: 'in-queue'
          };
          if (existingId) addPayload.customer_id = existingId;
    
          $.ajax({
            url: 'add_client.php',
            type: 'POST',
            dataType: 'json',
            data: addPayload
          })
          .done(function (resp2) {
            const cid = Number(resp2.customer_id || existingId || 0);
            if (!cid) {
              keepAndNext(true);
              return;
            }
            
            // 🔗 Remember mapping tempId → real customer_id so payments can attach later
            rememberOfflineCustomerMapping(entry.tempId, cid, businessId);
            
            // If this was only an offline check-in (never served), stop here
            if (!isServed) {
              keepAndNext(false);
              return;
            }

    
            const staffId = entry.staffId || 0;
    
            // 3a) best-effort staff attribution (queued or live)
            const assignStaff = staffId
              ? sendOrQueueAjax({
                  url:  window.location.pathname + '?action=assign_staff',
                  data: { customer_id: cid, staff_id: staffId },
                  description: 'Assign staff (offline sync) for ' + name
                })
              : $.Deferred().resolve().promise();
    
            assignStaff.always(function () {
              // 3b) run reminder logic (best-effort)
              $.get('reminder_processing.php', {
                customer_id:   cid,
                staff_id:      staffId || 0,
                user_queue_id: businessId
              }).always(function () {
                // 3c) mark as served (queued or queued for later)
                sendOrQueueAjax({
                  url:  'update_queue_status_pos.php',
                  data: {
                    id:               cid,
                    queue_status:     'served',
                    increment_visits: true
                  },
                  description: 'Offline served sync for ' + (entry.name || ('#' + cid)),
                  onSuccess: function () {
                    // If this client was also finished offline, replay finish_service
                    if (entry.finished) {
                      sendOrQueueAjax({
                        url:  window.location.pathname + '?action=finish_service',
                        data: { customer_id: cid },
                        description: 'Offline finish sync for ' + (entry.name || ('#' + cid)),
                        onError: function () {
                          if (typeof showSnack === 'function') {
                            showSnack(
                              'Could not sync finished service for "' +
                                (entry.name || ('#' + cid)) +
                                '".',
                              true,
                              2500
                            );
                          }
                        }
                      }).always(function () {
                        syncOne(idx + 1);
                      });
                    } else {
                      syncOne(idx + 1);
                    }
                  },
                  onError: function () {
                    // If we were actually online and it failed, keep entry to retry
                    offlineCheckins.push(entry);
                    saveOfflineCheckins();
                    if (typeof showSnack === 'function') {
                      showSnack(
                        'Could not sync served client "' +
                          (entry.name || ('#' + cid)) +
                          '" – will retry later.',
                        true,
                        2500
                      );
                    }
                    syncOne(idx + 1);
                  }
                });
              });
            });
          })
          .fail(function () {
            // add_client failed → keep entry for another attempt
            keepAndNext(true);
          });
        })
        .fail(function () {
          // lookup failed → keep entry
          keepAndNext(true);
        });
      }
    
      syncOne(0);
      return d.promise();
    }




/**
 * For simple POSTs that can be queued while offline
 * opts: { url, data, description, onSuccess, onError }
 */
function sendOrQueueAjax(opts) {
  const online = (window.APP_ONLINE !== false);

  if (online) {
    const jq = $.ajax({
      url:  opts.url,
      type: 'POST',
      data: opts.data || {}
    });

    if (typeof opts.onSuccess === 'function') jq.done(opts.onSuccess);
    if (typeof opts.onError === 'function')   jq.fail(opts.onError);
    return jq;
  } else {
    enqueueOfflineJob({
      url:  opts.url,
      method: 'POST',
      data: opts.data || {},
      description: opts.description || null
    });

    // Optimistic: pretend success so UI can continue
    if (typeof opts.onSuccess === 'function') {
      setTimeout(function () { opts.onSuccess({ queued: true }); }, 0);
    }

    return $.Deferred().resolve({ queued: true }).promise();
  }
}


/* ==== TIMER CORE — persists across reloads (drop-in) ==== */

// Live timer anchor maps
const waitStartMsMap = Object.create(null); // cid -> ms joined queue (local)
const serveEndMsMap  = Object.create(null); // cid -> ms finished service (local)

// Persisted anchors (per business)
const TIME_ANCHORS_KEY = `lpz_timeAnchors_${businessId}`;
let TIME_ANCHORS = {};
try { TIME_ANCHORS = JSON.parse(localStorage.getItem(TIME_ANCHORS_KEY) || '{}') || {}; } catch(_) { TIME_ANCHORS = {}; }
function saveTimeAnchors(){ try { localStorage.setItem(TIME_ANCHORS_KEY, JSON.stringify(TIME_ANCHORS)); } catch(_){} }
function getAnchor(cid){ return TIME_ANCHORS[cid] || {}; }
function setWaitMs(cid, ms){ const a = getAnchor(cid); a.waitMs = ms; TIME_ANCHORS[cid] = a; saveTimeAnchors(); }
function setEndMs (cid, ms){ const a = getAnchor(cid); a.endMs  = ms; TIME_ANCHORS[cid] = a; saveTimeAnchors(); }
function clearAnchor(cid){ if (TIME_ANCHORS[cid]) { delete TIME_ANCHORS[cid]; saveTimeAnchors(); } }

// Rehydrate persisted anchors BEFORE anything renders
for (const [k, a] of Object.entries(TIME_ANCHORS)) {
  const cid = Number(k);
  if (Number.isFinite(a?.waitMs)) waitStartMsMap[cid] = a.waitMs;
  if (Number.isFinite(a?.endMs))  serveEndMsMap [cid] = a.endMs;
}

/* ============================
   FAMILY GROUPING (DB-backed)
   - Membership is stored in DB (customers.family_key/family_label)
   - Colours are per-day, per-business, purely cosmetic, auto-assigned
============================ */

// ---- Per-day colour book (family_key -> colour) ----
function sydDateKey() {
  const d = new Date();
  const fmt = new Intl.DateTimeFormat('en-CA', {year:'numeric', month:'2-digit', day:'2-digit', timeZone:'Australia/Sydney'});
  return fmt.format(d); // e.g. 2025-11-07
}

const FAMILY_COLORS = ['#FDE68A','#BFDBFE','#FCA5A5','#A7F3D0','#DDD6FE','#FBCFE8','#FDBA74','#A5F3FC','#FECACA','#C7F9CC'];
const COLOR_BOOK_KEY = `lpz_familyColors_${businessId}_${sydDateKey()}`;
let COLOR_BOOK = {};
try { COLOR_BOOK = JSON.parse(localStorage.getItem(COLOR_BOOK_KEY) || '{}') || {}; } catch(_) { COLOR_BOOK = {}; }
function saveColorBook(){ try { localStorage.setItem(COLOR_BOOK_KEY, JSON.stringify(COLOR_BOOK)); } catch(_){} }
function nextUnusedColor(){
  const used = new Set(Object.values(COLOR_BOOK));
  for (const c of FAMILY_COLORS) if (!used.has(c)) return c;
  // If all used, rotate through (won't be perfect but keeps going)
  return FAMILY_COLORS[(Object.keys(COLOR_BOOK).length) % FAMILY_COLORS.length];
}
function colorForKey(key){
  if (!key) return null;
  if (!COLOR_BOOK[key]) { COLOR_BOOK[key] = nextUnusedColor(); saveColorBook(); }
  return COLOR_BOOK[key];
}

// ---- Live page state: FAMILIES from the server (key -> {label, members[]}) ----
let FAMILIES = {};              // all visible family memberships (for logic like selection)
let PAINTABLE_KEYS = new Set(); // only families with >=2 visible members (for painting)


function familyExistsForId(cid){
  const idStr = String(cid);
  for (const g of Object.values(FAMILIES)) {
    if ((g.members||[]).some(m => String(m) === idStr)) return true;
  }
  return false;
}
function familyFindByMember(cid){
  const idStr = String(cid);
  for (const [key,g] of Object.entries(FAMILIES)) {
    if ((g.members||[]).some(m => String(m) === idStr)) return { gid:key, group:g };
  }
  return null;
}

function collectVisibleCids(){
  const ids = new Set();
  $('.panel[aria-label="Checked-in clients"] .queue-item, .panel[aria-label="Served clients"] .queue-item')
    .each((_, el) => {
      const cid = Number($(el).attr('data-cid'));
      if (cid) ids.add(cid);
    });
  return Array.from(ids);
}

// Pull membership for visible customers and repaint ribbons
function refreshFamilyState(){
  const ids = collectVisibleCids();
  if (!ids.length) { FAMILIES = {}; repaintFamiliesDebounced(); return; }

  $.getJSON(window.location.pathname + '?action=family_list_for', { ids: ids.join(',') })
    .done(resp => {
        FAMILIES = {};
        PAINTABLE_KEYS = new Set();
        
        const map = (resp && resp.ok && resp.map) ? resp.map : {};
        const temp = {}; // key -> { label, members: [] }
        
        // build groups by key
        for (const [cidStr, info] of Object.entries(map)) {
          const key   = (info && info.key)   ? String(info.key)   : '';
          const label = (info && info.label) ? String(info.label) : '';
          if (!key) continue;
          if (!temp[key]) temp[key] = { label, members: [] };
          temp[key].members.push(Number(cidStr));
        }
        
        // Always paint: allocate colour for every family we see today
        for (const [k, g] of Object.entries(temp)) {
          FAMILIES[k] = g;
          if (!COLOR_BOOK[k]) colorForKey(k); // allocate a colour (per day) even for 1 visible member
          PAINTABLE_KEYS.add(k);              // not used to gate painting anymore
        }
        
        repaintFamiliesDebounced();

    })
    .fail(() => { /* leave previous paint; will retry on next tick */ });
}

// Cosmetic paint on cards
function applyFamilyStylesForRow($row){
  const cid = Number($row.attr('data-cid'));

  // Previous paint markers (cheap to compare)
  const beforeKey   = $row.attr('data-fam-key')   || '';
  const beforeLabel = $row.attr('data-fam-label') || '';
  const beforeHasFam= $row.hasClass('has-family');

  const hit = familyFindByMember(cid);
  const key   = hit ? hit.gid : '';
  const label = hit ? (hit.group?.label || '') : '';
  const color = key ? (colorForKey(key) || '#FDE68A') : '';

  // If nothing materially changed, do nothing (prevents flicker)
  if (beforeKey === key && beforeLabel === label && (!!beforeHasFam) === (!!key)) return;

  // Update markers
  $row.attr('data-fam-key', key).attr('data-fam-label', label);

  // No family now → clear once
  if (!key) {
    if (beforeHasFam) {
      $row.removeClass('has-family').css('--fam-color','');
      $row.find('.fam-chip').remove();
    }
    return;
  }

  // Paint/update
  $row.addClass('has-family').css('--fam-color', color);

  let $chip = $row.find('.fam-chip');
  if (!$chip.length) {
    $chip = $(`
      <div class="fam-chip" style="--fam-color:${color}">
        <i class="fas fa-users" aria-hidden="true"></i>
        <span class="lbl"></span>
        <button type="button" class="edit" title="Edit family"><i class="fas fa-edit"></i></button>
      </div>
    `);
    $chip.find('.edit').on('click', (e) => { e.stopPropagation(); openFamilyEditModal(key); });
    $row.prepend($chip);
  }
  // Only update what changed
  $chip.find('.lbl').text(label || 'Family');
  $chip.css('--fam-color', color);
}


function applyFamilyDecorations(){
  $('.panel[aria-label="Checked-in clients"] .queue-item, .panel[aria-label="Served clients"] .queue-item')
    .each((_, el) => applyFamilyStylesForRow($(el)));
}

// === Anti-flicker helpers (debounced repaint + state snapshot) ===
let __LAST_FAM_STATE = null;
let __famPaintTimer = null;

function stableStateSnapshot(){
  // snapshot only what affects paint: visible row -> { key, label }
  const snap = {};
  $('.panel[aria-label="Checked-in clients"] .queue-item, .panel[aria-label="Served clients"] .queue-item').each((_, el) => {
    const cid = Number($(el).attr('data-cid'));
    const hit = familyFindByMember(cid);
    snap[cid] = hit ? { key: hit.gid, label: (hit.group?.label||'') } : null;
  });
  return JSON.stringify(snap);
}

// Track last visible IDs so we only hit the server when the rows change
let __FAM_LAST_KEY = '';

function visibleIdsKey(){
  const ids = collectVisibleCids().sort((a,b)=>a-b);
  return ids.join(',');
}

function ensureFamilies(){
  const key = visibleIdsKey();
  if (key !== __FAM_LAST_KEY) {
    // Visible rows changed -> re-fetch membership from server
    __FAM_LAST_KEY = key;
    refreshFamilyState();
  } else {
    // Same rows -> just repaint ribbons if needed
    repaintFamiliesDebounced();
  }
}





// Build list of selectable (ungrouped) people for the modal
function collectUngroupedVisiblePeople(){
  const out = [];
  const $cards = $('.panel[aria-label="Checked-in clients"] .queue-item, .panel[aria-label="Served clients"] .queue-item');
  $cards.each((_, el) => {
    const $row = $(el);
    const cid = Number($row.attr('data-cid'));
    if (!cid || familyExistsForId(cid)) return;
    const name = ($row.find('.qi-name').text() || 'Customer').trim();
    const col  = $row.closest('.panel').attr('aria-label') || '';
    out.push({ id: cid, name, col });
  });
  // dedupe
  const map = new Map();
  out.forEach(p => map.set(p.id, p));
  return Array.from(map.values());
}
// escape helper
function esc(s){ return $('<div/>').text(String(s||'')).html(); }

/* Build list of visible people with names from DOM */
function buildVisiblePeopleMap(){
  const map = new Map();
  $('.panel[aria-label="Checked-in clients"] .queue-item, .panel[aria-label="Served clients"] .queue-item')
    .each((_, el) => {
      const $row = $(el);
      const cid = Number($row.attr('data-cid'));
      if (!cid) return;
      const nm = ($row.find('.qi-name').text() || 'Customer').trim();
      map.set(cid, nm);
    });
  return map;
}

/* CREATE tab renderer (re-uses your existing logic) */
function renderCreateFamilyTab(){
  const $list = $('#famPickList').empty();
  const candidates = collectUngroupedVisiblePeople(); // you already have this
  if (!candidates.length){
    $list.append('<div class="list-group-item text-muted">No ungrouped people in view.</div>');
  } else {
    candidates.forEach(p => {
      $list.append(`
        <label class="list-group-item d-flex align-items-center">
          <input class="mr-2 fam-choice" type="checkbox" value="${p.id}">
          <span class="badge badge-pill badge-info mr-2">${esc(p.col)}</span>
          <span>${esc(p.name)}</span>
        </label>
      `);
    });
  }
  $('#famNameInput').val('');
}

/* EDIT tab renderer (families that have members in view) */
function renderEditFamiliesTab(){
  const $host = $('#famEditInView').empty();
  const ids = collectVisibleCids(); // you already have this
  if (!ids.length){ $host.html('<div class="text-muted">No people in view.</div>'); return; }

  $.getJSON(window.location.pathname + '?action=family_list_for', { ids: ids.join(',') })
    .done(resp => {
      const map = (resp && resp.ok && resp.map) ? resp.map : {};
      const groups = {}; // key -> { label, members: [ids in view] }

      ids.forEach(id => {
        const info = map[id] || {};
        const key  = String(info.key || '');
        if (!key) return; // only real families
        if (!groups[key]) groups[key] = { label: String(info.label || ''), members: [] };
        groups[key].members.push(id);
      });

      const keys = Object.keys(groups);
      if (!keys.length){
        $host.html('<div class="text-muted">No families in view yet.</div>');
        return;
      }

      const nameMap = buildVisiblePeopleMap();

      keys.forEach((key, idx) => {
        const g = groups[key];
        const color = colorForKey(key) || '#FDE68A';
        const labelInputId = `famEditLabel_${idx}_${Date.now()}`;

        const $card = $(`
          <div class="card mb-2" data-key="${esc(key)}" style="box-shadow: inset 6px 0 0 0 ${color}">
            <div class="card-body">
              <div class="d-flex justify-content-between align-items-center">
                <div><strong>Family${g.label ? ' — ' + esc(g.label) : ''}</strong></div>
                <button type="button" class="btn btn-outline-secondary btn-sm full-edit">Full editor</button>
              </div>

              <div class="form-group mt-2">
                <label>Family name</label>
                <input id="${labelInputId}" class="form-control" value="${esc(g.label)}">
              </div>

              <div class="form-group">
                <label>Members (in view)</label>
                <div class="list-group members"></div>
                <small class="text-muted d-block mt-1">Only people currently visible are shown. Use <em>Full editor</em> to manage others.</small>
              </div>

              <div class="text-right">
                <button type="button" class="btn btn-primary btn-sm fam-save">Save</button>
              </div>
            </div>
          </div>
        `);

        const $list = $card.find('.members');
        g.members.forEach(id => {
          $list.append(`
            <label class="list-group-item d-flex align-items-center">
              <input type="checkbox" class="mr-2 fam-member" value="${id}" checked>
              <span>${esc(nameMap.get(id) || ('#'+id))}</span>
            </label>
          `);
        });

        // remember the "previous" visible membership set for diffing
        $card.data('prev', g.members.slice());

        // open full editor
        $card.find('.full-edit').on('click', () => openFamilyEditModal(key));

        // save in-view changes
        $card.find('.fam-save').on('click', function(){
          const prev = new Set(($card.data('prev')||[]).map(Number));
          const sel  = [];
          $card.find('.fam-member:checked').each(function(){ sel.push(Number(this.value)); });
          const selSet = new Set(sel);

          const add = sel.filter(id => !prev.has(id));
          const rem = Array.from(prev).filter(id => !selSet.has(id));
          const label = $card.find('#'+labelInputId).val().trim();

          $.ajax({
            url: window.location.pathname + '?action=family_update_members',
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({ family_key: key, add_ids: add, remove_ids: rem, label })
          })
          .done(r => { showSnack('Saved'); renderEditFamiliesTab(); refreshFamilyState(); })
          .fail(() => { showSnack('Save failed', true, 2000); });
        });

        $host.append($card);
      });
    })
    .fail(() => $host.html('<div class="text-danger">Failed to load families.</div>'));
}

// Modal control
function openFamilyModal(defaultTab){
  if (window.APP_ONLINE === false) {
    if (typeof showSnack === 'function') {
      showSnack('Family groups are only available when LineUpz is online.', true, 2200);
    } else {
      alert('Family groups are only available when LineUpz is online.');
    }
    return;
  }
  renderCreateFamilyTab();
  // defer the edit tab one tick so the page lists are present
  setTimeout(renderEditFamiliesTab, 0);

  if (defaultTab === 'edit') {
    $('#famTabEdit').tab('show');
  } else {
    $('#famTabCreate').tab('show');
  }

  $('#famTabs')
    .off('shown.bs.tab.fam')
    .on('shown.bs.tab.fam', 'a[data-toggle="tab"]', function(e){
      const href = $(e.target).attr('href');
      $('#famCreateBtn').toggle(href === '#famPaneCreate');
      if (href === '#famPaneEdit') setTimeout(renderEditFamiliesTab, 0); // refresh when switching
    });

  const activeHref = $('#famTabs .nav-link.active').attr('href') || '#famPaneCreate';
  $('#famCreateBtn').toggle(activeHref === '#famPaneCreate');

  $('#familyGroupModal').modal('show');
}




function createFamilyFromModal(){
  const ids = [];
  $('#famPickList .fam-choice:checked').each(function(){ ids.push(Number(this.value)); });
  if (ids.length < 2){ alert('Select at least two people to form a family.'); return; }
  const label = ($('#famNameInput').val() || '').trim();

  $.ajax({
    url: window.location.pathname + '?action=family_assign',
    type: 'POST',
    contentType: 'application/json',
    data: JSON.stringify({ customer_ids: ids, label })
  })
  .done(resp => {
    if (resp && resp.ok && resp.family_key) {
      // ensure colour exists for this key (auto-pick unused)
      colorForKey(resp.family_key);
      showSnack('Family created');
    } else {
      showSnack('Could not create family', true, 2000);
    }
  })
  .fail(()=> showSnack('Could not create family', true, 2000))
  .always(() => {
    $('#familyGroupModal').modal('hide');
    refreshFamilyState();
  });
}

function openFamilyEditModal(famKey){
  if (window.APP_ONLINE === false) {
    if (typeof showSnack === 'function') {
      showSnack('Editing families is only available when LineUpz is online.', true, 2200);
    } else {
      alert('Editing families is only available when LineUpz is online.');
    }
    return;
  }

  // prep UI
  $('#famEditList').html('<div class="list-group-item text-muted">Loading…</div>');
  $('#famEditName').val('');
  $('#familyEditModal').data({ famKey, famPrev: [] }).modal('show');
  // Raise Family Edit modal above the Profile modal
    $('#familyEditModal')
      .off('shown.bs.modal.stack hidden.bs.modal.stack')
      .on('shown.bs.modal.stack', function(){
        // modal above
        $(this).css('z-index', 2100);
        // top backdrop just under it
        $('.modal-backdrop').last().css('z-index', 2050);
      })
      .on('hidden.bs.modal.stack', function(){
        // clean up
        $(this).css('z-index', '');
        $('.modal-backdrop').last().css('z-index', '');
      });


  // fetch full family from DB
  $.getJSON(window.location.pathname + '?action=family_members', { family_key: famKey })
    .done(resp => {
      const serverMembers = (resp && resp.members) ? resp.members : [];
      const prevAll = serverMembers.map(m => Number(m.id));
      $('#familyEditModal').data('famPrev', prevAll);

      const serverLabel = (resp && resp.label) ? resp.label : '';
      const fallbackLbl = (FAMILIES[famKey] && FAMILIES[famKey].label) || '';
      $('#famEditName').val(serverLabel || fallbackLbl);

      // build list: all current members (checked) + visible non-members (unchecked)
      const visibleIds = new Set(collectVisibleCids());
      const inViewMap = new Map();
      visibleIds.forEach(id => {
        const $row = $(`.queue-item[data-cid="${id}"]`);
        const nm = $row.find('.qi-name').text().trim() || 'Customer';
        inViewMap.set(id, nm);
      });

      const list = [];

      // all current members (may be not in view)
      serverMembers.forEach(m => {
        const id = Number(m.id);
        const name = (m.firstName || 'Customer');
        const inView = visibleIds.has(id);
        list.push({ id, name, checked:true, inView });
        if (inView) visibleIds.delete(id);
      });

      // visible non-members → allow adding
      inViewMap.forEach((nm, id) => {
        if (!prevAll.includes(id)) list.push({ id, name:nm, checked:false, inView:true });
      });

      // render
      const $list = $('#famEditList').empty();
      if (!list.length) {
        $list.append('<div class="list-group-item text-muted">No people to edit here.</div>');
      } else {
        list.sort((a,b) => (a.name||'').localeCompare(b.name||''));
        list.forEach(p => {
          const badge = p.inView ? '' : '<span class="badge badge-light ml-2">not in view</span>';
          $list.append(`
            <label class="list-group-item d-flex align-items-center justify-content-between">
              <div class="d-flex align-items-center">
                <input class="mr-2 fam-edit-choice" type="checkbox" value="${p.id}" ${p.checked?'checked':''}>
                <span>${$('<div>').text(p.name).html()}</span>
              </div>
              ${badge}
            </label>
          `);
        });
      }
    })
    .fail(() => {
      $('#famEditList').html('<div class="list-group-item text-danger">Could not load family.</div>');
    });
}


$('#famEditSaveBtn').off('click').on('click', function(){
  const famKey = $('#familyEditModal').data('famKey');
  const prevArr = $('#familyEditModal').data('famPrev') || [];
  const prevAll = new Set(prevArr.map(Number));

  const sel = [];
  $('#famEditList .fam-edit-choice:checked').each(function(){ sel.push(Number(this.value)); });
  const selSet = new Set(sel);

  const addIds    = sel.filter(id => !prevAll.has(id));
  const removeIds = Array.from(prevAll).filter(id => !selSet.has(id));
  const label     = ($('#famEditName').val() || '').trim();

  $.ajax({
    url: window.location.pathname + '?action=family_update_members',
    type: 'POST',
    contentType: 'application/json',
    data: JSON.stringify({ family_key: famKey, add_ids: addIds, remove_ids: removeIds, label })
  })
  .done(resp => {
    if (resp && resp.ok){ showSnack('Family updated'); }
    else                { showSnack('Update failed', true, 2000); }
  })
  .fail(() => showSnack('Update failed', true, 2000))
  .always(() => { $('#familyEditModal').modal('hide'); refreshFamilyState(); });
});



// Wire Up
$(function(){
  $('#familyGroupBtn').off('click.fam').on('click.fam', () => {
      if (window.APP_ONLINE === false) {
        if (typeof showSnack === 'function') {
          showSnack('Family groups are only available when LineUpz is online.', true, 2200);
        } else {
          alert('Family groups are only available when LineUpz is online.');
        }
        return;
      }
      openFamilyModal();
    });

  $('#famCreateBtn').off('click.fam').on('click.fam', () => createFamilyFromModal());


  // First paint after both columns are drawn
  setTimeout(() => refreshFamilyState(), 80);
});



// Helpers used by the live tick
function parseLocalMs(ts){
  if (!ts) return NaN;
  const s = String(ts).replace(' ', 'T');        // parse "YYYY-MM-DD HH:MM:SS" as local
  const t = Date.parse(s);
  return Number.isFinite(t) ? t : NaN;
}
function fmtDur(secs){
  secs = Math.max(0, Math.floor(secs));
  const h = Math.floor(secs/3600), m = Math.floor((secs%3600)/60), s = secs%60;
  return h ? `${h}h ${String(m).padStart(2,'0')}m ${String(s).padStart(2,'0')}s`
           : `${m}m ${String(s).padStart(2,'0')}s`;
}

let __liveTickHandle = null;
function updateLiveTimers(){
  const now = Date.now();

  // Waiting timers (checked-in)
  document.querySelectorAll('.js-wait-timer').forEach(el => {
    const start = Number(el.getAttribute('data-start-ms')) || 0;
    if (start) el.textContent = fmtDur((now - start) / 1000);
  });

  // Serving timers (served)
  document.querySelectorAll('.js-serve-timer').forEach(el => {
    const start = Number(el.getAttribute('data-start-ms')) || 0;
    if (!start) return;
    const end = Number(el.getAttribute('data-end-ms')) || 0;
    const until = (end && end > start) ? end : now;
    el.textContent = fmtDur((until - start) / 1000);
  });
}
function startLiveTimers(){
  if (__liveTickHandle) return;
  updateLiveTimers();
  __liveTickHandle = setInterval(updateLiveTimers, 1000);
}


// --- freeze re-render briefly so our badge animation can finish
let uiFreezeUntil = 0;
function freezeUI(ms = 1400){ uiFreezeUntil = Date.now() + ms; }
function isUIFrozen(){ return Date.now() < uiFreezeUntil; }


function setBadge($nameEl, status) {
  const $row  = $nameEl.closest('.queue-item');
  const $host = $row.find('.ci-badges');           // ⬅️ new preferred host

  if ($host.length) {
    let $b = $host.find('.cart-badge');
    if (!status) { if ($b.length) $b.remove(); return; }
    const cls  = (status === 'paid') ? 'badge-success' : 'badge-info';
    const text = (status === 'paid') ? 'Paid' : 'In Cart';
    if ($b.length) {
      if ($b.data('status') === status) return;
      $b.removeClass('badge-success badge-info').addClass(cls).text(text).data('status', status);
    } else {
      $('<span class="badge cart-badge ml-2">').addClass(cls).text(text).data('status', status).appendTo($host);
    }
    return;
  }

  // fallback (older rows)
  let $b = $nameEl.siblings('.cart-badge');
  if (!status) { if ($b.length) $b.remove(); return; }
  const cls  = (status === 'paid') ? 'badge-success' : 'badge-info';
  const text = (status === 'paid') ? 'Paid' : 'In Cart';
  if ($b.length) {
    if ($b.data('status') === status) return;
    $b.removeClass('badge-success badge-info').addClass(cls).text(text).data('status', status);
  } else {
    $('<span class="badge cart-badge ml-2">').addClass(cls).text(text).data('status', status).insertAfter($nameEl);
  }
}

function applyCartButtonState($row, status) {
  const $btn = $row.find('.btn-add-cart');
  if (!$btn.length) return;
  if (status === 'pending' || status === 'paid') {
    $btn.prop('disabled', true).addClass('disabled btn-secondary').removeClass('btn-outline-primary');
  } else {
    $btn.prop('disabled', false).removeClass('disabled btn-secondary').addClass('btn-outline-primary');
  }
}
function updateOfflineServedRowForTempId(tempId, status) {
  const $row = $(`.offline-served-item[data-temp-id="${tempId}"]`);
  if (!$row.length) return;

  const $nameEl = $row.find('.qi-name').first();  // same as online
  setBadge($nameEl, status);
  applyCartButtonState($row, status);             // disables/enables .btn-add-cart
}

function nameFrom(c) {
  const first = c.firstName || c.first_name || '';
  const last  = c.lastName  || c.last_name  || '';
  return (first + ' ' + last).trim() || (c.firstName || c.first_name || 'Customer');
}
function refreshWaitEta(){
  // Uses the hidden input you already have on the page
  const qid = Number($('#userQueueId').val() || 0);
  if (!qid) { $('#waitEta').text('Live'); return; }

  // If we’re offline, don’t spam the server – just show "Offline"
  if (window.APP_ONLINE === false) {
    $('#waitEta').text('Offline');
    return;
  }

  $.getJSON('calculate_queue_wait_time_test.php', { queue_id: qid })
    .done(resp => {
      if (resp && resp.waitTime) {
        const nice = String(resp.waitTime)
          .replace(' minutes', ' min')
          .replace('-', '–');
        $('#waitEta').text(nice);
      } else {
        $('#waitEta').text('Live');
      }
    })
    .fail(() => { $('#waitEta').text('Live'); });
}


function centsToAUD(cents) {
  const v = (Number(cents) || 0) / 100;
  return v.toLocaleString('en-AU', { style: 'currency', currency: 'AUD' });
}
function safeText(v) { return (v ?? '').toString(); }
function formatPhoneAU(phone) { if (!phone) return ''; let s = (phone+'').trim(); s = s.replace(/^\+61\s*0?/, '0'); return s; }

// ===== Upsell editor (POS add-ons per customer) =====
let upsellCustomerId = null;

function openUpsellEditorForRow($row) {
  if (window.APP_ONLINE === false) {
    if (typeof showSnack === 'function') {
      showSnack('Add-ons can only be edited when LineUpz is online.', true, 2200);
    } else {
      alert('Add-ons can only be edited when LineUpz is online.');
    }
    return;
  }

  const cid = Number(
    $row.attr('data-cid') ||
    $row.find('[data-id]').first().attr('data-id') ||
    0
  );
  const qid = Number($row.attr('data-queue-id') || businessId || 0);

  if (!cid || !qid) return;

  upsellCustomerId = cid;

  const name =
    ($row.find('.qi-name').text() ||
     $row.find('.font-weight-bold').first().text() ||
     'Customer').trim();

  $('#upsellModalCustomer').html(
    '<strong>Customer:</strong> ' + h(name)
  );
  $('#upsellOptions').html('<div class="text-muted">Loading add-ons…</div>');
  $('#upsellModal').modal('show');

  // Load: (1) upsell services, (2) current selection for this customer
  $.when(
    $.getJSON(window.location.pathname + '?action=upsell_options'),
    $.getJSON(window.location.pathname + '?action=upsell_get', { customer_id: cid })
  ).done(function (optResp, curResp) {
    const opt = optResp[0] && optResp[0].ok ? (optResp[0].services || []) : [];
    const cur = curResp[0] && curResp[0].ok ? (curResp[0].service_ids || []) : [];
    const selected = new Set(cur.map(Number));

    const $list = $('<div class="list-group"></div>');
    if (!opt.length) {
      $list.append(
        '<div class="list-group-item text-muted">' +
        'No add-on services are configured. ' +
        'Mark services as “Upsell” in Services Manager to show them here.' +
        '</div>'
      );
    } else {
      opt.forEach(function (s) {
        const sid = Number(s.id);
        const checked = selected.has(sid) ? 'checked' : '';
        $list.append(`
          <label class="list-group-item d-flex align-items-center justify-content-between">
            <div>
              <input type="checkbox"
                     class="mr-2 upsell-opt"
                     value="${sid}"
                     ${checked}>
              <span>${h(s.item_name)}</span>
            </div>
            <span class="small text-muted">
              ${centsToAUD(s.variation_price_amount || 0)}
            </span>
          </label>
        `);
      });
    }

    $('#upsellOptions').empty().append($list);
  }).fail(function () {
    $('#upsellOptions').html('<div class="text-danger">Failed to load add-ons.</div>');
  });
}

function refreshUpsellBadges($row, c) {
  if (!$row || !c) return;

  // Remove any previous upsell row for this card
  $row.find('.appointment-info.upsell-row').remove();

  let ups = Array.isArray(c.kiosk_upsells) ? c.kiosk_upsells.slice() : [];
  if (!ups.length && c.kiosk_upsell_summary) {
    ups = [{ item_name: c.kiosk_upsell_summary }];
  }
  if (!ups.length) return;

  const $upsRow = $('<div class="appointment-info upsell-row" />');
  $upsRow.append('<span class="muted small mr-1">Add-ons:</span>');

  ups.forEach(function (u) {
    const name = (u && u.item_name) ? u.item_name : '';
    if (!name) return;
    $upsRow.append(
      $('<span class="badge badge-pill badge-info mr-1"></span>').text(name)
    );
  });

  // Insert under the phone line if we can find it, otherwise append at the end
  const $phoneRow = $row.find('.appointment-info').not('.upsell-row').first();
  if ($phoneRow.length) {
    $upsRow.insertAfter($phoneRow);
  } else {
    $row.append($upsRow);
  }
}

/* ========== Badge refresh (uses row data-queue-id) ========== */
function updateCartBadge(customer, $nameEl, $row, context) {
  const cid = Number(customer.id);
  const qid = Number($row.attr('data-queue-id') || 0);
  if (!cid || !qid) return;

  if (cid in cartStatusCache) {
    const st = cartStatusCache[cid];
    setBadge($nameEl, st);
    applyCartButtonState($row, st);
  }

  if (cartStatusInflight.has(cid)) return;
  cartStatusInflight.add(cid);
    $.getJSON(window.location.pathname + '?action=cart_status', { customer_id: cid, queue_id: qid })
      .done(resp => {
        const srvStatus = resp?.cart?.status ?? null;          // 'pending' or null (server never returns 'paid' here)
        const allowNew  = !!resp?.allow_new;                   // false during 2h cooldown
    
        // Derive the UI status:
        // - Active cart -> 'pending'
        // - No active cart but cooldown -> 'paid'
        // - Otherwise -> null
        let effective = srvStatus;                             // 'pending' | null
        if (!srvStatus && allowNew === false) effective = 'paid';
    
        if (cartStatusCache[cid] !== effective) {
          cartStatusCache[cid] = effective; persistStatus();
          setBadge($nameEl, effective);
          applyCartButtonState($row, effective);
        }
      })

    .always(() => cartStatusInflight.delete(cid));
}
// ===== Finish Service local lock cache =====
const FINISH_LOCK_KEY = 'finishLocks_v1';
let finishLocks = {};
try { finishLocks = JSON.parse(localStorage.getItem(FINISH_LOCK_KEY) || '{}') || {}; } catch(e){ finishLocks = {}; }
function persistFinishLocks() { try { localStorage.setItem(FINISH_LOCK_KEY, JSON.stringify(finishLocks)); } catch(e){} }

/* ==== Callback send counts (per day, per business, per customer) ==== */
const CB_COUNT_KEY = `lpz_cbCounts_${businessId}_${sydDateKey()}`;
let CB_COUNTS = {};
try { CB_COUNTS = JSON.parse(localStorage.getItem(CB_COUNT_KEY) || '{}') || {}; } catch(_){ CB_COUNTS = {}; }
function cbSave(){ try { localStorage.setItem(CB_COUNT_KEY, JSON.stringify(CB_COUNTS)); } catch(_){} }
function cbGet(cid){ return Number(CB_COUNTS[cid] || 0); }
function cbBump(cid){ const n = cbGet(cid) + 1; CB_COUNTS[cid] = n; cbSave(); return n; }
function cbRenderBadge($btn, n){
  let $b = $btn.find('.callback-count');
  if (!n || n <= 0){ if ($b.length) $b.remove(); return; }
  if (!$b.length){ $b = $('<span class="callback-count"></span>').appendTo($btn); }
  $b.text(n);
}



/* ============================
   LEFT: Checked-in
============================ */
function buildCheckedInItem(c) {
  const $row = $('<div class="queue-item d-flex flex-column" />');
  if (c.service_item_name) $row.addClass('service-set');

  const qid = Number(c.queue_id || c.q_id || c.queueId || businessId || 0);
  $row.attr('data-queue-id', qid);
  $row.attr('data-cid', c.id);


  // --- TOP ROW: action buttons (centered like served cards) ---
  const $actions = $('<div class="qi-subrow" />');

    const $cb = $('<button class="btn btn-slim btn-compact callback-btn btn-grow" title="Send callback"><i class="fas fa-bell text-white"></i></button>')
      .attr('data-id', c.id)
      .on('click', function () {
        const $self = $(this);
    
        // brief lockout so we don't spam multiple posts on the same tap
        if ($self.data('busy')) return;
        $self.data('busy', true).prop('disabled', true);
    
        // keep your UI pause so the mini toast animates cleanly
        freezeUI(800);
    
        const jq = sendOrQueueAjax({
          url: 'call_back.php',
          data: { id: c.id, user_queue_id: businessId },
          description: 'Callback ' + (nameFrom(c) || c.id),
          onSuccess: function () {
            showAlertBadge($self, 'Alert sent', false);
            const n = cbBump(c.id);           // bump per-customer count (per day)
            cbRenderBadge($self, n);          // paint/update the count chip
          },
          onError: function () {
            showAlertBadge($self, 'Failed', true);
          }
        });
        
        jq.always(function () {
          // re-enable after a short cooldown
          setTimeout(function () {
            $self.data('busy', false).prop('disabled', false);
          }, 700);
        });

      });
    
    // paint any existing count on initial render
    cbRenderBadge($cb, cbGet(c.id));
    
        
          

    const $del = $('<button class="btn btn-danger btn-slim btn-compact btn-grow">DELETE</button>')
      .attr('data-id', c.id)
      .on('click', function () {
        const $btn = $(this).prop('disabled', true);
        const qid  = Number($row.attr('data-queue-id') || 0);
    
        // Local UI clean-up (works online + offline)
        const removeFromUI = () => {
          // remove the card
          $row.remove();
          // drop live wait timer anchors
          delete waitStartMsMap[c.id];
          clearAnchor(c.id);
    
          // if no checked-in cards left, show empty state
          const $wrap = $('#queueList');
          if (!$wrap.children('.queue-item').length) {
            $wrap.html('<div class="text-center text-muted py-3 checkedin-empty">No clients checked in.</div>');
          }
    
          // also nuke any local cart lines for this customer (offline safety)
          cart.items = cart.items.filter(it => it.customerId !== c.id);
          renderCart();
          cartStatusCache[c.id] = null;
          persistStatus();
        };
    
        // 1) pick staff (no auto-assign – uses cached staff offline)
        openStaffChooser(
          'Deleting: ' + $('<div/>').text(nameFrom(c)).html(),
          function onPicked(staff) {
            // 2) last confirmation with staff name
            if (!confirm(`Delete this customer as ${staff.name}? This cannot be undone.`)) {
              $btn.prop('disabled', false);
              return;
            }
    
            // 3) Optimistic local removal – works ONLINE + OFFLINE
            removeFromUI();
    
            // 4) Queue status → filed (online now OR queued for when back online)
            sendOrQueueAjax({
              url: 'update_queue_status_pos.php',
              data: {
                id: c.id,
                queue_status: 'filed',
                increment_visits: false
              },
              description: 'Delete customer ' + (nameFrom(c) || c.id),
              onError: function () {
                // Only nag if we were actually online when it failed
                if (window.APP_ONLINE !== false) {
                  showSnack('Failed to update queue status for deleted client.', true, 2500);
                }
              }
            });
    
            // 5) Best-effort extras (only when actually online)
            if (window.APP_ONLINE !== false) {
              // record who deleted
              $.ajax({
                url: window.location.pathname + '?action=delete_customer_staff',
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({ customer_id: c.id, staff_id: staff.id })
              });
    
              // clear any server-side open cart
              $.ajax({
                url: window.location.pathname + '?action=cart_clear',
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({ customer_id: c.id, queue_id: qid })
              });
            }
    
            // button is on a removed row now anyway, no need to re-enable
          },
          function onCancel() {
            $btn.prop('disabled', false);
          }
        );
      });


    
  const $serve = $('<button class="btn btn-success btn-slim btn-compact btn-grow">SERVE</button>')
    .attr('data-id', c.id)
    .on('click', function() {
      const $btn = $(this).prop('disabled', true);

      openStaffPickerForCustomer(
        { id: c.id, name: nameFrom(c) },
        function onPicked(staff) {
          // Best-effort reminder logic (unchanged)
          $.get('reminder_processing.php', {
              customer_id:   c.id,
              staff_id:      staff.id,
              user_queue_id: businessId
            })
            .always(function () {
              // Queue status -> served (online or queued for later)
              sendOrQueueAjax({
                url:  'update_queue_status_pos.php',
                data: {
                  id:               c.id,
                  queue_status:     'served',
                  increment_visits: true
                },
                description: 'Serve ' + (nameFrom(c) || c.id),

                onSuccess: function () {
                  // capture family metadata from the checked-in card
                  const famKey   = $row.attr('data-fam-key')   || '';
                  const famLabel = $row.attr('data-fam-label') || '';
                  const famMeta  = famKey ? { key: famKey, label: famLabel } : null;

                  // remove from Checked-in + clear wait timer anchors
                  $row.remove();
                  delete waitStartMsMap[c.id];
                  clearAnchor(c.id); // drop any waiting anchor once they leave the queue

                  // ✅ IMPORTANT: copy the whole queue object (c) so we keep kiosk_upsells
                  const servedObj = {
                    ...c,
                    queue_id:   qid,          // ensure queue_id is set for served list
                    staff_name: staff.name    // who is serving them
                  };

                  // this will immediately render upsell badges using kiosk_upsells / summary
                  pushIntoServedInstant(servedObj, famMeta);
                },

                onError: function () {
                  // Only nag if we were actually online when it failed
                  if (window.APP_ONLINE !== false) {
                    alert('Failed to mark as served. Please try again.');
                    $btn.prop('disabled', false);
                  }
                }
              });
            });
        },
        function onCancel() {
          $btn.prop('disabled', false);
        }
      );
    });



  const $addCart = $('<button class="btn btn-outline-primary btn-slim btn-compact btn-add-cart">Add to Cart</button>')
    .on('click', () => openServicePickerForCustomer(c, false));

  // respect cached state for Add to Cart
  const cached = cartStatusCache[c.id];
  if (cached === 'pending' || cached === 'paid') {
    $addCart.prop('disabled', true)
            .addClass('disabled btn-secondary')
            .removeClass('btn-outline-primary');
  }

  $actions.append($cb, $del, $serve, $addCart);
  $row.append($actions);

  // --- SECOND ROW: name + cart badge (like served cards) ---
  const $headline = $('<div class="qi-headline" />');
  const $nameEl   = $('<span class="qi-name font-weight-bold" />').text(nameFrom(c));
  $headline.append($nameEl);
  $row.append($headline);

  // show / refresh badge + disable Add to Cart when needed
  updateCartBadge(c, $nameEl, $row, 'checkedin');
  
  // --- WAIT TIMER (always-on, anchored to added_to_queue from DB) ---
  {
    // Always re-derive from the DB timestamps, so we never reuse a stale cached value
    const parsed = parseLocalMs(
      c.added_to_queue || c.added || c.timestamp || c.created_at || c.created || c.checkin_time
    );
    const startMs = Number.isFinite(parsed) ? parsed : Date.now();

    // Overwrite any previous anchor so this visit always starts from the real join time
    waitStartMsMap[c.id] = startMs;
    setWaitMs(c.id, startMs);

    const $waitChip = $(`
      <div class="muted small">
        <i class="far fa-clock mr-1"></i>
        Waiting: <span class="js-wait-timer" data-start-ms="${startMs}">0s</span>
      </div>
    `);
    $row.append($waitChip);
  }

    

  // --- THIRD ROW: phone (pretty) ---
  if (c.phone) {
    $row.append($('<div class="appointment-info" />').text(formatPhoneAU(c.phone)));
  }

  // Kiosk upsell badges (always based on latest data)
  refreshUpsellBadges($row, c);
  
    // --- Edit add-ons / upsells button (POS-only, discrete) ---
  const $upsellEditRow = $(`
    <div class="mt-1 small text-right">
      <button type="button"
              class="btn btn-link btn-sm p-0 btn-upsells"
              data-id="${c.id}"
              data-queue-id="${qid}">
        <i class="fas fa-plus-circle mr-1"></i> Add-ons / Upsells
      </button>
    </div>
  `);
  $row.append($upsellEditRow);

  // (optional) keep appointment line after phone if present
  if (c.service_item_name) {
    let line = 'Appointment: ' + c.service_item_name;
    if (c.staff_given_name) line += ' with ' + c.staff_given_name;
    if (c.appointment_time) line += ' @ ' + c.appointment_time;
    $row.append($('<div class="appointment-info" />').text(line));
  }

  return $row;
}


function showAlertBadge($btn, text, isError){
  $btn.css('position','relative');                // ensure the badge can anchor to the button
  let $badge = $btn.find('.callback-badge');
  if (!$badge.length) $badge = $('<span class="callback-badge"></span>').appendTo($btn);
  $badge.toggleClass('error', !!isError).text(text);

  // animate in
  requestAnimationFrame(() => $badge.addClass('show'));
  // fade out + remove
  setTimeout(() => $badge.removeClass('show'), 1200);
  setTimeout(() => $badge.remove(), 1500);
}

function renderCheckedInList(list){
  const $wrap = $('#queueList');
  const rows = Array.isArray(list) ? list : [];

  // If we have data, kill any old empty-state first
  if (rows.length) {
    $wrap.find('.checkedin-empty').remove();
  }

  // Index currently-rendered rows by customer id (ONLY .queue-item cards)
  const byId = new Map();
  $wrap.children('.queue-item').each(function(){
    const cid = Number($(this).attr('data-cid') || $(this).find('[data-id]').first().attr('data-id') || 0);
    if (cid) byId.set(cid, $(this));
  });

  const seen = new Set();

  // Rebuild in server order
  rows.forEach(c => {
    const cid = Number(c.id);
    seen.add(cid);

    let $row = byId.get(cid);
    if ($row) {
      // Keep existing node (preserves DOM), move into current order
      $wrap.append($row);

      // ALWAYS re-anchor to the DB join time (added_to_queue) for this visit
      const parsed = parseLocalMs(
        c.added_to_queue || c.added || c.timestamp || c.created_at || c.created || c.checkin_time
      );
      const startMs = Number.isFinite(parsed) ? parsed : Date.now();

      // Overwrite any previously cached anchor
      waitStartMsMap[cid] = startMs;
      setWaitMs(c.id, startMs);

      const $tmr = $row.find('.js-wait-timer');
      if ($tmr.length) {
        $tmr.attr('data-start-ms', startMs);
      } else {
        $row.append(`
          <div class="muted small">
            <i class="far fa-clock mr-1"></i>
            Waiting: <span class="js-wait-timer" data-start-ms="${startMs}">0s</span>
          </div>
        `);
      }

      // 🔄 refresh upsell badges when the row is reused
      refreshUpsellBadges($row, c);

      byId.delete(cid);
    } else {
      // New card
      const $new = buildCheckedInItem(c);
      // buildCheckedInItem already calls refreshUpsellBadges, but calling again is safe
      refreshUpsellBadges($new, c);
      $wrap.append($new);
    }
  });


  // Remove cards no longer present
  byId.forEach(($row, cid) => { if (!seen.has(cid)) $row.remove(); });

  // If there are no actual cards, show the empty state (and tag it so we can remove later)
  if (!$wrap.children('.queue-item').length) {
    $wrap.html('<div class="text-center text-muted py-3 checkedin-empty">No clients checked in.</div>');
  } else {
    // Safety: if any empty-state survived, remove it now
    $wrap.find('.checkedin-empty').remove();
  }

  // refreshFamilyState();
  ensureFamilies();
  prefetchProfilesForVisible();   // 🔹 NEW: pre-cache profiles for visible customers
}






let queueTimer = null;
let queueInFlight = false;

function fetchQueueData() {
  // Don’t start a second request if one is already running
  if (queueInFlight) return;

  // If offline, skip the network call completely and just try again later
  if (window.APP_ONLINE === false) {
    if (queueTimer) clearTimeout(queueTimer);
    queueTimer = setTimeout(fetchQueueData, 5000);
    return;
  }

  queueInFlight = true;
  let delay = 1500; // default repeat interval

  $.getJSON('business_queue.php', function (data) {
      if (!isUIFrozen()) {
        renderCheckedInList(data);
        hydrateCartFromVisibleCustomers();
      }
  })
  .fail(function () {
      // On error, back off to 30s
      delay = 30000;
  })
  .always(function () {
      queueInFlight = false;

      if (document.hidden) {
        if (queueTimer) {
          clearTimeout(queueTimer);
          queueTimer = null;
        }
        return;
      }

      if (queueTimer) clearTimeout(queueTimer);
      queueTimer = setTimeout(fetchQueueData, delay);
  });
}



refreshWaitEta();                 // first paint
setInterval(refreshWaitEta, 10000); // update every 10s


/* ============================
   MIDDLE: Served
============================ */
function buildServedItem(c) {
  const $row = $('<div class="queue-item d-flex flex-column" />');
  const qid = Number(c.queue_id || c.q_id || c.queueId || businessId || 0);
  $row.attr('data-queue-id', qid);
  $row.attr('data-cid', c.id);

  // If we already know this customer's family, paint it straight away
  applyFamilyStylesForRow($row);

  const $top = $('<div class="d-flex justify-content-between align-items-center qi-headline" />');
  const displayName = nameFrom(c);
  const $nameEl = $('<span class="qi-name font-weight-bold" />').text(displayName);
  $top.append($nameEl);
  $row.append($top);


  updateCartBadge(c, $nameEl, $row, 'served');

  const $actions = $('<div class="qi-subrow" />');

  const $profile  = $('<button class="btn btn-success btn-compact btn-slim btn-grow">Customer Profile</button>')
    .attr('data-id', c.id)
    .on('click', () => openCustomerProfileInline(c.id));

  const $finish = $('<button class="btn btn-orange btn-compact btn-slim btn-finish btn-grow">Finish Service</button>')
    .attr('data-id', c.id)
    .prop('disabled', true)
    .on('click', function () {
    if ($(this).prop('disabled')) return;
    const $b = $(this).prop('disabled', true).text('Saving…');

    // Optimistic local update (works even when offline)
    const nowMs = Date.now();
    serveEndMsMap[c.id] = nowMs;
    setEndMs(c.id, nowMs);

    const $rowEl = $b.closest('.queue-item');
    const $tmr   = $rowEl.find('.js-serve-timer');

    $rowEl.find('.js-serve-label').text('Served');
    if ($tmr.length) $tmr.attr('data-end-ms', nowMs);
    if (typeof updateLiveTimers === 'function') updateLiveTimers();

    // Give the button the "Finished" look + local 2h lock
    finishLocks[c.id] = nowMs + 7200 * 1000;
    persistFinishLocks();
    $b.text('Finished').addClass('disabled').prop('disabled', true);

    // Now queue the real DB write (or send immediately if online)
    sendOrQueueAjax({
      url: window.location.pathname + '?action=finish_service',
      data: { customer_id: c.id },      // form-style, works with our PHP fallback
      description: 'Finish service ' + (nameFrom(c) || c.id),

      onSuccess: function (resp) {
        // OFFLINE path → we get { queued: true } from sendOrQueueAjax
        if (resp && resp.queued) {
          // nothing more to do; UI is already updated and job is queued
          return;
        }

        // ONLINE success as normal
        if (resp && resp.ok) {
          // nothing extra; we already set anchors + locks above
          return;
        }

        // ONLINE cooldown error from PHP (e.g. within 2 hours)
        if (resp && resp.error === 'cooldown') {
          const retry = Number(resp.retry_after_secs || 7200);
          finishLocks[c.id] = Date.now() + retry * 1000;
          persistFinishLocks();
          $b.text('Finished')
            .addClass('disabled')
            .prop('disabled', true)
            .attr('title', 'Available in ~' + Math.ceil(retry / 60) + ' min');
          return;
        }

        // Other server error (only when actually online)
        if (window.APP_ONLINE !== false) {
          alert('Failed to record: ' + ((resp && resp.error) || 'server error'));
          // let the user try again
          $b.text('Finish Service')
            .removeClass('disabled')
            .prop('disabled', false)
            .attr('title','');
          // clear local lock so it can be retried
          delete finishLocks[c.id];
          persistFinishLocks();
          if ($tmr.length) $tmr.removeAttr('data-end-ms');
        }
      },

      onError: function () {
        // Only complain if we were actually online – offline errors are already queued
        if (window.APP_ONLINE !== false) {
          alert('Failed to record service time.');
          $b.text('Finish Service')
            .removeClass('disabled')
            .prop('disabled', false)
            .attr('title','');
          delete finishLocks[c.id];
          persistFinishLocks();
          if ($tmr.length) $tmr.removeAttr('data-end-ms');
        }
      }
    });
  });


  const $addCart = $('<button class="btn btn-outline-primary btn-compact btn-slim btn-add-cart">Add to Cart</button>')
    .on('click', () => openServicePickerForCustomer(c, false));

  const cached = cartStatusCache[c.id];
  if (cached === 'pending' || cached === 'paid') {
    $addCart
      .prop('disabled', true)
      .addClass('disabled btn-secondary')
      .removeClass('btn-outline-primary');
  }

  $actions.append($profile, $finish, $addCart);
  $row.prepend($actions);

  // Finish button state on paint
  (function resolveFinishState() {
    const until = Number(finishLocks[c.id] || 0);
    const nowMs = Date.now();
    if (until > nowMs) {
      const mins = Math.ceil((until - nowMs) / 60000);
      $finish
        .text('Finished')
        .addClass('disabled')
        .prop('disabled', true)
        .attr('title', 'Available in ~' + mins + ' min');
      return;
    } else if (until) {
      delete finishLocks[c.id];
      persistFinishLocks();
    }

    $finish.text('Finish Service').prop('disabled', false).removeClass('disabled');

    $.getJSON(window.location.pathname + '?action=finish_service_status', { customer_id: c.id })
      .done(function (resp) {
        if (resp && resp.ok && resp.allowed === false) {
          const retry = Number(resp.retry_after_secs || 0);
          if (retry > 0) {
            finishLocks[c.id] = nowMs + retry * 1000;
            persistFinishLocks();
          }
          const mins = Math.ceil(retry / 60);
          $finish
            .text('Finished')
            .addClass('disabled')
            .prop('disabled', true)
            .attr('title', 'Available in ~' + mins + ' min');
        }
      });
  })();

  // Live "Serving" timer
  (function () {
    const startMs = parseLocalMs(c.served_by_staff || c.servedAt || c.served || c.timestamp);
    if (!Number.isFinite(startMs)) return;

    const persistedEnd = (getAnchor(c.id).endMs ?? serveEndMsMap[c.id]);
    const apiEnd       = parseLocalMs(c.finished_at || null);
    const endMs        = Number.isFinite(persistedEnd) ? persistedEnd : apiEnd;

    const isFinished =
      (Number.isFinite(endMs) && endMs > startMs) ||
      (c.finished === 1 || c.finished === '1' || c.finished === true);

    const label   = isFinished ? 'Served' : 'Serving';
    const endAttr = isFinished && Number.isFinite(endMs)
      ? ` data-end-ms="${endMs}"`
      : '';

    $row.append($(
      `<div class="muted small">
         <i class="fas fa-stopwatch mr-1"></i>
         <span class="js-serve-label">${label}</span>:
         <span class="js-serve-timer" data-start-ms="${startMs}"${endAttr}>0s</span>
       </div>`
    ));
  })();

  // Served-by line that we can refresh later
  if (c.staff_name) {
    $row.append(
      $('<div class="appointment-info served-by" />')
        .text('Served by: ' + c.staff_name)
        .data('staff-name', c.staff_name)
    );
  }

  // NOTE: phone row REMOVED for served customers

  // Kiosk upsell badges (shared helper)
  refreshUpsellBadges($row, c);


  const $upsellEditRow = $(`
    <div class="mt-1 small text-right">
      <button type="button"
              class="btn btn-link btn-sm p-0 btn-upsells"
              data-id="${c.id}"
              data-queue-id="${qid}">
        <i class="fas fa-plus-circle mr-1"></i> Add-ons / Upsells
      </button>
    </div>
  `);
  $row.append($upsellEditRow);

  return $row;
}



// --- tiny helper used for sorting served_by_staff timestamps ---
function tsMs(v){
  if (!v) return 0;
  const t = Date.parse(String(v).replace(' ', 'T'));
  return Number.isFinite(t) ? t : 0;
}

function renderServedList(list){
  const $wrap = $('#servedList');
  let rows = Array.isArray(list) ? list.slice() : [];

  // 🔹 NEW: hide rows that are both "finished" and "paid"
  // This covers:
  //   - Online customers (finish_service called + cart paid)
  //   - Offline customers that were finished/paid on this device
  const nowMs = Date.now();
  rows = rows.filter(c => {
    const cid = Number(c.id || 0);
    if (!cid) return true;

    // From POS cart status (rehydrated via cart_status on load)
    const paidStatus = cartStatusCache[cid];      // 'pending' | 'paid' | null
    const paid       = (paidStatus === 'paid');

    // From server (if fetch_served_clients_pos.php includes finished column)
    const finishedFlag = Number(c.finished || 0) === 1;

    // From local "Finish Service" button (cooldown lock persisted in finishLocks)
    const lockUntil     = Number(finishLocks[cid] || 0);
    const finishedLocal = finishedFlag || (lockUntil && lockUntil > nowMs);

    // DROP rows that are both finished + paid
    return !(finishedLocal && paid);
  });

  if (rows.length) {
    $wrap.find('.served-empty').remove();
  }


  rows.sort((a,b) => {
    const diff = tsMs(b.served_by_staff) - tsMs(a.served_by_staff);
    return diff !== 0 ? diff : ((Number(b.id)||0) - (Number(a.id)||0));
  });

  const byId = new Map();
  $wrap.children('.queue-item').each(function(){
    const cid = Number($(this).attr('data-cid') || $(this).find('[data-id]').first().attr('data-id') || 0);
    if (cid) byId.set(cid, $(this));
  });

  rows.forEach(c => {
    const cid = Number(c.id);
    let $row = byId.get(cid);

    if ($row) {
      $wrap.append($row); // keep sorted order by re-appending

      // Refresh timer anchors on the existing DOM row
      const startMs = parseLocalMs(c.served_by_staff || c.servedAt || c.served || c.timestamp);
      if (Number.isFinite(startMs)) {
        const $tmr = $row.find('.js-serve-timer');
        if ($tmr.length) {
          $tmr.attr('data-start-ms', startMs);
          const persistedEnd = (getAnchor(cid).endMs ?? serveEndMsMap[cid]);
          const apiEnd       = parseLocalMs(c.finished_at || null);
          const endMs        = Number.isFinite(persistedEnd) ? persistedEnd : apiEnd;
          if (Number.isFinite(endMs) && endMs > startMs) {
            $tmr.attr('data-end-ms', endMs);
            $row.find('.js-serve-label').text('Served');
          }
        }
      }

      // 🔄 refresh upsell badges on reused row
      refreshUpsellBadges($row, c);

      byId.delete(cid);
    } else {
      const $new = buildServedItem(c);
      // buildServedItem already calls refreshUpsellBadges, but extra call is harmless
      refreshUpsellBadges($new, c);
      $wrap.append($new);
    }
  });


  // Remove rows no longer present
  byId.forEach(($row) => $row.remove());

  if (!$wrap.children('.queue-item').length) {
    $wrap.html('<div class="text-center text-muted py-3 served-empty">No served clients yet.</div>');
  }

  ensureFamilies();
  refreshServedStaffLabels();

  // Also render any offline-served temp clients, positioned vs latest ONLINE served
  if (typeof renderOfflineServedInPanel === 'function') {
    let latestOnlineMs = 0;
    if (rows.length) {
      const top = rows[0];
      latestOnlineMs = parseLocalMs(
        top.served_by_staff || top.servedAt || top.served || top.timestamp || ''
      ) || 0;
    }
    renderOfflineServedInPanel(latestOnlineMs);
  }

  prefetchProfilesForVisible();   // 🔹 NEW: also pre-cache when Served list updates
}





function refreshServedStaffLabels(){
  const ids = [];
  $('#servedList .queue-item').each(function(){
    const cid = Number($(this).attr('data-cid'));
    if (cid) ids.push(cid);
  });
  if (!ids.length) return;

  $.getJSON(window.location.pathname + '?action=served_staff_refresh', { ids: ids.join(',') })
    .done(function(resp){
      if (!resp || !resp.ok || !resp.map) return;
      const map = resp.map;
      Object.keys(map).forEach(function(idStr){
        const cid  = Number(idStr);
        const name = (map[idStr] || '').trim();
        const $row = $('#servedList .queue-item[data-cid="'+cid+'"]');
        if (!$row.length) return;

        let $line = $row.find('.appointment-info.served-by');

        if (!name) {
          // no staff now – remove line if present
          if ($line.length) $line.remove();
          return;
        }

        if (!$line.length) {
          // create line if it doesn't exist yet
          $line = $('<div class="appointment-info served-by"></div>').appendTo($row);
        }

        const current = ($line.data('staff-name') || '').trim();
        if (current === name) return;   // nothing changed

        $line.text('Served by: ' + name).data('staff-name', name);
      });
    });
}


function repaintFamiliesDebounced(){
  clearTimeout(__famPaintTimer);
  __famPaintTimer = setTimeout(() => {
    // If we have no family data yet, there's nothing to repaint.
    if (!FAMILIES || !Object.keys(FAMILIES).length) {
      return;
    }
    const now = stableStateSnapshot();
    if (now === __LAST_FAM_STATE) return;  // nothing changed
    __LAST_FAM_STATE = now;
    applyFamilyDecorations();
  }, 80);
}



function sydneyNowSQL(){
  const parts = new Intl.DateTimeFormat('en-CA',{
    timeZone:'Australia/Sydney',
    year:'numeric',month:'2-digit',day:'2-digit',
    hour:'2-digit',minute:'2-digit',second:'2-digit',
    hour12:false
  }).formatToParts(new Date());
  const g=t=>parts.find(p=>p.type===t)?.value||'00';
  return `${g('year')}-${g('month')}-${g('day')} ${g('hour')}:${g('minute')}:${g('second')}`;
}


function pushIntoServedInstant(c, familyMeta) {
  // ensure we have a served_at timestamp for timers
  c = { ...c, served_by_staff: c.served_by_staff || sydneyNowSQL() };
  const $row = buildServedItem(c);

  // If we know the family from the checked-in card, paint it immediately
  if (familyMeta && familyMeta.key) {
    const key   = String(familyMeta.key);
    const label = (familyMeta.label || '').trim();
    const color = colorForKey(key) || '#FDE68A';

    $row
      .addClass('has-family')
      .attr('data-fam-key', key)
      .attr('data-fam-label', label)
      .css('--fam-color', color);

    // Inject fam-chip if it isn't already there
    if (!$row.find('.fam-chip').length) {
      const $chip = $(`
        <div class="fam-chip" style="--fam-color:${color}">
          <i class="fas fa-users" aria-hidden="true"></i>
          <span class="lbl"></span>
          <button type="button" class="edit" title="Edit family">
            <i class="fas fa-edit"></i>
          </button>
        </div>
      `);

      $chip.find('.lbl').text(label || 'Family');
      $chip.find('.edit').on('click', function (e) {
        e.stopPropagation();
        openFamilyEditModal(key);
      });

      $row.prepend($chip);
    }
  }

  $('#servedList').prepend($row);

  // Still re-sync from DB so we stay true to the backend
  refreshFamilyState();
}

let servedTimer = null;
function fetchServedData() {
  // If offline, don't hammer the server
  if (window.APP_ONLINE === false) {
    if (servedTimer) clearTimeout(servedTimer);
    servedTimer = setTimeout(fetchServedData, 5000);
    return;
  }

  $.ajax({
    url: 'fetch_served_clients_pos.php',
    type: 'GET',
    dataType: 'json',
    data: { user_queue_id: businessId }
  })
  .done(data => {
    renderServedList(data);
    hydrateCartFromVisibleCustomers();
    // normal polling cadence when things are working
    servedTimer = setTimeout(fetchServedData, 1500);
  })
  .fail(() => {
    // on error, back off a bit so we don't hammer the server/browser
    servedTimer = setTimeout(fetchServedData, 30000);
  });
}


// Pause polling when tab not visible; resume when it becomes visible again
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    // Stop future polls while hidden
    if (queueTimer)  { clearTimeout(queueTimer);  queueTimer = null; }
    if (servedTimer) { clearTimeout(servedTimer); servedTimer = null; }
  } else {
    // Resume if not already scheduled
    if (!queueTimer)  fetchQueueData();
    if (!servedTimer) fetchServedData();
  }
});



/* ============================
   RIGHT: Shopping Cart
============================ */
const cart = { items: [] }; // {customerId, customerName, serviceId, serviceName, priceCents, qty, queueId}
const hydratedCustomers = new Set();

function updateAllRowsForCustomer(customerId, fn) {
  $('.queue-item').each(function(){
    const $row = $(this);
    const $btn = $row.find('[data-id]').first();
    if ($btn.length && Number($btn.attr('data-id')) === Number(customerId)) fn($row);
  });
}
function addToCartLocalOnly(customerId, customerName, queueId, itemsArr) {
  itemsArr.forEach(svc => {
    const serviceId = Number(svc.service_id ?? svc.id);
    const priceCents = Number(svc.price_cents ?? svc.variation_price_amount ?? 0);
    const qty = Number(svc.qty || 1);
    const existing = cart.items.find(it => it.customerId === customerId && it.serviceId === serviceId);
    if (existing) existing.qty += qty;
    else cart.items.push({ customerId, customerName, serviceId, serviceName:(svc.name ?? svc.item_name ?? 'Service'), priceCents, qty, queueId });
  });
  renderCart();
}
function addToCart(customer, selectedServices) {
  const customerId = Number(customer.id);
  const customerName = nameFrom(customer);
  let qid = 0;
  $('.queue-item').each(function(){
    const $row = $(this);
    const $btn = $row.find('[data-id]').first();
    if ($btn.length && Number($btn.attr('data-id')) === customerId) { qid = Number($row.attr('data-queue-id') || 0); return false; }
  });
  if (!qid && customer.queue_id) qid = Number(customer.queue_id);
  if (!qid) { alert('Missing queue reference for this customer. Please refresh.'); return; }

  cartStatusCache[customerId] = 'pending'; persistStatus();
  updateAllRowsForCustomer(customerId, $row => { const $nameEl=$row.find('.font-weight-bold').first(); setBadge($nameEl,'pending'); applyCartButtonState($row,'pending'); });

  selectedServices.forEach(svc => {
    const existing = cart.items.find(it => it.customerId === customerId && it.serviceId === svc.id);
    const qtyToAdd = Number(svc.qty || 1);
    if (existing) existing.qty += qtyToAdd;
    else cart.items.push({ customerId, customerName, serviceId: svc.id, serviceName: svc.item_name, priceCents: Number(svc.variation_price_amount || 0), qty: qtyToAdd, queueId: qid });
  });
  renderCart();
}
function hydrateCartFromVisibleCustomers() {
  // Offline: keep the local cart only; don't try to sync from server
  if (window.APP_ONLINE === false) return;

  const seen = {};
  $('.queue-item').each(function(){
    const $row = $(this);
    const $btn = $row.find('[data-id]').first();
    const qid  = Number($row.attr('data-queue-id') || 0);
    if (!$btn.length || !qid) return;

    const cid = Number($btn.attr('data-id'));
    if (seen[cid]) return; seen[cid] = true;
    if (hydratedCustomers.has(cid)) return;
    hydratedCustomers.add(cid);  // guard BEFORE request to avoid double-hydrate races

    const nameText = $row.find('.font-weight-bold').first().text().trim() || 'Customer';

    $.getJSON(window.location.pathname + '?action=cart_status', { customer_id: cid, queue_id: qid })
      .done(resp => {
        const cartRow  = resp?.cart || null;
        const status   = cartRow?.status ?? null;   // 'pending' or null
        const allowNew = !!resp?.allow_new;         // false during 2h cooldown

        if (status === 'pending' && Array.isArray(cartRow.items_json) && cartRow.items_json.length) {
          // Replace local group with server copy (idempotent)
          cart.items = cart.items.filter(it => !(Number(it.customerId) === cid && Number(it.queueId) === qid));
          addToCartLocalOnly(cid, nameText, qid, cartRow.items_json);
          cartStatusCache[cid] = 'pending';
          persistStatus();
          updateAllRowsForCustomer(cid, $r => {
            const $n = $r.find('.font-weight-bold').first();
            setBadge($n, 'pending'); applyCartButtonState($r, 'pending');
          });
          renderCart();
        } else {
          // No active cart -> ensure local group is cleared
          const before = cart.items.length;
          cart.items = cart.items.filter(it => !(Number(it.customerId) === cid && Number(it.queueId) === qid));
          if (cart.items.length !== before) renderCart();

          if (!status && allowNew === false) {
            // within 2h cooldown -> show Paid
            if (cartStatusCache[cid] !== 'paid') { cartStatusCache[cid] = 'paid'; persistStatus(); }
            updateAllRowsForCustomer(cid, $r => {
              const $n = $r.find('.font-weight-bold').first();
              setBadge($n, 'paid'); applyCartButtonState($r, 'paid');
            });
          } else {
            if (cartStatusCache[cid] !== null) {
              cartStatusCache[cid] = null; persistStatus();
              updateAllRowsForCustomer(cid, $r => {
                const $n = $r.find('.font-weight-bold').first();
                setBadge($n, null); applyCartButtonState($r, null);
              });
            }
          }
        }
      })
      .fail(() => {
        // let it retry next render if the call failed
        hydratedCustomers.delete(cid);
      });
  });
}


/* ===== Quick Sale support ===== */
function hydrateQuickSaleFromServer() {
  // Offline: we don't try to sync Quick Sale from the server
  if (window.APP_ONLINE === false) return;

  $.getJSON(window.location.pathname + '?action=qs_status')
    .done(resp => {
      const cartRow = resp?.cart || null;
      const status  = cartRow?.status ?? null;

      if (status === 'pending' && Array.isArray(cartRow.items_json) && cartRow.items_json.length) {
        // replace local QS group with server copy
        cart.items = cart.items.filter(it => it.customerId !== QUICKSALE_ID);
        addToCartLocalOnly(QUICKSALE_ID, 'Quick Sale', businessId, cartRow.items_json);
        cartStatusCache[QUICKSALE_ID] = 'pending';
        persistStatus();
        renderCart();
      } else if (status === 'paid') {
        cartStatusCache[QUICKSALE_ID] = 'paid';
        persistStatus();
      } else {
        // clear any local QS items if server says there's no cart
        if (cart.items.some(it => it.customerId === QUICKSALE_ID)) {
          cart.items = cart.items.filter(it => it.customerId !== QUICKSALE_ID);
          renderCart();
        }
        cartStatusCache[QUICKSALE_ID] = null;
        persistStatus();
      }
    });
}

function openServicePickerForQuickSale() {
  // 1) pick staff first
  openStaffChooser('<strong>Quick Sale</strong> — select staff member', function onPicked(staff){
    quickSaleStaff      = staff || null;

    // 2) set up picker for QS
    pickerCustomer      = { id: QUICKSALE_ID, queue_id: businessId };
    pickerIsQuickSale   = true;
    pickerRedoAllowed   = false; // <-- QS has no customer context, never allow Redo

    $('#servicePickerCustomer').html(
      '<strong>Quick Sale</strong>' + (quickSaleStaff ? ' — ' + $('<div/>').text(quickSaleStaff.name).html() : '')
    );
    const isOffline = (window.APP_ONLINE === false);

    if (isOffline) {
      if (!cachedServices || !Array.isArray(cachedServices) || !cachedServices.length) {
        $('#servicesContainer').html(
          '<div class="text-danger">Services are only available for Quick Sale offline after this device has loaded them once while online.</div>'
        );
        $('#servicePickerModal').modal('show');
        return;
      }

      pickerQTokens       = 0;
      pickerHasQFeature   = false;
      pickerTokenBudget   = 0;
      pickerTokenSelected = 0;

      // Pre-fill from LOCAL Quick Sale items only
      const existingLocal = cart.items.filter(it => String(it.customerId) === String(QUICKSALE_ID));

      renderServiceOptions(cachedServices);

      if (existingLocal.length) {
        $('#servicesContainer .svc-cell').each(function(){
          const svc = $(this).data('svc'); if (!svc) return;
          const match = existingLocal.find(it => Number(it.serviceId) === Number(svc.id));
          if (match) {
            const q = Number(match.qty || 1);
            $(this).data('base', q).data('count', q);
            $(this).find('.svc-ui').show().find('.svc-count').text(q);
          }
        });
      }

      applyScanEntriesToPicker();
      renderScanStrip();
      $('#servicePickerModal').modal('show');
      return;
    }


    // 3) load services + current QS cart; then show modal
    const loadServices = $.getJSON(window.location.pathname + '?action=services')
      .then(function (resp) {
        if (resp && resp.ok && Array.isArray(resp.services)) {
          saveServicesCache(resp.services);
          return resp;
        }
        throw new Error('services load failed');
      });



    $.when(loadServices, $.getJSON(window.location.pathname + '?action=qs_status'))
      .done((svcResp, qsResp) => {
        const services = (svcResp?.services ?? svcResp?.[0]?.services ?? cachedServices ?? []);
        renderServiceOptions(services);
        
        // pre-fill any existing QS cart lines into the grid counts (and mark base)
        const items = (qsResp?.[0]?.cart?.items_json) || [];
        if (items.length) {
          $('#servicesContainer .svc-cell').each(function(){
            const svc = $(this).data('svc'); if (!svc) return;
            const match = items.find(it => Number(it.service_id) === Number(svc.id));
            if (match) {
              const q = Number(match.qty || 1);
              $(this).data('base', q).data('count', q);
              $(this).find('.svc-ui').show().find('.svc-count').text(q);
            }
          });
        }

        
        // apply any freshly scanned barcodes last
        applyScanEntriesToPicker();
        renderScanStrip();


        // QS never uses Q-tokens
        pickerQTokens       = 0;
        pickerHasQFeature   = false;
        pickerTokenBudget   = 0;
        pickerTokenSelected = 0;

        $('#servicePickerModal').modal('show');
      })
      .fail(() => alert('Could not load Quick Sale state. Please try again.'));
  }, function onCancel(){
    // cancelled picking staff; do nothing
  });
}





/* ===== Remove / clear / render cart ===== */
function removeCartItem(idx) {
  const row = cart.items[idx];
  if (!row) return;

  // OFFLINE: local-only cart changes
  if (window.APP_ONLINE === false) {
    const cid = row.customerId;
    const qid = row.queueId;

    cart.items.splice(idx, 1);
    renderCart();

    const stillHas = cart.items.some(it => it.customerId === cid && it.queueId === qid);
    if (!stillHas) {
      cartStatusCache[cid] = null;
      persistStatus();

      if (cid === QUICKSALE_ID) {
        // nothing – Quick Sale has no per-row badge
      } else {
        const numId = Number(cid);
        if (Number.isFinite(numId) && numId > 0) {
          // Online customer row
          updateAllRowsForCustomer(numId, $row => {
            const $n = $row.find('.font-weight-bold').first();
            setBadge($n, null);
            applyCartButtonState($row, null);
          });
        } else {
          // Offline-served temp customer row
          updateOfflineServedRowForTempId(String(cid), null);
        }
      }
    }

    return;
  }

  // ONLINE path (unchanged)
  if (row.customerId === QUICKSALE_ID) {
    $.ajax({ url: window.location.pathname + '?action=qs_remove_items', type:'POST', contentType:'application/json', data: JSON.stringify({ service_ids:[row.serviceId] }) })
      .done(resp => {
        cart.items.splice(idx, 1); renderCart();
        if (resp?.state === 'empty') { cartStatusCache[QUICKSALE_ID] = null; persistStatus(); }
        else { cartStatusCache[QUICKSALE_ID] = 'pending'; persistStatus(); }
      })
      .fail(() => alert('Failed to remove item from quick sale.'));
    return;
  }

  $.ajax({ url: window.location.pathname + '?action=cart_remove_items', type:'POST', contentType:'application/json',
           data: JSON.stringify({ customer_id: row.customerId, queue_id: row.queueId, service_ids:[row.serviceId] }) })
    .done(resp => {
      cart.items.splice(idx, 1); renderCart();
      if (resp?.state === 'empty') {
        cartStatusCache[row.customerId] = null; persistStatus();
        updateAllRowsForCustomer(row.customerId, $row => { const $n=$row.find('.font-weight-bold').first(); setBadge($n, null); applyCartButtonState($row, null); });
      } else {
        cartStatusCache[row.customerId] = 'pending'; persistStatus();
        updateAllRowsForCustomer(row.customerId, $row => applyCartButtonState($row, 'pending'));
      }
    })
    .fail(() => alert('Failed to remove item from cart.'));
}

function clearCart() {
  if (cart.items.length === 0) { renderCart(); return; }

  // OFFLINE: just clear local cart & badges
  if (window.APP_ONLINE === false) {
    cart.items = [];
    renderCart();

    Object.keys(cartStatusCache).forEach(k => { cartStatusCache[k] = null; });
    persistStatus();

    $('.queue-item').each(function(){
      const $row = $(this);
      const $n   = $row.find('.font-weight-bold').first();
      setBadge($n, null);
      applyCartButtonState($row, null);   // also re-enables offline Add to Cart
    });

    return;
  }

  // ONLINE path (unchanged)
  const ops = [];

  if (cart.items.some(it => it.customerId === QUICKSALE_ID)) {
    ops.push($.ajax({ url: window.location.pathname + '?action=qs_clear', type:'POST' })
      .done(() => { cartStatusCache[QUICKSALE_ID] = null; persistStatus(); cart.items = cart.items.filter(it => it.customerId !== QUICKSALE_ID); }));
  }

  const seen = {};
  cart.items.forEach(it => {
    if (it.customerId === QUICKSALE_ID) return;
    const key = it.customerId + '|' + it.queueId;
    if (seen[key]) return; seen[key]=true;
    ops.push($.ajax({ url: window.location.pathname + '?action=cart_clear', type:'POST', contentType:'application/json',
                      data: JSON.stringify({ customer_id: it.customerId, queue_id: it.queueId }) })
      .done(() => {
        cartStatusCache[it.customerId] = null; persistStatus();
        updateAllRowsForCustomer(it.customerId, $row => { const $n=$row.find('.font-weight-bold').first(); setBadge($n, null); applyCartButtonState($row, null); });
        cart.items = cart.items.filter(r => !(r.customerId === it.customerId && r.queueId === it.queueId));
      }));
  });

  $.when.apply($, ops).always(renderCart);
}

// --- Edit qty helpers ---
function openEditQty(idx){
  const row = cart.items[idx];
  if (!row) return;

  const cur = Number(row.qty || 1);
  let val = prompt(`Set quantity for "${row.serviceName}" (${row.customerName || (row.customerId===QUICKSALE_ID?'Quick Sale':'Customer')}):`, cur);
  if (val === null) return;               // cancelled
  val = parseInt(val, 10);
  if (!Number.isFinite(val) || val < 0 || val > 999){
    alert('Enter a whole number between 0 and 999.');
    return;
  }
  if (val === cur) return;

  updateCartQty(idx, val);
}

function updateCartQty(idx, newQty){
  const row = cart.items[idx];
  if (!row) return;

  // OFFLINE: change local cart only
  if (window.APP_ONLINE === false) {
    if (newQty === 0) {
      removeCartItem(idx);
    } else {
      cart.items[idx].qty = newQty;
      renderCart();
    }
    return;
  }

  const oldQty = Number(row.qty || 1);
  const svcId  = Number(row.serviceId);
  const isQS   = (row.customerId === QUICKSALE_ID);

  // 0 means delete (reuse your existing remover, which already updates server+UI)
  if (newQty === 0){ removeCartItem(idx); return; }

  // Build server ops:
  // For decreases we do: remove then (if needed) add with newQty.
  // For increases we only add the delta (fewer writes).
  let op;
  if (isQS){
    if (newQty < oldQty){
      op = $.Deferred();
      $.ajax({
        url: window.location.pathname + '?action=qs_remove_items',
        type:'POST', contentType:'application/json',
        data: JSON.stringify({ service_ids:[svcId] })
      }).done(function(){
        $.ajax({
          url: window.location.pathname + '?action=qs_add_items',
          type:'POST', contentType:'application/json',
          data: JSON.stringify({ items:[{ service_id: svcId, name: row.serviceName, price_cents: row.priceCents, qty: newQty }] })
        }).done(()=>op.resolve()).fail(()=>op.reject());
      }).fail(()=>op.reject());
    } else {
      const delta = newQty - oldQty;
      op = $.ajax({
        url: window.location.pathname + '?action=qs_add_items',
        type:'POST', contentType:'application/json',
        data: JSON.stringify({ items:[{ service_id: svcId, name: row.serviceName, price_cents: row.priceCents, qty: delta }] })
      });
    }
  } else {
    if (newQty < oldQty){
      op = $.Deferred();
      // remove entire service then add back with newQty
      $.ajax({
        url: window.location.pathname + '?action=cart_remove_items',
        type:'POST', contentType:'application/json',
        data: JSON.stringify({ customer_id: row.customerId, queue_id: row.queueId, service_ids:[svcId] })
      }).done(function(){
        $.ajax({
          url: window.location.pathname + '?action=cart_add_items',
          type:'POST', contentType:'application/json',
          data: JSON.stringify({ customer_id: row.customerId, queue_id: row.queueId,
                                 items:[{ service_id: svcId, name: row.serviceName, price_cents: row.priceCents, qty: newQty }] })
        }).done(()=>op.resolve()).fail(()=>op.reject());
      }).fail(()=>op.reject());
    } else {
      const delta = newQty - oldQty;
      op = $.ajax({
        url: window.location.pathname + '?action=cart_add_items',
        type:'POST', contentType:'application/json',
        data: JSON.stringify({ customer_id: row.customerId, queue_id: row.queueId,
                               items:[{ service_id: svcId, name: row.serviceName, price_cents: row.priceCents, qty: delta }] })
      });
    }
  }

  // UI optimistic disable + finalize
  const $btn = $('.cart-item button[data-edit-idx="'+idx+'"]');
  $btn.prop('disabled', true);

  op.done(function(){
    // update local model, re-render
    cart.items[idx].qty = newQty;
    renderCart();
  }).fail(function(){
    alert('Failed to update quantity. Please try again.');
    $btn.prop('disabled', false);
  });
}

function cartTotalCents() { return cart.items.reduce((s, it) => s + it.priceCents * it.qty, 0); }
function renderCart() {
  const $wrap = $('#cartItems').empty();
  if (cart.items.length === 0) {
    $wrap.append('<div class="cart-empty text-center py-3">Your cart is empty.</div>');
  } else {
    const byCustomer = {};
    cart.items.forEach((it, idx) => { if (!byCustomer[it.customerId]) byCustomer[it.customerId] = []; byCustomer[it.customerId].push({ ...it, _idx: idx }); });

    Object.keys(byCustomer).forEach(custId => {
      const group = byCustomer[custId];
      const label = (custId === QUICKSALE_ID) ? 'Quick Sale' : group[0].customerName;
      const chip = $('<div class="customer-chip mb-2"><i class="far fa-user mr-1"></i>' + label + '</div>');
      $wrap.append(chip);
    
      group.forEach(row => {
        const $item = $('<div class="cart-item" />');
        const $left = $('<div class="d-flex flex-column" />');
        $left.append($('<span class="cart-title" />').text(row.serviceName));
        $left.append($('<small class="muted" />').text('Qty: ' + row.qty));
        const $right = $('<div class="d-flex align-items-center" />');
        $right.append($('<span class="price mr-2" />').text(centsToAUD(row.priceCents * row.qty)));
        
        // <-- add this:
        const $edit = $('<button class="btn btn-outline-secondary btn-sm mr-2" title="Edit items"><i class="far fa-edit"></i></button>')
          .on('click', () => {
            if (window.APP_ONLINE === false) {
              showSnack
                ? showSnack('Editing cart items is only available when LineUpz is online.', true, 2200)
                : alert('Editing cart items is only available when LineUpz is online.');
              return;
            }
            openEditItemsForGroup(row.customerId);
          });

        $right.append($edit);
        
        // existing remove button
        const $rm = $('<button class="btn btn-outline-danger btn-sm" title="Remove"><i class="far fa-trash-alt"></i></button>')
          .on('click', () => removeCartItem(row._idx));
        $right.append($rm);
        
        $item.append($left, $right);
        $wrap.append($item);
      });
    });
  }
  $('#cartTotal').text(centsToAUD(cartTotalCents()));
}

$('#cartClear').on('click', clearCart);

// Single vs Double click handler for Checkout
let checkoutClickTimer = null;
const CHECKOUT_CLICK_DELAY = 260; // ms

function openCheckoutNormally(){
  if (cart.items.length === 0) { alert('Cart is empty.'); return; }

  // Group items by customer like before
  checkoutByCustomer = {};
  cart.items.forEach(it => {
    if (!checkoutByCustomer[it.customerId]) {
      checkoutByCustomer[it.customerId] = {
        queueId: it.queueId,
        items: [],
        name: it.customerName || (it.customerId===QUICKSALE_ID ? 'Quick Sale' : 'Customer')
      };
    }
    checkoutByCustomer[it.customerId].items.push(it);
  });

  checkoutQueue = Object.keys(checkoutByCustomer);
  checkoutIdx = 0;
  checkoutTxnGroup = 'TXN-' + Date.now() + '-' + Math.random().toString(36).slice(2, 7).toUpperCase();
  openCheckoutForCurrent();
}

async function quickDrawerOpenZeroSale(){
  // Pick a staff member first
  openStaffChooser('<strong>Open Drawer</strong> — select staff for $0.00 cash', async function onPicked(staff){
    try {
      // If there is a pending Quick Sale with items, don't hijack it — just open drawer.
      const st = await $.getJSON(window.location.pathname + '?action=qs_status');
      const hasPendingWithItems = !!(st && st.cart && st.cart.status === 'pending'
                                     && Array.isArray(st.cart.items_json) && st.cart.items_json.length > 0);

      if (!hasPendingWithItems) {
        // Ensure a pending QS row (empty), attributed to this staff
        await $.ajax({
          url: window.location.pathname + '?action=qs_add_items',
          type: 'POST',
          contentType: 'application/json',
          data: JSON.stringify({ items: [], staff_id: staff.id })
        });
        // Mark it paid (CASH) with a recognizable txn_group
        const txnGroup = 'DRAWER-' + Date.now().toString(36).toUpperCase();
        await $.ajax({
          url: window.location.pathname + '?action=qs_mark_paid',
          type: 'POST',
          contentType: 'application/json',
          data: JSON.stringify({
            payment_method: 'cash',
            external_ref: '',
            txn_group: txnGroup,
            staff_id: staff.id
          })
        });
        showSnack('Logged $0 sale · ' + staff.name);
      } else {
        showSnack('Quick Sale pending — logged drawer open only', true, 2200);
      }

      // Physically open the drawer
      drawerKick();

    } catch (e) {
      // Still try to open the drawer, but warn if we couldn’t log
      drawerKick();
      showSnack('Drawer opened, but $0 sale not recorded', true, 2400);
    }
  });
}

$('#cartCheckout').off('click').on('click', function(e){
  // If second click arrives within the window, treat as double
  if (checkoutClickTimer){
    clearTimeout(checkoutClickTimer);
    checkoutClickTimer = null;
    e.preventDefault();
    e.stopImmediatePropagation();
    quickDrawerOpenZeroSale();
    return;
  }
  // Otherwise schedule normal checkout
  checkoutClickTimer = setTimeout(() => {
    checkoutClickTimer = null;
    openCheckoutNormally();
  }, CHECKOUT_CLICK_DELAY);
});

function buildQuickCash(totalCents){
  const exact = totalCents;
  const next5  = Math.ceil(totalCents / 500)  * 500;
  const next10 = Math.ceil(totalCents / 1000) * 1000;
  const next20 = Math.ceil(totalCents / 2000) * 2000;
  return [exact, next5, next10, next20, 5000, 10000]
    .filter((v, i, a) => a.indexOf(v) === i)
    .sort((a,b)=>a-b);
}
function renderQuickCash(totalCents){
  const $wrap = $('#coQuickCash').empty();
  const amounts = buildQuickCash(totalCents);
  amounts.forEach(c => {
    const $b = $('<button type="button" class="btn btn-outline-secondary qbtn"></button>')
      .text(centsToAUD(c)).attr('data-amt', c);
    $wrap.append($b);
  });
}
// ===== Cash Drawer integration =====
// Fire-and-forget post to the drawer page.
// kind: 'sale_cash'|'in'|'out'|'adjust'
// amountCents: integer cents
// reason: short text shown in movement table
function cdPost(kind, amountCents, reason){
  const dollars = (Number(amountCents)||0) / 100;
  // Only attempt if positive
  if (dollars <= 0) return $.Deferred().resolve().promise();
  return $.ajax({
    url: 'cash_drawer.php?action=move',
    type: 'POST',
    contentType: 'application/json',
    data: JSON.stringify({ kind, amount: dollars, reason: (reason||'') })
  })
  // Non-blocking: swallow errors (eg. no open drawer) but nudge the user
  .fail(xhr => {
    try {
      const r = JSON.parse(xhr.responseText||'{}');
      if (r && r.error === 'no_open_drawer'){
        showSnack('Open the Cash Drawer to log cash takings.', true, 2200);
      }
    } catch(e){}
  });
}
/* ===== Device Agent + cached logo + ESC/POS helpers ===== */
const AGENT = 'http://127.0.0.1:17313';
const LPZ_DEFAULT_PRINTER_KEY = 'lineupz.default_printer';
const BIZ_NAME  = <?php echo json_encode($footerBizName ?: 'LineUpz'); ?>;
const LOGO_URL  = <?php echo json_encode($footerLogoUrl ?: ''); ?>;

/* Printer width:
   - 58mm printers ~384 dots, 80mm often 576. Set to 384 by default. */
const PRINTER_DOT_WIDTH = 384;
const RCPT_WIDTH = (PRINTER_DOT_WIDTH >= 500 ? 42 : 32);

/* --- tiny utils --- */
function getSavedPrinter(){ try{ return localStorage.getItem(LPZ_DEFAULT_PRINTER_KEY) || undefined; }catch(_){ return undefined; } }
async function agentPost(path, body){
  const r = await fetch(AGENT+path, {
    method:'POST', mode:'cors', cache:'no-store',
    headers:{ 'Content-Type':'application/json' },
    body: JSON.stringify(body||{})
  });
  if (!r.ok) throw new Error('HTTP '+r.status);
  return r.json();
}
// --- Drawer kick (ESC p 0 25 250) ---
async function drawerKick(){
  try {
    const hex = '1B700019FA';
    const printer = getSavedPrinter();          // use saved default if set
    await agentPost('/print/escpos', printer ? { printer, hex } : { hex });
  } catch (e) {
    console.warn('drawerKick failed:', e);
  }
}

function bytesToHex(u8){ return Array.from(u8).map(b=>b.toString(16).padStart(2,'0')).join('').toUpperCase(); }
function lineLR(left, right, w=RCPT_WIDTH){
  left = String(left); right = String(right);
  const space = Math.max(1, w - left.length - right.length);
  return left + ' '.repeat(space) + right;
}
function padRight(s,n){ s=String(s); return s.length>=n ? s.slice(0,n) : s + ' '.repeat(n-s.length); }

/* ===== Cached logo (localStorage + memory) ===== */
let __LPZ_LOGO_HEX_CACHE = null;
const __LPZ_THRESH = 180; // keep in sync with the rasterizer threshold below
const LOGO_CACHE_KEY = `lpz_logo_hex_${PRINTER_DOT_WIDTH}_${__LPZ_THRESH}_${LOGO_URL}`;

function u8ToHex(u8){ return Array.from(u8).map(b=>b.toString(16).padStart(2,'0')).join('').toUpperCase(); }
function hexToU8(hex){ const out=new Uint8Array(hex.length/2); for(let i=0;i<out.length;i++) out[i]=parseInt(hex.substr(i*2,2),16); return out; }

/** Return the ESC/POS GS v 0 raster block (Uint8Array), cached. */
async function getLogoBlockU8(){
  if (__LPZ_LOGO_HEX_CACHE) return hexToU8(__LPZ_LOGO_HEX_CACHE);
  try {
    const raw = localStorage.getItem(LOGO_CACHE_KEY);
    if (raw) { __LPZ_LOGO_HEX_CACHE = raw; return hexToU8(raw); }
  } catch (_) {}

  const u8 = await buildLogoBlock(); // pure generator below
  if (u8 && u8.length){
    const hex = u8ToHex(u8);
    __LPZ_LOGO_HEX_CACHE = hex;
    try { localStorage.setItem(LOGO_CACHE_KEY, hex); } catch (_) {}
    return u8;
  }
  return null;
}

/** Precompute the logo in idle time so printing is instant. */
function warmLogo(){
  if (!LOGO_URL) return;
  const idle = window.requestIdleCallback || ((fn)=>setTimeout(fn,300));
  idle(()=>{ getLogoBlockU8().catch(()=>{}); });
}

/* ---- Logo → ESC/POS raster image (GS v 0) — fixed alpha & white bg ---- */
async function buildLogoBlock() {
  if (!LOGO_URL) return null;
  try {
    const res = await fetch(LOGO_URL, { cache: 'no-store' });
    if (!res.ok) return null;
    const blob = await res.blob();
    const bmp  = await createImageBitmap(blob);

    // scale to printer width, keep aspect
    const scale = Math.min(1, PRINTER_DOT_WIDTH / bmp.width);
    const w = Math.min(PRINTER_DOT_WIDTH, Math.round(bmp.width * scale));
    const h = Math.round(bmp.height * scale);

    const cv = document.createElement('canvas');
    cv.width = w; cv.height = h;
    const cx = cv.getContext('2d', { willReadFrequently: true });

    // white background so transparent PNGs don't turn black
    cx.fillStyle = '#ffffff';
    cx.fillRect(0, 0, w, h);
    cx.drawImage(bmp, 0, 0, w, h);

    const img  = cx.getImageData(0, 0, w, h);
    const mono = new Uint8Array(Math.ceil(w/8) * h);
    const wb   = Math.ceil(w/8);

    const THRESH = __LPZ_THRESH; // must match the cache key above

    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        const i = (y*w + x) * 4;
        const r = img.data[i], g = img.data[i+1], b = img.data[i+2];
        const a = img.data[i+3] / 255;
        const lumRGB = 0.2126*r + 0.7152*g + 0.0722*b;
        const lum    = a * lumRGB + (1 - a) * 255; // alpha-aware over white
        if (lum < THRESH) mono[y*wb + (x>>3)] |= (0x80 >> (x & 7));
      }
    }

    // GS v 0  m xL xH yL yH <data>
    const m = 0; // normal
    const xL =  (wb     & 0xFF), xH = ((wb >> 8) & 0xFF);
    const yL =  (h      & 0xFF), yH = ((h  >> 8) & 0xFF);

    const out = new Uint8Array(8 + mono.length);
    out.set([0x1D,0x76,0x30, m, xL, xH, yL, yH], 0);
    out.set(mono, 8);
    return out;
  } catch {
    return null;
  }
}

/* Aggregate cart -> lines for a combined receipt */
function aggregateReceiptFromCheckout(checkoutByCustomer){
  const map = new Map(); let total=0;
  Object.values(checkoutByCustomer||{}).forEach(g=>{
    (g.items||[]).forEach(it=>{
      const name = String(it.serviceName||it.name||'Item');
      const unit = Number(it.priceCents||0);
      const qty  = Math.max(1, Number(it.qty||1));
      const key  = name+'|'+unit;
      if(!map.has(key)) map.set(key, { name, priceCents:unit, qty:0 });
      map.get(key).qty += qty; total += unit*qty;
    });
  });
  const items = Array.from(map.values());
  const gst   = Math.round(total/11), sub = Math.max(0,total-gst);
  return { items, subtotalC: sub, gstC: gst, totalC: total };
}

/* Build pretty ESC/POS receipt (logo, tidy layout, kick + cut) → HEX */
async function buildReceiptHexPretty({ biz=BIZ_NAME, items=[], subtotalC=0, gstC=0, totalC=0, method='CASH', changeC=0, txn='' }){
  const ESC=0x1B, GS=0x1D;
  const a=[]; const push=(...b)=>{ for(const x of b) a.push(x); };
  const pushTxt=t=>{ for(let i=0;i<t.length;i++) a.push(t.charCodeAt(i)); };
  const nl = ()=> a.push(0x0A);

  // init
  push(ESC,0x40);

  // logo (center) — cached
    // logo (center) — cached
    push(ESC,0x61,0x01);
    const logoU8 = await getLogoBlockU8();
    const hasLogo = !!(logoU8 && logoU8.length);
    if (hasLogo){
      a.push(...logoU8); nl();
    } else {
      // Only print business name if no logo available
      push(GS,0x21,0x11); push(ESC,0x45,0x01);
      pushTxt(String(biz).toUpperCase()); nl();
      push(GS,0x21,0x00); push(ESC,0x45,0x00);
    }


  // timestamp
  push(ESC,0x61,0x00); pushTxt((new Date()).toLocaleString()); nl();
  pushTxt('-'.repeat(RCPT_WIDTH)); nl();

  // items
  (items||[]).forEach(it=>{
    const name = String(it.name||'Item').replace(/\s+/g,' ').trim();
    pushTxt(padRight(name, RCPT_WIDTH)); nl();
    const qty = Math.max(1, Number(it.qty||1));
    const unit = centsToAUD(it.priceCents||0);
    const line = centsToAUD(qty*(it.priceCents||0));
    pushTxt(lineLR(`${qty} x ${unit}`, line, RCPT_WIDTH)); nl();
  });

  pushTxt('-'.repeat(RCPT_WIDTH)); nl();
  pushTxt(lineLR('Subtotal (excl. GST):', centsToAUD(subtotalC), RCPT_WIDTH)); nl();
  pushTxt(lineLR('GST (incl.):',          centsToAUD(gstC),      RCPT_WIDTH)); nl();
  push(ESC,0x45,0x01); pushTxt(lineLR('TOTAL PAID:', centsToAUD(totalC), RCPT_WIDTH)); nl(); push(ESC,0x45,0x00);
  pushTxt(lineLR('Payment:', String(method||'CASH').toUpperCase(), RCPT_WIDTH)); nl();
  if ((method||'').toUpperCase()==='CASH'){ pushTxt(lineLR('Change:', centsToAUD(changeC), RCPT_WIDTH)); nl(); }
  if (txn){ pushTxt(lineLR('Txn Group:', txn, RCPT_WIDTH)); nl(); }

  nl(); push(ESC,0x61,0x01); pushTxt('Thank you!'); nl(); pushTxt('Visit again soon.'); nl();
  nl(); nl();


  // Drawer kick only for CASH, then cut
  push(ESC,0x61,0x00);                     // left align
  if ((String(method || '').toUpperCase()) === 'CASH') {
    push(ESC,0x70,0x00,0x19,0xFA);         // ESC p 0 25 250 (kick)
  }
  nl(); nl();
  push(GS,0x56,0x41,0x10);                 // GS V 65 16 (partial cut)


  return bytesToHex(Uint8Array.from(a));
}

/* Print receipt via Device Agent */
async function printReceiptGroup({ checkoutByCustomer, changeCents=0, method='CASH', txnGroup='' }){
  const agg = aggregateReceiptFromCheckout(checkoutByCustomer);
  const hex = await buildReceiptHexPretty({
    biz: BIZ_NAME,
    items: agg.items,
    subtotalC: agg.subtotalC,
    gstC: agg.gstC,
    totalC: agg.totalC,
    method,
    changeC: Number(changeCents||0),
    txn: txnGroup||''
  });
  const printer = getSavedPrinter(); // undefined => default system printer
  try { await agentPost('/print/escpos', { printer, hex }); } catch(e){ console.warn('Receipt print failed:', e); }
}


function recordPaymentHandler(){
  // Deprecated flow; primary button now always drives terminal.
  startCardFlow();
}
// (intentionally nothing else here)
function pollLinklySession() {
  if (!cardFlow.sessionId) return;

  cardFlow.pollAttempts = (cardFlow.pollAttempts || 0) + 1;

  $.getJSON(window.location.pathname + '?action=linkly_poll', {
    session_id: cardFlow.sessionId
  }).done(function(resp) {
    if (!resp || !resp.ok) return;

    if (resp.state === 'pending') {
      // Timeout after ~3 minutes of nothing (Linkly recommends error recovery here)
      if (cardFlow.pollAttempts >= 60) {
        clearCardFlowTimer();
        cardFlow.inProgress = false;
        $('#coCardAlert')
          .removeClass('alert-warning')
          .addClass('alert-danger')
          .text('Timed out waiting for the terminal. Please check the Linkly device.')
          .show();
        $('#coPrimaryBtn')
          .prop('disabled', false)
          .text('Try Card Again')
          .off('click')
          .on('click', startCardFlow);
      }
      return;
    }

    // state === 'done'
    clearCardFlowTimer();
    cardFlow.inProgress = false;

    if (!resp.approved) {
      // Reuse your big DECLINED banner helper
      showDeclined('FAILED', resp.response_text || null);
      return;
    }

    const extRef = resp.host_ref || resp.rrn || resp.rfn || '';

    // Same pattern as Square: mark each order in the group as paid (CARD)
    const ops = [];
    Object.entries(checkoutByCustomer).forEach(function([key, group]) {
      const isQS = (key === String(QUICKSALE_ID));
      if (isQS) {
        ops.push($.ajax({
          url:  window.location.pathname + '?action=qs_mark_paid',
          type: 'POST',
          contentType: 'application/json',
          data: JSON.stringify({
            payment_method: 'card',
            external_ref:   extRef,
            txn_group:      checkoutTxnGroup,
            staff_id:       (quickSaleStaff && quickSaleStaff.id) || null
          })
        }));
      } else {
        ops.push($.ajax({
          url:  window.location.pathname + '?action=cart_mark_paid',
          type: 'POST',
          contentType: 'application/json',
          data: JSON.stringify({
            customer_id:   Number(key),
            queue_id:      group.queueId,
            payment_method:'card',
            external_ref:  extRef,
            txn_group:     checkoutTxnGroup
          })
        }));
      }
    });

    $.when.apply($, ops).done(function () {
      // Print via LineUpz printer (ESC/POS) – same as Square CARD path
      (async () => {
        try {
          await printReceiptGroup({
            checkoutByCustomer,
            changeCents: 0,
            method: 'CARD',
            txnGroup: checkoutTxnGroup
          });
        } catch (_) {}
      })();

      afterPaymentSuccessUI('Card approved ✓', 0, 'CARD');
    }).fail(function () {
      $('#coCardAlert')
        .removeClass('alert-warning')
        .addClass('alert-danger')
        .text('Paid on terminal, but failed to record in POS. Please refresh.')
        .show();
      $('#coPrimaryBtn')
        .prop('disabled', false)
        .text('Try Card Again')
        .off('click')
        .on('click', startCardFlow);
    });

  }).fail(function () {
    // network blip while polling – just try again next tick
  });
}

function cancelLinklyFlow() {
  if (!cardFlow.inProgress) return;

  clearCardFlowTimer();
  cardFlow.inProgress = false;

  $('#coCardAlert')
    .removeClass('alert-warning')
    .addClass('alert-danger')
    .text('Card flow cancelled. You can start again or take CASH.')
    .show();

  $('#coPrimaryBtn')
    .prop('disabled', false)
    .text('Try Card Again')
    .off('click')
    .on('click', startCardFlow);
}

function pollCardStatus(checkoutId, done){
  let tries = 0, maxTries = 120; // ~6–8 minutes max
  const timer = setInterval(() => {
    $.getJSON(window.location.pathname + '?action=sq_terminal_status', { id: checkoutId })
      .done(s => {
        if (!s || !s.ok) return;
        const st = s.status;
        if (st === 'COMPLETED' || st === 'CANCELED' || st === 'FAILED' || st === 'EXPIRED') {
          clearInterval(timer);
          done(st, s.payment_ids || [], s.cancel_reason || null);
        } else if (++tries >= maxTries) {
          clearInterval(timer);
          done('EXPIRED', []);
        }
      })
      .fail(() => {
        if (++tries >= maxTries) { clearInterval(timer); done('FAILED', []); }
      });
  }, 3000);
  return timer; // ← we return it so callers can clear it
}
function startCardFlow(){
  // Don't stack requests
  if (cardFlow.inProgress) return;
  $('#cardDeclinedBanner').hide();

  // If offline, don't try to talk to Square/Linkly
    if (window.APP_ONLINE === false) {
      var needsOnline = !!window.EFTPOS_NEEDS_ONLINE;
      var msg = needsOnline
        ? 'EFTPOS offline due to no internet. Please restart your Wi-Fi and try again. In the meantime, you can accept CASH.'
        : 'You are offline. Use your EFTPOS terminal in standalone mode for now.';
    
      $('#coCardAlert')
        .removeClass('alert-warning')
        .addClass('alert-danger')
        .text(msg)
        .show();
      return;
    }


  const provider = (window.PREFERRED_EFTPOS || '').toLowerCase();
  // treat any value containing "linkly" as Linkly
  if (provider.indexOf('linkly') !== -1) {
    startLinklyFlow();
  } else {
    // default / fallback: Square Terminal
    startSquareFlow();
  }
}


/* Original Square flow extracted into its own function */
function startSquareFlow(){
  if (cardFlow.inProgress) return;
  $('#cardDeclinedBanner').hide();

  const totalCents = Number($('#coTotal').attr('data-total-cents') || 0);
  if (!totalCents) {
    $('#coCardAlert').removeClass('alert-warning').addClass('alert-danger')
      .text('Nothing to charge.').show();
    return;
  }

  $('#coCardAlert').removeClass('alert-danger').addClass('alert-warning')
    .text('Sending to terminal…').show();

  // while running: primary = Cancel on Terminal
  $('#coPrimaryBtn').prop('disabled', false).text('Cancel on Terminal')
    .off('click').on('click', cancelTerminalCheckout);

  $.getJSON(window.location.pathname + '?action=sq_ready').done(function(rdy){
    if (!rdy || !rdy.ok || !rdy.ready){
      $('#coCardAlert').removeClass('alert-warning').addClass('alert-danger')
        .text('No terminal linked. Connect one in Square Terminal Setup.').show();
      rebindPrimaryToRecord && rebindPrimaryToRecord();
      return;
    }

    $.ajax({
      url: window.location.pathname + '?action=sq_terminal_checkout',
      type: 'POST',
      contentType: 'application/json',
      data: JSON.stringify({
        amount_cents: totalCents,
        txn_group: checkoutTxnGroup
      })
    }).done(function(resp){
      if (!resp || !resp.ok || !resp.checkout_id){
        $('#coCardAlert').removeClass('alert-warning').addClass('alert-danger')
          .text('Failed to start terminal checkout.').show();
        rebindPrimaryToRecord && rebindPrimaryToRecord();
        return;
      }

      cardFlow.inProgress = true;
      cardFlow.checkoutId = resp.checkout_id;

      $('#coCardAlert').removeClass('alert-danger').addClass('alert-warning')
        .text('Waiting for customer on the terminal…').show();

      cardFlow.timer = pollCardStatus(resp.checkout_id, function(status, paymentIds, cancelReason){
        clearCardFlowTimer();
        cardFlow.inProgress = false;

        if (status === 'COMPLETED'){
          const extRef = (Array.isArray(paymentIds) && paymentIds.length)
            ? paymentIds[0]
            : resp.checkout_id;

          // mark all sub-orders as paid (CARD), then print, then green box
          const ops = [];
          Object.entries(checkoutByCustomer).forEach(function([key, group]){
            const isQS = (key === String(QUICKSALE_ID));
            if (isQS) {
              ops.push($.ajax({
                url: window.location.pathname + '?action=qs_mark_paid',
                type:'POST',
                contentType:'application/json',
                data: JSON.stringify({
                  payment_method: 'card',
                  external_ref:   extRef,
                  txn_group:      checkoutTxnGroup,
                  staff_id:       (quickSaleStaff && quickSaleStaff.id) || null
                })
              }));
            } else {
              ops.push($.ajax({
                url: window.location.pathname + '?action=cart_mark_paid',
                type:'POST',
                contentType:'application/json',
                data: JSON.stringify({
                  customer_id: Number(key),
                  queue_id:    group.queueId,
                  payment_method:'card',
                  external_ref: extRef,
                  txn_group:    checkoutTxnGroup
                })
              }));
            }
          });

          $.when.apply($, ops).done(function(){
            (async () => { try {
              await printReceiptGroup({
                checkoutByCustomer,
                changeCents: 0,
                method: 'CARD',
                txnGroup: checkoutTxnGroup
              });
            } catch(_){}})();

            afterPaymentSuccessUI('Card approved ✓', 0, 'CARD');
          }).fail(function(){
            $('#coCardAlert').removeClass('alert-warning').addClass('alert-danger')
              .text('Paid on terminal, but failed to record in POS. Please refresh.').show();
            rebindPrimaryToRecord && rebindPrimaryToRecord();
          });

        } else {
          // big banner + try-again
          showDeclined(status, cancelReason || null);
        }
      });

    }).fail(function(){
      $('#coCardAlert').removeClass('alert-warning').addClass('alert-danger')
        .text('Could not reach Square. Check internet.').show();
      rebindPrimaryToRecord && rebindPrimaryToRecord();
    });
  }).fail(function(){
    $('#coCardAlert').removeClass('alert-warning').addClass('alert-danger')
      .text('Could not check terminal link.').show();
    rebindPrimaryToRecord && rebindPrimaryToRecord();
  });
}

/* New async Linkly flow – POS talks to our PHP, PHP talks async to Linkly */
function startLinklyFlow() {
  if (cardFlow.inProgress) return;
  $('#cardDeclinedBanner').hide();

  const totalCents = Number($('#coTotal').attr('data-total-cents') || 0);
  if (!totalCents) {
    $('#coCardAlert').removeClass('alert-warning').addClass('alert-danger')
      .text('Nothing to charge.').show();
    return;
  }

  // If we’re offline at all, don’t even try
  if (window.APP_ONLINE === false) {
    $('#coCardAlert')
      .removeClass('alert-warning')
      .addClass('alert-danger')
      .text('EFTPOS needs internet. Use CASH or standalone terminal while offline.')
      .show();
    return;
  }

  cardFlow.inProgress   = true;
  cardFlow.sessionId    = null;
  cardFlow.pollAttempts = 0;
  clearCardFlowTimer();

  $('#coCardAlert')
    .removeClass('alert-danger')
    .addClass('alert-warning')
    .text('Sending to Linkly terminal…')
    .show();

  // Primary button becomes "Cancel" for this flow (local cancel – stops polling)
  $('#coPrimaryBtn')
    .prop('disabled', false)
    .text('Cancel')
    .off('click')
    .on('click', cancelLinklyFlow);

  // Quick sanity check that Linkly is wired
  $.getJSON(window.location.pathname + '?action=linkly_ready')
    .done(function(info) {
      if (!info || !info.ok || !info.ready) {
        cardFlow.inProgress = false;
        clearCardFlowTimer();
        $('#coCardAlert')
          .removeClass('alert-warning')
          .addClass('alert-danger')
          .text('Linkly Cloud is not connected. Open Settings → Linkly Cloud to pair your terminal.')
          .show();

        // fall back to cash
        $('#coPrimaryBtn')
          .prop('disabled', false)
          .text('Record Cash')
          .off('click')
          .on('click', recordCashPayment);
        return;
      }

      // Kick off async purchase from PHP
      $.ajax({
        url:  window.location.pathname + '?action=linkly_purchase',
        type: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({
          amount_cents: totalCents,
          txn_group:    checkoutTxnGroup
        })
      }).done(function(resp) {
        if (!resp || !resp.ok || !resp.session_id) {
          cardFlow.inProgress = false;
          clearCardFlowTimer();
          $('#coCardAlert')
            .removeClass('alert-warning')
            .addClass('alert-danger')
            .text(resp && resp.error ? ('Linkly error: ' + resp.error) : 'Failed to start Linkly transaction.')
            .show();

          $('#coPrimaryBtn')
            .prop('disabled', false)
            .text('Try Card Again')
            .off('click')
            .on('click', startCardFlow);
          return;
        }

        // We have a Linkly sessionId – now just poll our own PHP for the notification result
        cardFlow.sessionId = resp.session_id;
        cardFlow.pollAttempts = 0;

        $('#coCardAlert')
          .removeClass('alert-danger')
          .addClass('alert-warning')
          .text('Waiting for customer on the terminal…')
          .show();

        // Start polling once every 3 seconds, up to ~3 minutes
        clearCardFlowTimer();
        cardFlow.timer = setInterval(pollLinklySession, 3000);

      }).fail(function() {
        cardFlow.inProgress = false;
        clearCardFlowTimer();
        $('#coCardAlert')
          .removeClass('alert-warning')
          .addClass('alert-danger')
          .text('Could not reach Linkly Cloud. Check internet and try again.')
          .show();

        $('#coPrimaryBtn')
          .prop('disabled', false)
          .text('Try Card Again')
          .off('click')
          .on('click', startCardFlow);
      });
    })
    .fail(function() {
      cardFlow.inProgress = false;
      clearCardFlowTimer();
      $('#coCardAlert')
        .removeClass('alert-warning')
        .addClass('alert-danger')
        .text('Could not check Linkly connection.')
        .show();

      $('#coPrimaryBtn')
        .prop('disabled', false)
        .text('Record Cash')
        .off('click')
        .on('click', recordCashPayment);
    });
}



function afterPaymentSuccessUI(message, changeCents, method){
  const combinedTotalCents = computeCombinedTotalCents();
  const preEmail = ($('#coEmail').val() || '').trim();

  // mark UI paid + clear local cart
  Object.entries(checkoutByCustomer).forEach(([key, group]) => {
    const keyStr = String(key);

    if (keyStr === String(QUICKSALE_ID)) {
      // Quick Sale
      cartStatusCache[QUICKSALE_ID] = 'paid';
    } else if (/^\d+$/.test(keyStr)) {
      // Normal online customer (numeric id)
      const idNum = Number(keyStr);
      cartStatusCache[idNum] = 'paid';
      updateAllRowsForCustomer(idNum, $row => {
        const $nameEl = $row.find('.font-weight-bold').first();
        setBadge($nameEl, 'paid');
        applyCartButtonState($row, 'paid');
      });
    } else {
      // Offline temp check-in (e.g. "off_...") — mark its offline card as paid
      markOfflinePaidForGroup(keyStr);
    }
  });

  persistStatus();
  cart.items = [];
  renderCart();


  const $totalRow = $('#coTotal').closest('.d-flex');
  $totalRow.hide();
  $('.method-tiles, #coCashSection, .email-header, #coEmail, #coEmailKeypad, #coCardAlert, hr').hide();

    $('#coSuccess').html(`
      <div class="alert alert-success mb-0">
        <div class="approved-stamp">${method === 'CARD' ? 'APPROVED' : 'PAID'}</div>
        <div class="d-flex justify-content-between align-items-end">
          <div><strong>${message}</strong></div>
          <div class="co-change-big">
            ${method === 'CASH' ? 'Change: ' + centsToAUD(changeCents) : centsToAUD(combinedTotalCents)}
          </div>
        </div>
    
        <div class="mt-3">
          <label class="mb-1">Email for receipt (optional)</label>
          <div class="input-group">
            <input type="email" class="form-control" id="coEmailInSuccess" placeholder="customer@email.com" value="${preEmail.replace(/"/g,'&quot;')}">
            <div class="input-group-append"><button class="btn btn-light" id="coEmailSaveBtn" type="button">Save</button></div>
          </div>
          <div id="coEmailSaveHint" class="small text-muted mt-1" style="display:none;">Saved</div>
        </div>
      </div>
    `).show();


  $('#coEmailInSuccess').off('input.autosave').on('input.autosave', debounce(function(){
    const v = ($('#coEmailInSuccess').val() || '').trim();
    if (!looksLikeEmail(v)) return;
    saveEmailForAllActiveCustomers(v).done(function(){
      $('#coEmailSaveHint').text('Saved').stop(true,true).show().delay(900).fadeOut(250);
    });
  }, 600));

  $('#coEmailSaveBtn').off('click').on('click', function(){
    const emailVal = ($('#coEmailInSuccess').val() || '').trim();
    if (!emailVal){ $('#coEmailSaveHint').text('No email entered').show().delay(1500).fadeOut(300); return; }
    saveEmailForAllActiveCustomers(emailVal).done(function(){
      $('#coEmailSaveHint').text('Saved').show().delay(1200).fadeOut(300);
    }).fail(function(){
      $('#coEmailSaveHint').text('Save failed').show().delay(1500).fadeOut(300);
    });
  });

  $('#coPrimaryBtn').off('click')
    .text('Finish')
    .prop('disabled', false)
    .one('click', function(){
      const fallbackEmail = ($('#coEmailInSuccess').val() || '').trim();
      $.ajax({
        url: window.location.pathname + '?action=email_receipts',
        type: 'POST',
        contentType: 'application/json',
        dataType: 'json',
        data: JSON.stringify({ txn_group: checkoutTxnGroup, fallback_email: fallbackEmail })
      })
      .always(function(){ setTimeout(function(){ $('#checkoutModal').modal('hide'); }, 900); });
    });
}


// Show a tiny, non-blocking toast in the green success box
function coFlashNote(msg, isError){
  // host is the inner .alert if present, else #coSuccess itself
  const $host = $('#coSuccess .alert.alert-success, #coSuccess').first();
  if (!$host.length) return;
  let $note = $host.find('.mini-toast');
  if (!$note.length) $note = $('<div class="mini-toast"></div>').appendTo($host);
  $note.toggleClass('error', !!isError).text(msg).fadeIn(120);
  setTimeout(()=>{ $note.fadeOut(200); }, 1200);
}

function showSnack(msg, isError=false, ttl=1600){
  let $root = $('#snackRoot');
  if (!$root.length) $root = $('<div id="snackRoot"></div>').appendTo('body');

  const $snack = $('<div class="snack" role="status"></div>')
    .toggleClass('error', !!isError)
    .text(String(msg || ''));

  $root.append($snack);
  // animate in
  requestAnimationFrame(()=> $snack.addClass('show'));
  // animate out + remove
  setTimeout(()=> $snack.removeClass('show'), ttl);
  setTimeout(()=> $snack.remove(), ttl + 220);
}
// When offline, swap blocking alert() popups for a small toast so the page doesn't "freak out".
(function(){
  const origAlert = window.alert;
  let lastOfflineAlert = 0;

  window.alert = function(msg){
    if (window.APP_ONLINE === false) {
      const now = Date.now();
      if (typeof showSnack === 'function' && (now - lastOfflineAlert > 2000)) {
        lastOfflineAlert = now;
        showSnack(String(msg || 'You are offline.'), true, 2200);
      } else {
        console.log('Offline alert:', msg);
      }
      return;
    }
    return origAlert.call(window, msg);
  };
})();




function wirePrimaryForMethod(){
  const isCard = $('#tileCard').hasClass('active');
  if (isCard){
    $('#coPrimaryBtn').off('click')
      .text('Send to Terminal')
      .prop('disabled', false)
      .on('click', startCardFlow);
  } else {
    $('#coPrimaryBtn').off('click')
      .text('Record Cash')
      .prop('disabled', false)
      .on('click', recordCashPayment);
  }
}

// Restored CASH flow
function recordCashPayment(){
  const totalCents = Number($('#coTotal').attr('data-total-cents') || 0);
  if (totalCents <= 0){ alert('Nothing to record.'); return; }

  // keypad writes cents into data('cents'); fallback to parsing field if needed
  const tenderCents = Number(
    $('#coTender').data('cents') ||
    Math.round(parseFloat($('#coTender').val() || '0') * 100)
  );
  if (!Number.isFinite(tenderCents) || tenderCents < totalCents){
    alert('Tendered amount is less than total due.'); return;
  }

  const changeCents = Math.max(0, tenderCents - totalCents);
  $('#coChange').text(centsToAUD(changeCents));
  $('#coPrimaryBtn').prop('disabled', true).text('Recording…');

  // 🔌 OFFLINE: queue payment for later sync + print local receipt
  if (window.APP_ONLINE === false) {
    // Build an offline payment payload from checkoutByCustomer
    const pay = {
      id:           'pay_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8),
      createdAt:    Date.now(),
      business_id:  businessId,
      method:       'cash',
      txn_group:    checkoutTxnGroup,   // keep real group id so email_receipts will match
      change_cents: changeCents,
      customers:    []                  // entries for each customer / QS / offline temp
    };

    Object.entries(checkoutByCustomer || {}).forEach(([key, group]) => {
      const items = (group.items || []).map(it => ({
        service_id : it.serviceId,
        name       : it.serviceName,
        price_cents: Number(it.priceCents || 0),
        qty        : Number(it.qty || 1)
      })).filter(r => r.qty > 0);

      if (!items.length) return;

      const isQS = (key === String(QUICKSALE_ID));
      if (isQS) {
        // Quick Sale: anonymous
        pay.customers.push({
          type:     'qs',
          staff_id: (quickSaleStaff && quickSaleStaff.id) || null,
          items
        });
      } else {
        // Either a real customer_id OR an offline tempId from the offline check-in list
        const numericId = Number(key);
        if (Number.isFinite(numericId) && numericId > 0) {
          // Real customer (online, or already synced)
          pay.customers.push({
            type:        'customer',
            customer_id: numericId,
            queue_id:    group.queueId,
            items
          });
        } else {
          // Offline-only customer (tempId from offline check-in)
          pay.customers.push({
            type:     'offline',
            temp_id:  key,
            queue_id: group.queueId,
            items
          });
        }
      }
    });

    if (pay.customers.length) {
      offlinePayments.push(pay);
      saveOfflinePayments();
      if (typeof showSnack === 'function') {
        showSnack('Offline cash saved – will sync when back online.', false, 2200);
      }
    }

    // Print receipt + open drawer *now* (local only)
    (async () => {
      try {
        await printReceiptGroup({
          checkoutByCustomer,
          changeCents: changeCents,
          method: 'CASH',
          txnGroup: checkoutTxnGroup          // same id used when we sync
        });
      } catch (_) {}
      try { await drawerKick(); } catch (_) {}
    })();

    // UI behaves like a normal success but message says it *will* sync
    afterPaymentSuccessUI(
      'Offline cash taken (will sync when online).',
      changeCents,
      'CASH'
    );
    return;
  }

  // 🌐 ONLINE: original behaviour (update PHP + reports + drawer + receipt)
  const ops = [];
  Object.entries(checkoutByCustomer).forEach(([key, group]) => {
    const isQS = (key === String(QUICKSALE_ID));
    if (isQS){
      ops.push($.ajax({
        url: window.location.pathname + '?action=qs_mark_paid',
        type:'POST',
        contentType:'application/json',
        data: JSON.stringify({
          payment_method: 'cash',
          external_ref:   '',
          txn_group:      checkoutTxnGroup,
          staff_id:       (quickSaleStaff && quickSaleStaff.id) || null
        })
      }));
    } else {
      ops.push($.ajax({
        url: window.location.pathname + '?action=cart_mark_paid',
        type:'POST',
        contentType:'application/json',
        data: JSON.stringify({
          customer_id: Number(key),
          queue_id:    group.queueId,
          payment_method:'cash',
          external_ref: '',
          txn_group:    checkoutTxnGroup
        })
      }));
    }
  });

  $.when.apply($, ops).done(function(){
    const combinedTotalCents = computeCombinedTotalCents();
    cdPost('sale_cash', combinedTotalCents, `POS ${checkoutTxnGroup}`);

    (async () => {
      try {
        await printReceiptGroup({
          checkoutByCustomer,
          changeCents: changeCents,
          method: 'CASH',
          txnGroup: checkoutTxnGroup
        });
      } catch (_) {}
    })();

    afterPaymentSuccessUI('Payment recorded.', changeCents, 'CASH');
  }).fail(function(){
    alert('Failed to record cash payment. Please try again.');
    $('#coPrimaryBtn').prop('disabled', false).text('Record Cash');
  });
}


// Back-compat: keep the old name but delegate
function rebindPrimaryToRecord(){ wirePrimaryForMethod(); }



// ==== Checkout flow (per-customer, sequential) ====

const QUICKSALE_ID = 'QS';
let quickSaleStaff = null; // selected staff for the current Quick Sale session

// ─── Card flow state ───────────────────────────────────────────────────────────
let cardFlow = {
  inProgress: false,
  checkoutId: null,   // Square only
  sessionId:  null,   // Linkly async
  timer:      null,   // shared poll timer (Square or Linkly)
  pollAttempts: 0     // Linkly only
};

function showDeclined(status, reason){
  const word = status === 'FAILED' ? 'DECLINED' : (status === 'CANCELED' ? 'CANCELLED' : 'EXPIRED');
  $('#cardDeclinedBanner').text(word).show();
  $('#coCardAlert').removeClass('alert-warning').addClass('alert-danger')
    .text((word + (reason ? `: ${reason}` : ''))).show();

  // Primary becomes “Try Card Again”
  $('#coPrimaryBtn').prop('disabled', false).text('Try Card Again')
    .off('click').on('click', function(){
      $('#cardDeclinedBanner').hide();
      startCardFlow();  // retry
    });
}

function clearCardFlowTimer(){
  if (cardFlow.timer){ clearInterval(cardFlow.timer); cardFlow.timer = null; }
}

function cancelTerminalCheckout(){
  if (!cardFlow.inProgress || !cardFlow.checkoutId) return;
  const id = cardFlow.checkoutId;
  // tell server to cancel checkout → clears device screen
  $.post(window.location.pathname + '?action=sq_terminal_cancel', { id })
    .always(() => {
      clearCardFlowTimer();
      cardFlow.inProgress = false;
      cardFlow.checkoutId = null;
      $('#coCardAlert').removeClass('alert-warning').addClass('alert-danger')
        .text('Cancelled.').show();
      rebindPrimaryToRecord && rebindPrimaryToRecord();
    });
}


/* ==== Combined checkout (group payment) ==== */
let checkoutByCustomer = {};
let checkoutQueue = [];
let checkoutIdx = 0;
let checkoutTxnGroup = '';


function computeCombinedTotalCents() {
  return Object.values(checkoutByCustomer)
    .reduce((sum, g) => sum + g.items.reduce((s, it) => s + it.priceCents * it.qty, 0), 0);
}

function openCheckoutForCurrent() {
  const keys = Object.keys(checkoutByCustomer);
  const totalCents = computeCombinedTotalCents();
  
  $('#tileCash').addClass('active');
    $('#tileCard').removeClass('active');
    $('#coCashSection').show();
    $('#coCardAlert').hide();


  $('#coSuccess').hide().empty();
  $('#coCustomerName').text(`Combined payment — ${keys.length} order${keys.length > 1 ? 's' : ''}`);
  $('#coTotal').text(centsToAUD(totalCents)).attr('data-total-cents', totalCents);

  // default method = cash
  $('#tileCash').addClass('active'); 
  $('#tileCard').removeClass('active');
  $('#coCardAlert').hide(); 
  $('#coCashSection').show();

  // reset inputs
  $('#coTender').val('').data('cents', 0);
  $('#coChange').text(centsToAUD(0));
  $('#coEmail').val('');
  // Auto-save as the cashier types an email (pre-record section)
    $('#coEmail').off('input.autosave').on('input.autosave', debounce(function(){
      const v = ($(this).val() || '').trim();
      if (!looksLikeEmail(v)) return;                 // wait until it looks valid
      saveEmailForAllActiveCustomers(v);              // fire-and-forget; UI stays snappy
    }, 600));

  $('#coEmailKeypad').hide();
  // (#4) Prefill if there is exactly one non-Quick-Sale customer in the checkout
    (function tryPrefillEmail(){
      const ids = Object.keys(checkoutByCustomer).filter(k => k !== String(QUICKSALE_ID));
      if (ids.length !== 1) return;
      const onlyId = Number(ids[0]);
      $.getJSON(window.location.pathname + '?action=customer_email_get', { customer_id: onlyId })
        .done(resp => { if (resp && resp.ok && resp.email) $('#coEmail').val(resp.email); });
    })();


  // >>> Restore anything we might have hidden after success <<<
  const $totalRow = $('#coTotal').closest('.d-flex');
  $totalRow.show();
  $('.method-tiles').show();
  $('#coCashSection').show();
  $('.email-header, #coEmail, hr').show();
  $('#coCardAlert').hide();

  // (Keep chips hidden pre-record if you prefer)
  $('#coQuickCash').empty();              // or .hide() if you want them hidden pre-record
  $('.change-line').hide();

  renderQuickCash(totalCents);            // leave this if you still use chips
  // $('#coQuickCash').show();            // <- REMOVE this line if you keep chips hidden pre-record

  // Prefill email if exactly one non-QS customer…
  // ...
  // ...
  wirePrimaryForMethod(); // cash by default -> "Record Cash"
  $('#checkoutModal').modal('show');
}





// Toggle tiles; auto-start Card terminal flow
$('.method-tiles').off('click.method').on('click.method', '.method-tile', function(){
  if (cardFlow.inProgress) return;
  $('.method-tile').removeClass('active');
  $(this).addClass('active');

  const method = $(this).data('method');
  if (method === 'cash'){
    $('#coCashSection').show();
    $('#coCardAlert').hide().text('').removeClass('alert-danger alert-warning');
    $('#cardDeclinedBanner').hide();
    wirePrimaryForMethod();               // primary = "Record Cash"
  } else {
    $('#coCashSection').hide();
    $('#cardDeclinedBanner').hide();
    wirePrimaryForMethod();               // primary = "Send to Terminal"
    startCardFlow();                      // auto-send to terminal
  }
});





// On-screen numeric keypad
$('#coNumKeys').off('click').on('click', '.key', function(){
  const $in = $('#coTender');
  let cents = Number($in.data('cents') || 0);

  const val = $(this).attr('data-val');
  const act = $(this).attr('data-action');

  if (act === 'back') {
    // remove last digit
    cents = Math.floor(cents / 10);
  } else if (val) {
    if (val === '00') {
      // append two zeros
      cents = cents * 100;
    } else {
      const digit = Number(val);
      if (Number.isInteger(digit) && digit >= 0 && digit <= 9) {
        // append single digit
        cents = cents * 10 + digit;
      }
    }
  }

  // clamp (optional safety)
  if (cents < 0) cents = 0;

  // write display + fire input for change calc
  $in.data('cents', cents)
     .val((cents/100).toFixed(2))
     .trigger('input');
});

// Visual press feedback (mouse + touch + pen)
$('#coNumKeys')
  .off('pointerdown.keypress pointerup.keypress pointercancel.keypress ' +
       'mousedown.keypress mouseup.keypress touchstart.keypress touchend.keypress')
  .on('pointerdown.keypress mousedown.keypress touchstart.keypress', '.key', function () {
    $(this).addClass('pressed').attr('aria-pressed','true');
  })
  .on('pointerup.keypress pointercancel.keypress mouseup.keypress touchend.keypress', '.key', function () {
    $(this).removeClass('pressed').attr('aria-pressed','false');
  });



// Email keypad toggle & keys
$('#toggleEmailKeys').on('click', function(){ $('#coEmailKeypad').toggle(); });

$('#coEmailKeypad').on('click', '.ekey', function(){
  const $e = $('#coEmail');
  let v = $e.val() || '';
  const ch = $(this).data('ch');
  const action = $(this).data('action');
  if (action === 'back') v = v.slice(0,-1);
  else if (action === 'clear') v = '';
  else if (action === 'space') v += ' ';
  else if (ch) v += ch;
  $e.val(v);
});

$('.domain-chip').on('click', function(){
  const $e = $('#coEmail');
  const dom = $(this).data('dom') || '';
  let v = $e.val() || '';
  if (!v.includes('@')) v = (v + dom).replace(/\s+/g,'');
  else if (!v.endsWith(dom)) v = v.slice(0, v.indexOf('@')) + dom;
  $e.val(v);
});


$('#coTender').off('input').on('input', function(){
  const totalCents  = Number($('#coTotal').attr('data-total-cents') || 0);
  const tenderCents = Number($(this).data('cents') || 0);
  const changeCents = Math.max(0, tenderCents - totalCents);
  $('#coChange').text(centsToAUD(changeCents));
});





/* ============================
   Service Picker (Modal)
============================ */
let pickerCustomer = null;
// === Edit mode globals ===
let editMode   = false;        // are we editing an existing cart?
let editTarget = null;         // { isQS, customerId, queueId }
// Discount/Q-token context for the currently open Service Picker
let pickerQTokens = 0;         // customer's current balance in this picker
let pickerHasQFeature = false; // business-level feature flag (from profile)
// Is the currently open Service Picker for Quick Sale?
let pickerIsQuickSale = false;
// Token budget for this picker session (NEW selections only)
let pickerTokenBudget   = 0; // remaining tokens available (wallet minus tokens already used by existing discount lines)
let pickerTokenSelected = 0; // tokens reserved by NEW increments during this modal session

// ===== OFFLINE: add items from picker into local cart only (no server) =====
// ===== OFFLINE: add items from picker into local cart only (no server) =====
function offlineAddFromPicker(selected){
  if (!pickerCustomer) {
    $('#servicePickerModal').modal('hide');
    return;
  }

  const isQS = pickerIsQuickSale || String(pickerCustomer.id) === String(QUICKSALE_ID);

  // For Quick Sale offline: drop token-required + "Redo" discounts
  if (isQS && Array.isArray(selected)) {
    selected = selected.filter(s => {
      if (!s.is_discount) return true;
      const needsTokens = Number(s.discount_qtokens || 0) > 0;
      const isRedo      = /\bredo\b/i.test(String(s.item_name || ''));
      return !(needsTokens || isRedo);
    });
  }

  selected = Array.isArray(selected) ? selected : [];

  // Split new selection: normal items vs discount items
  const normals   = selected.filter(s => !s.is_discount);
  const discounts = selected.filter(s =>  s.is_discount);

  let cid, qid, label;

  if (isQS) {
    // Quick Sale offline → local-only "QS" cart
    cid   = QUICKSALE_ID;
    qid   = businessId;
    label = 'Quick Sale';
  } else {
    cid   = pickerCustomer.id;
    qid   = Number(pickerCustomer.queue_id || businessId || 0);
    label = nameFrom(pickerCustomer);
  }

  if (!cid || !qid) {
    alert('Missing queue reference for this client.');
    return;
  }

  const normalsPayload = normals.map(s => ({
    service_id : s.id,
    name       : s.item_name,
    price_cents: Number(s.variation_price_amount || 0),
    qty        : Math.max(1, Number(s.qty || 1))
  })).filter(r => r.qty > 0);

  // Base subtotal for simple % discounts using this new selection only
  const baseSub = normalsPayload.reduce((sum, r) => sum + r.price_cents * r.qty, 0);

  const discountPayload = discounts.map(d => {
    const qty   = Math.max(1, Number(d.qty || 1));
    const dtype = d.discount_type;
    const val   = Number(d.discount_value || 0);
    let perOff  = 0;

    if (dtype === 'amount') {
      perOff = val;
    } else if (dtype === 'percent') {
      const pct = Math.max(0, Math.min(100, val));
      perOff = Math.floor(baseSub * pct / 100);
    }
    if (perOff <= 0) return null;

    return {
      service_id : d.id,
      name       : `DISCOUNT — ${d.item_name}`,
      price_cents: -perOff,
      qty
    };
  }).filter(Boolean);

  const all = normalsPayload.concat(discountPayload);
  if (!all.length) {
    $('#servicePickerModal').modal('hide');
    return;
  }

  // Merge into local cart (supports normal customers + "QS")
  all.forEach(svc => {
    const existing = cart.items.find(it =>
      String(it.customerId) === String(cid) &&
      Number(it.queueId)    === Number(qid) &&
      Number(it.serviceId)  === Number(svc.service_id)
    );
    if (existing) {
      existing.qty += svc.qty;
    } else {
      cart.items.push({
        customerId:   cid,
        customerName: label,
        serviceId:    svc.service_id,
        serviceName:  svc.name,
        priceCents:   svc.price_cents,
        qty:          svc.qty,
        queueId:      qid
      });
    }
  });

  renderCart();

  // Mark this customer / QS as "In Cart" in the UI
  cartStatusCache[cid] = 'pending';
  persistStatus();

  // Only try to touch visible rows for non-QS targets
  if (!isQS) {
    const numId = Number(cid);

    if (Number.isFinite(numId) && numId > 0) {
      // Normal online customer – same as before
      updateAllRowsForCustomer(numId, $row => {
        const $n = $row.find('.font-weight-bold').first();
        setBadge($n, 'pending');
        applyCartButtonState($row, 'pending');
      });
    } else {
      // Offline-served temp customer (e.g. "off_…") – update that card
      updateOfflineServedRowForTempId(String(cid), 'pending');
    }
  }


  // Clear any barcode strip for this session
  pendingScans.length = 0;
  renderScanStrip();

  $('#servicePickerModal').modal('hide');
}



function openServicePickerForCustomer(customer, force=false) {
  if (!force && (cartStatusCache[customer.id] === 'paid' || cartStatusCache[customer.id] === 'pending')) return;

  // resolve qid from visible row
  let qidForPicker = 0;
  $('.queue-item').each(function(){
    const $row = $(this);
    const $btn = $row.find('[data-id]').first();
    if ($btn.length && Number($btn.attr('data-id')) === Number(customer.id)) {
      qidForPicker = Number($row.attr('data-queue-id') || 0); return false;
    }
  });
  if (!qidForPicker && customer.queue_id) qidForPicker = Number(customer.queue_id);

  pickerCustomer = { ...customer, queue_id: (qidForPicker || customer.queue_id || businessId) };
  pickerIsQuickSale = false;

  $('#servicePickerCustomer').html('<strong>Customer:</strong> ' + $('<div/>').text(nameFrom(customer)).html());
  
    const isOffline = (window.APP_ONLINE === false);
    
      if (isOffline) {
        // Need services already cached from a previous online session
        if (!cachedServices || !Array.isArray(cachedServices) || !cachedServices.length) {
          $('#servicesContainer').html(
            '<div class="text-danger">Services are only available offline after this device has loaded them once while online.</div>'
          );
          $('#servicePickerModal').modal('show');
          return;
        }
    
        // Offline: treat everything as simple items (no Q-token / redo logic)
        pickerQTokens       = 0;
        pickerHasQFeature   = false;
        pickerTokenBudget   = 0;
        pickerTokenSelected = 0;
        pickerRedoAllowed   = false;
    
        // Pre-fill from LOCAL cart rows for this customer+queue (no server)
        const existingLocal = cart.items.filter(it =>
          Number(it.customerId) === Number(customer.id) &&
          Number(it.queueId)    === Number(qidForPicker || customer.queue_id || businessId)
        );
    
        renderServiceOptions(cachedServices);
    
        if (existingLocal.length) {
          $('#servicesContainer .svc-cell').each(function(){
            const svc = $(this).data('svc'); if (!svc) return;
            const match = existingLocal.find(it => Number(it.serviceId) === Number(svc.id));
            if (match) {
              const q = Number(match.qty || 1);
              $(this).data('base', q).data('count', q);
              $(this).find('.svc-ui').show().find('.svc-count').text(q);
            }
          });
        }
    
        applyScanEntriesToPicker();
        renderScanStrip();
        $('#servicePickerModal').modal('show');
        return;
      }


    const loadServices = $.getJSON(window.location.pathname + '?action=services')
      .then(function (resp) {
        if (resp && resp.ok && Array.isArray(resp.services)) {
          // keep cache fresh for offline use
          saveServicesCache(resp.services);
          return resp;
        }
        throw new Error('services load failed');
      });



  $.when(
    loadServices,
    $.getJSON(window.location.pathname + '?action=cart_status', { customer_id: customer.id, queue_id: qidForPicker || 0 }),
    $.getJSON(window.location.pathname + '?action=customer_profile_data', { customer_id: customer.id })
  )
  .done((svcResp, cartResp, profileResp) => {
    // Token context
    pickerQTokens = Number(profileResp?.[0]?.customer?.Q_token || 0);
    const biz = profileResp?.[0]?.business || {};
    pickerHasQFeature = Number(biz?.Q_token || 0) === 1;

// AFTER
    pickerRedoAllowed = false;
    try {
      const hdr = (profileResp?.[0]?.header) || {};
      const iso = hdr.redo_anchor_iso || hdr.last_served_prev_iso; // prefer anchor
      if (iso) {
        const last = new Date(String(iso).replace(' ', 'T'));
        pickerRedoAllowed = ((Date.now() - last.getTime()) / 86400000) <= 7;
      }
    } catch (_) { pickerRedoAllowed = false; }


    const services = (svcResp?.services ?? svcResp?.[0]?.services ?? cachedServices ?? []);
    const existingItems = (cartResp?.[0]?.cart?.items_json) || [];

    // token budget before render (existing discounts already “spent”)
    (function initTokenBudget(){
      let usedByExisting = 0;
      if (Array.isArray(existingItems) && existingItems.length){
        const tokPer = {};
        services.forEach(s => { tokPer[Number(s.id)] = Number(s.discount_qtokens || 0); });
        existingItems.forEach(it => {
          const sid = Number(it['service_id'] || 0);
          const per = tokPer[sid] || 0;
          if (per > 0) usedByExisting += per * Number(it['qty'] || 1);
        });
      }
      pickerTokenBudget   = Math.max(0, pickerQTokens - usedByExisting);
      pickerTokenSelected = 0;

    })();

    renderServiceOptions(services);
    
    // pre-fill existing cart lines first
    if (existingItems.length) {
      $('#servicesContainer .svc-cell').each(function(){
        const svc = $(this).data('svc'); if (!svc) return;
        const match = existingItems.find(it => Number(it['service_id']) === Number(svc.id));
        if (match) {
          const q = Number(match.qty || 1);
          $(this).data('base', q).data('count', q);
          $(this).find('.svc-ui').show().find('.svc-count').text(q);
        }
      });
    }
    
    // then apply any freshly scanned barcodes
    applyScanEntriesToPicker();
    renderScanStrip();


    $('#servicePickerModal').modal('show');
  })
  .fail(() => {
    $('#servicesContainer').html('<div class="text-danger">Failed to load services.</div>');
    $('#servicePickerModal').modal('show');
  });
}

// Open the SAME service picker, but in "edit" mode for either a customer or QS
function openEditItemsForGroup(groupKey){
  const isQS = (String(groupKey) === String(QUICKSALE_ID));

  // Resolve queue + label
  let queueId = businessId;
  let label   = isQS ? 'Quick Sale' : 'Customer';

  if (isQS) {
    pickerCustomer = { id: QUICKSALE_ID, queue_id: businessId };
  } else {
    $('.queue-item').each(function(){
      const $row = $(this);
      const $btn = $row.find('[data-id]').first();
      if ($btn.length && Number($btn.attr('data-id')) === Number(groupKey)) {
        queueId = Number($row.attr('data-queue-id') || businessId);
        const nm = $row.find('.font-weight-bold').first().text().trim();
        if (nm) label = nm;
        return false;
      }
    });
    if (label === 'Customer'){
      const anyRow = cart.items.find(it => Number(it.customerId) === Number(groupKey));
      if (anyRow){ queueId = anyRow.queueId || businessId; label = anyRow.customerName || label; }
    }
    pickerCustomer = { id: Number(groupKey), queue_id: Number(queueId) };
  }

  editMode          = true;
  editTarget        = isQS ? { isQS:true } : { isQS:false, customerId:Number(groupKey), queueId:Number(queueId) };
  pickerIsQuickSale = isQS;
  pickerRedoAllowed = isQS ? false : pickerRedoAllowed; // <-- QS edit = never allow Redo

  $('#servicePickerCustomer').html('<strong>Edit:</strong> ' + $('<div/>').text(label).html());
  $('#servicePickerAdd').text('Save Changes');

  const loadServices = $.getJSON(window.location.pathname + '?action=services')
    .then(function (resp) {
      if (resp && resp.ok && Array.isArray(resp.services)) {
        saveServicesCache(resp.services);
        return resp;
      }
      throw new Error('services load failed');
    });



  const loadExisting = isQS
    ? $.getJSON(window.location.pathname + '?action=qs_status')
    : $.getJSON(window.location.pathname + '?action=cart_status',
        { customer_id: Number(groupKey), queue_id: Number(queueId) });

  const loadProfile = isQS
    ? $.Deferred().resolve({ customer:{Q_token:0}, business:{Q_token:0}, header:{} }).promise()
    : $.getJSON(window.location.pathname + '?action=customer_profile_data', { customer_id: Number(groupKey) });

  $.when(loadServices, loadExisting, loadProfile).done((svcResp, cartResp, profResp) => {
    const services = (svcResp?.services ?? svcResp?.[0]?.services ?? cachedServices ?? []);
    const existing = (cartResp?.[0]?.cart?.items_json || cartResp?.cart?.items_json || []) || [];

    const pr = profResp?.[0] ?? profResp;
    pickerQTokens     = Number(pr?.customer?.Q_token || 0);
    pickerHasQFeature = Number(pr?.business?.Q_token || 0) === 1;

    // Redo window (<=7 days) — prefer redo_anchor_iso (ignored for QS)
    pickerRedoAllowed = isQS ? false : (function(){
      try {
        const hdr = (pr?.header) || {};
        const iso = hdr.redo_anchor_iso || hdr.last_served_prev_iso;
        if (!iso) return false;
        const last = new Date(String(iso).replace(' ', 'T'));
        return ((Date.now() - last.getTime()) / 86400000) <= 7;
      } catch(_) { return false; }
    })();

    // token budget pre-calc
    (function initTokenBudget(){
      if (isQS) { pickerTokenBudget = 0; pickerTokenSelected = 0; return; }
      let usedByExisting = 0;
      if (existing.length){
        const tokPer = {};
        services.forEach(s => { tokPer[Number(s.id)] = Number(s.discount_qtokens || 0); });
        existing.forEach(it => {
          const sid = Number(it['service_id'] || 0);
          const per = tokPer[sid] || 0;
          if (per > 0) usedByExisting += per * Number(it['qty'] || 1);
        });
      }
      pickerTokenBudget   = Math.max(0, pickerQTokens - usedByExisting);
      pickerTokenSelected = 0;
    })();

    renderServiceOptions(services);
    
    // Pre-fill counts into grid and mark base
    if (existing.length){
      $('#servicesContainer .svc-cell').each(function(){
        const svc = $(this).data('svc'); if (!svc) return;
        const match = existing.find(it => Number(it['service_id']) === Number(svc.id));
        if (match){
          const q = Number(match.qty || 1);
          $(this).data('base', q).data('count', q);
          $(this).find('.svc-ui').show().find('.svc-count').text(q);
        }
      });
    }
    
    // apply any queued scans to this editor
    applyScanEntriesToPicker();
    renderScanStrip();
    
    $('#servicePickerModal').modal('show');

  })
  .fail(() => {
    $('#servicesContainer').html('<div class="text-danger">Failed to load editor.</div>');
    $('#servicePickerModal').modal('show');
  });
}




function renderServiceOptions(services) {
  const $host = $('#servicesContainer').empty();

  if (!Array.isArray(services) || !services.length) {
    $host.html('<div class="text-muted">No services found for this business.</div>');
    return;
  }

  const items = services.filter(s => Number(s.active || 0) === 1);

  const withIdx    = items.filter(s => s.grid_index !== null && s.grid_index !== undefined && s.grid_index !== '');
  const withoutIdx = items.filter(s => s.grid_index === null || s.grid_index === undefined || s.grid_index === '');

  const cells = new Array(36).fill(null);
  withIdx.forEach(s => {
    const idx = Number(s.grid_index);
    if (Number.isInteger(idx) && idx >= 0 && idx < 500) {
      while (idx >= cells.length) cells.push(null);
      if (cells[idx] === null) cells[idx] = s; else withoutIdx.push(s);
    } else {
      withoutIdx.push(s);
    }
  });
  let k = 0;
  for (let i=0; i<cells.length && k<withoutIdx.length; i++) {
    if (cells[i] === null) cells[i] = withoutIdx[k++];
  }
  while (k < withoutIdx.length) cells.push(withoutIdx[k++]);

  const $grid = $('<div class="svc-grid"></div>');

  function hexToLuma(hex){
    let h = String(hex||'').replace('#','');
    if (h.length === 3) h = h.split('').map(c=>c+c).join('');
    const r = parseInt(h.substr(0,2)||'00',16),
          g = parseInt(h.substr(2,2)||'00',16),
          b = parseInt(h.substr(4,2)||'00',16);
    return (0.2126*r + 0.7152*g + 0.0722*b)/255;
  }

  cells.forEach((svc) => {
    if (!svc) { $grid.append('<div class="svc-cell empty"></div>'); return; }

    const isDisc      = Number(svc.is_discount || 0) === 1;
    const needsTokens = Number(svc.discount_qtokens || 0);
    const isRedo      = isDisc && /\bredo\b/i.test(String(svc.item_name || ''));
    const redoDisabled= isRedo && !pickerRedoAllowed;

    // QS: hide token-required discounts AND any "Redo" discount entirely
    if (pickerIsQuickSale && (isRedo || (isDisc && needsTokens > 0))) {
      $grid.append('<div class="svc-cell empty"></div>');
      return;
    }

    const $cell = $('<div class="svc-cell"></div>');

    const bg = svc.color_hex || '#EFEFEF';
    $cell.css('background', bg);
    $cell.addClass(hexToLuma(bg) > 0.7 ? 'svc-dark' : 'svc-light');

    const priceC = Number(svc.variation_price_amount || 0);
    const priceT = centsToAUD(priceC);

    const pills = [];
    if (Number(svc.is_primary||0) === 1) pills.push('<span class="badge badge-primary">Primary</span>');
    if (Number(svc.is_upsell ||0) === 1) pills.push('<span class="badge badge-success">Upsell</span>');
    if (isDisc)                            pills.push('<span class="badge badge-warning">Discount</span>');
    if (Number(svc.is_retail  ||0) === 1) pills.push('<span class="badge badge-info">Retail</span>');

    if (isDisc) {
      const dtype = String(svc.discount_type || 'none');
      const dval  = Number(svc.discount_value || 0);
      let discountLabel = '';
      if (dtype === 'amount')  discountLabel = `-${centsToAUD(dval)}${needsTokens ? ' • Q'+needsTokens : ''}`;
      if (dtype === 'percent') discountLabel = `-${dval}%${needsTokens ? ' • Q'+needsTokens : ''}`;
      if (discountLabel) pills.push(`<span class="badge badge-warning">${discountLabel}</span>`);
    }

    const $top = $('<div class="svc-top"/>').append(
      $('<div style="flex:1;">' +
          '<div class="svc-name"></div>' +
          '<div class="svc-badges"></div>' +
        '</div>')
    );
    $top.find('.svc-name').text(svc.item_name || 'Service');
    $top.find('.svc-badges').html(pills.join(' '));

    const $bottom = $('<div class="d-flex align-items-center justify-content-between"></div>');
    if (!isDisc) { $bottom.append(`<div class="svc-price">${priceT}</div>`); }
    else { $cell.addClass('is-discount'); }

    const $ui = $(`
      <div class="svc-ui">
        <span class="svc-count">1</span>
        <button type="button" class="svc-clear" title="Clear">
          <i class="fas fa-trash"></i>
        </button>
      </div>
    `).hide();

    $cell
      .data('svc', svc)
      .data('count', 0)
      .data('base',  0)
      .data('qt_per', needsTokens);

    // If Redo outside window, block it with a message
    if (redoDisabled) {
      $cell.addClass('disabled').css({ filter:'grayscale(100%)', opacity:.45, cursor:'not-allowed' });
    }
    // If token-required discount but wallet can’t cover it, show as grey (customer flow)
    if (!pickerIsQuickSale && isDisc && needsTokens > 0 && pickerHasQFeature && pickerQTokens < needsTokens) {
      $cell.addClass('disabled').css({ filter:'grayscale(100%)', opacity:.45, cursor:'not-allowed' });
    }

    function redraw() {
      const n = Number($cell.data('count') || 0);
      if (n > 0) { $ui.show().find('.svc-count').text(n); }
      else { $ui.hide(); }
    }

    $cell.on('click', function(e){
      if ($(e.target).closest('.svc-clear').length) return;

      if (pickerIsQuickSale && (isRedo || (isDisc && needsTokens > 0))) {
        // Should never happen because we skipped above, but keep a guard
        return;
      }

      if (redoDisabled) {
        if (typeof showSnack === 'function') showSnack('Redo is only available within 7 days of last visit.', true, 2200);
        else alert('Redo is only available within 7 days of last visit.');
        return;
      }

      const per   = Number($cell.data('qt_per') || 0);
      const base  = Number($cell.data('base') || 0);
      let   count = Number($cell.data('count') || 0);

      // Enforce wallet/budget for token-required discounts (customer flow)
      if (!pickerIsQuickSale && isDisc && per > 0) {
        const proposed    = count + 1;
        const incConsumes = proposed > base ? per : 0;
        if (incConsumes > 0 && (pickerTokenSelected + incConsumes) > pickerTokenBudget) {
          const left = Math.max(0, pickerTokenBudget - pickerTokenSelected);
          const msg  = `Not enough Q-tokens for this selection (need ${per}, available ${left}).`;
          if (typeof showSnack === 'function') showSnack(msg, true, 2200); else alert(msg);
          return;
        }
        if (incConsumes > 0) pickerTokenSelected += incConsumes;
      }

      count = Math.min(999, count + 1);
      $cell.data('count', count);
      redraw();
    });

    $ui.on('click', '.svc-clear', function(e){
      e.stopPropagation();
      const per   = Number($cell.data('qt_per') || 0);
      const base  = Number($cell.data('base') || 0);
      const count = Number($cell.data('count') || 0);

      if (!pickerIsQuickSale && isDisc && per > 0 && count > base) {
        const release = (count - base) * per;
        pickerTokenSelected = Math.max(0, pickerTokenSelected - release);
      }
      $cell.data('count', 0);
      redraw();
    });

    $cell.append($ui).append($top).append($bottom);
    $grid.append($cell);
  });

  $host.append($grid);
}


// === EDIT MODE: replace the cart with exactly the current selection ===
function saveEditChanges(selected){
  if (!pickerCustomer) { $('#servicePickerModal').modal('hide'); return; }

  const isQS = String(pickerCustomer.id) === String(QUICKSALE_ID);
  const qid  = Number(pickerCustomer.queue_id || businessId || 0);

  // Partition selection
  let normals   = selected.filter(s => !s.is_discount);
  let discounts = selected.filter(s =>  s.is_discount);

  // QS cannot carry token-required discounts
  if (isQS) {
    const blocked = discounts.filter(d => Number(d.discount_qtokens||0) > 0);
    if (blocked.length){
      const names = blocked.map(b => b.item_name).join(', ');
      showSnack(`Removed token-required discounts from Quick Sale: ${names}`, true, 2200);
    }
    discounts = discounts.filter(d => Number(d.discount_qtokens||0) === 0);
  }

  // Build add payload rows for NORMAL items
  const rowsFromNormals = normals.map(s => ({
    service_id: s.id,
    name: s.item_name,
    price_cents: Number(s.variation_price_amount || 0),
    qty: Number(s.qty || 1)
  }));

  // Compute negative lines for DISCOUNTS (percent applies to selected normals only)
  const baseSubtotal = rowsFromNormals.reduce((sum, r) => sum + r.price_cents * r.qty, 0);
  const discountNegLines = discounts.map(d => {
    let off = 0;
    if (d.discount_type === 'amount')  off = Math.max(0, Number(d.discount_value||0));
    if (d.discount_type === 'percent') off = Math.floor(baseSubtotal * Math.max(0,Math.min(100,Number(d.discount_value||0)))/100);
    return (off>0) ? {
      service_id: d.id,
      name      : `DISCOUNT — ${d.item_name}`,
      price_cents: -off,
      qty: 1,
      _qtokens: Number(d.discount_qtokens||0)
    } : null;
  }).filter(Boolean);

  const payload = rowsFromNormals.concat(
    discountNegLines.map(n => ({ service_id:n.service_id, name:n.name, price_cents:n.price_cents, qty:n.qty }))
  );

  // Disable Save while we work
  const $btn = $('#servicePickerAdd').prop('disabled', true).text('Saving...');

  // Little helpers
  function finishOK(){
    // reset edit state and close
    editMode = false; editTarget = null;
    $('#servicePickerModal').modal('hide');
    $btn.prop('disabled', false).text('Add to Cart');
  }
  function finishErr(msg){
    alert(msg||'Failed to save changes.');
    $btn.prop('disabled', false).text('Save Changes');
  }

  // ---------- QUICK SALE (clear -> add -> rehydrate local) ----------
  if (isQS){
    // Clear existing QS cart
    $.ajax({ url: window.location.pathname + '?action=qs_clear', type:'POST' })
      .done(function(){
        if (!payload.length){
          // nothing selected => empty
          cart.items = cart.items.filter(it => it.customerId !== QUICKSALE_ID);
          cartStatusCache[QUICKSALE_ID] = null; persistStatus();
          renderCart(); finishOK(); return;
        }
        // Add back the new items
        $.ajax({
          url: window.location.pathname + '?action=qs_add_items',
          type:'POST', contentType:'application/json',
          data: JSON.stringify({
            items: payload,
            staff_id: (quickSaleStaff && quickSaleStaff.id) || null   // credit QS items to staff
          })
        })

        .done(function(){
          // Rehydrate from server for exact state
          $.getJSON(window.location.pathname + '?action=qs_status').done(st => {
            cart.items = cart.items.filter(it => it.customerId !== QUICKSALE_ID);
            const row = st?.cart;
            if (row && Array.isArray(row.items_json) && row.items_json.length){
              addToCartLocalOnly(QUICKSALE_ID, 'Quick Sale', businessId, row.items_json);
              cartStatusCache[QUICKSALE_ID] = 'pending';
            } else {
              cartStatusCache[QUICKSALE_ID] = null;
            }
            persistStatus(); renderCart(); finishOK();
          });
        })
        .fail(()=> finishErr('Failed to add items to Quick Sale.'));
      })
      .fail(()=> finishErr('Failed to clear Quick Sale.'));
    return;
  }

  // ---------- CUSTOMER CART (clear -> tokens -> add -> rehydrate local) ----------
  // First, clear the customer's open cart; backend will refund Q-tokens for any existing discount lines.
  $.ajax({
    url: window.location.pathname + '?action=cart_clear',
    type:'POST', contentType:'application/json',
    data: JSON.stringify({ customer_id: Number(pickerCustomer.id), queue_id: qid })
  })
  .done(function(){
    if (!payload.length){
      // User removed everything
      cart.items = cart.items.filter(it => !(Number(it.customerId)===Number(pickerCustomer.id) && Number(it.queueId)===qid));
      cartStatusCache[Number(pickerCustomer.id)] = null; persistStatus();
      updateAllRowsForCustomer(Number(pickerCustomer.id), $r => {
        const $n=$r.find('.font-weight-bold').first();
        setBadge($n, null); applyCartButtonState($r, null);
      });
      renderCart(); finishOK(); return;
    }

    // Claim tokens for newly selected discount lines (after clear/refund)
    const claimAmt = discountNegLines.reduce((s,n)=> s + (n._qtokens||0), 0);
    const claim = (!claimAmt || !pickerHasQFeature)
      ? $.Deferred().resolve().promise()
      : $.ajax({
          url: window.location.pathname + '?action=customer_qtokens_claim',
          type:'POST', contentType:'application/json',
          data: JSON.stringify({ customer_id: Number(pickerCustomer.id), amount: claimAmt })
        });

    claim
    .fail(xhr => {
      if (xhr?.responseJSON?.error === 'insufficient') finishErr('Insufficient Q-tokens for selected discounts.');
      else finishErr('Failed to claim Q-tokens.');
    })
    .done(function(){
      // Add the new full set
      $.ajax({
        url: window.location.pathname + '?action=cart_add_items',
        type:'POST', contentType:'application/json',
        data: JSON.stringify({ customer_id: Number(pickerCustomer.id), queue_id: qid, items: payload })
      })
      .done(function(){
        // Rehydrate exact state from server
        $.getJSON(window.location.pathname + '?action=cart_status', { customer_id: Number(pickerCustomer.id), queue_id: qid })
          .done(resp => {
            const cartRow = resp?.cart;
            // replace local group precisely
            cart.items = cart.items.filter(it => !(Number(it.customerId)===Number(pickerCustomer.id) && Number(it.queueId)===qid));
            if (cartRow && Array.isArray(cartRow.items_json) && cartRow.items_json.length){
              addToCartLocalOnly(Number(pickerCustomer.id), nameFrom(pickerCustomer), qid, cartRow.items_json);
              cartStatusCache[Number(pickerCustomer.id)] = 'pending'; persistStatus();
              updateAllRowsForCustomer(Number(pickerCustomer.id), $r => {
                const $n=$r.find('.font-weight-bold').first();
                setBadge($n, 'pending'); applyCartButtonState($r, 'pending');
              });
            } else {
              cartStatusCache[Number(pickerCustomer.id)] = null; persistStatus();
              updateAllRowsForCustomer(Number(pickerCustomer.id), $r => {
                const $n=$r.find('.font-weight-bold').first();
                setBadge($n, null); applyCartButtonState($r, null);
              });
            }
            renderCart(); finishOK();
          });
      })
      .fail(function(){
        // best-effort refund if add failed after claiming
        if (claimAmt>0){
          $.ajax({
            url: window.location.pathname + '?action=customer_qtokens_add',
            type:'POST', contentType:'application/json',
            data: JSON.stringify({ customer_id: Number(pickerCustomer.id), amount: claimAmt })
          });
        }
        finishErr('Failed to add items to cart.');
      });
    });
  })
  .fail(()=> finishErr('Failed to clear existing cart.'));
} // <-- CLOSE saveEditChanges


// One-tap guarded handler for Service Picker → Add to Cart
$('#servicePickerAdd')
  .off('click.addOnce')
  .on('click.addOnce', function () {
    const $btn = $(this);
    if ($btn.data('busy')) return;
    if (!pickerCustomer) { $('#servicePickerModal').modal('hide'); return; }

    // Gather selections (+ base for delta math)
    const selected = [];
    $('#servicesContainer .svc-cell').each(function () {
      const svc  = $(this).data('svc'); if (!svc) return;
      const qty  = Number($(this).data('count') || 0);
      const base = Number($(this).data('base')  || 0);
      if (qty > 0) {
        selected.push({
          id: svc.id,
          item_name: svc.item_name,
          variation_price_amount: Number(svc.variation_price_amount || 0),
          qty, base,
          is_discount: Number(svc.is_discount || 0) === 1,
          discount_type: String(svc.discount_type || 'none'),
          discount_value: Number(svc.discount_value || 0),
          discount_qtokens: Number(svc.discount_qtokens || 0)
        });
      }
    });

    const isEditing = (editMode && editTarget);
    if (!isEditing && !selected.length) {
      alert('Please select at least one item.');
      return;
    }

    // 🔌 OFFLINE: local-only add, no PHP calls
    if (window.APP_ONLINE === false) {
      offlineAddFromPicker(selected);
      return;
    }

    const isQS = String(pickerCustomer.id) === String(QUICKSALE_ID);
    const qid  = Number(pickerCustomer.queue_id || businessId || 0);
    if (!isQS && !qid) { alert('Missing queue reference for this customer. Please refresh.'); return; }

    if (isEditing && editTarget) { return saveEditChanges(selected); }

    $btn.data('busy', true).prop('disabled', true).text('Adding…');
    const unlock = () => $btn.data('busy', false).prop('disabled', false).text('Add to Cart');

    // ... keep your existing ONLINE logic from here down ...


    // Split + compute only the DELTAS
    let normals   = selected.filter(s => !s.is_discount);
    let discounts = selected.filter(s =>  s.is_discount);

    // QS can’t take token-required discounts or “Redo”
    if (pickerIsQuickSale) {
      discounts = discounts.filter(d => !(/\bredo\b/i.test(d.item_name || '')) && !(d.discount_qtokens > 0));
    }

    const normalsDelta = normals
      .map(s => ({ ...s, delta: Math.max(0, Number(s.qty) - Number(s.base || 0)) }))
      .filter(s => s.delta > 0);

    const discountsDelta = discounts
      .map(s => ({ ...s, delta: Math.max(0, Number(s.qty) - Number(s.base || 0)) }))
      .filter(s => s.delta > 0);

    if (!normalsDelta.length && !discountsDelta.length) {
      $('#servicePickerModal').modal('hide');
      return unlock();
    }

    // Build rows for the increments only
    const rowsFromNormals = normalsDelta.map(s => ({
      service_id : s.id,
      name       : s.item_name,
      price_cents: Number(s.variation_price_amount || 0),
      qty        : s.delta
    }));

    // Need current cart to price percent discounts correctly
    const getExisting = isQS
      ? $.getJSON(window.location.pathname + '?action=qs_status').then(r => (r?.cart?.items_json || []))
      : $.getJSON(window.location.pathname + '?action=cart_status', { customer_id: Number(pickerCustomer.id), queue_id: qid })
          .then(r => (r?.cart?.items_json || []));

    getExisting
      .then(existingItems => {
        const existingSubtotal     = (existingItems || []).reduce((s, it) => s + (Number(it.price_cents||0) * Number(it.qty||1)), 0);
        const deltaNormalsSubtotal = rowsFromNormals.reduce((s, r) => s + (r.price_cents * r.qty), 0);
        const baseSubtotalForPct   = existingSubtotal + deltaNormalsSubtotal;

        const discountNegLines = discountsDelta.map(d => {
          let perOff = 0;
          if (d.discount_type === 'amount') {
            perOff = Math.max(0, d.discount_value|0);
          } else if (d.discount_type === 'percent') {
            const pct = Math.max(0, Math.min(100, d.discount_value|0));
            perOff = Math.floor(baseSubtotalForPct * pct / 100);
          }
          return (perOff > 0) ? {
            service_id : d.id,
            name       : `DISCOUNT — ${d.item_name}`,
            price_cents: -perOff,
            qty        : d.delta,
            _qtokens   : d.discount_qtokens|0
          } : null;
        }).filter(Boolean);

        // Claim tokens only for NEW discount increments (customer flow)
        function claimTokensIfNeeded() {
          if (isQS) return $.Deferred().resolve().promise();
          const totalTokens = discountNegLines.reduce((s, nl) => s + (Number(nl._qtokens||0) * Number(nl.qty||1)), 0);
          if (!pickerHasQFeature || totalTokens <= 0) return $.Deferred().resolve().promise();
          return $.ajax({
            url: window.location.pathname + '?action=customer_qtokens_claim',
            type:'POST',
            contentType:'application/json',
            data: JSON.stringify({ customer_id: Number(pickerCustomer.id), amount: totalTokens })
          });
        }

        claimTokensIfNeeded()
          .done(() => {
            const payload = rowsFromNormals.concat(
              discountNegLines.map(({service_id, name, price_cents, qty}) => ({ service_id, name, price_cents, qty }))
            );

            if (isQS) {
              $.ajax({
                url: window.location.pathname + '?action=qs_add_items',
                type:'POST', contentType:'application/json',
                data: JSON.stringify({
                  items: payload,
                  staff_id: (quickSaleStaff && quickSaleStaff.id) || null
                })
              })
              .done(() => {
                $.getJSON(window.location.pathname + '?action=qs_status').done(st => {
                  cart.items = cart.items.filter(it => it.customerId !== QUICKSALE_ID);
                  const row = st?.cart;
                  if (row && Array.isArray(row.items_json) && row.items_json.length){
                    addToCartLocalOnly(QUICKSALE_ID, 'Quick Sale', businessId, row.items_json);
                    cartStatusCache[QUICKSALE_ID] = 'pending';
                  } else {
                    cartStatusCache[QUICKSALE_ID] = null;
                  }
                  persistStatus(); renderCart(); pendingScans.length = 0; renderScanStrip();
                  $('#servicePickerModal').modal('hide');
                });
              })
              .fail(() => { alert('Failed to add to quick sale.'); unlock(); });
              return;
            }

            $.ajax({
              url: window.location.pathname + '?action=cart_add_items',
              type:'POST',
              contentType:'application/json',
              data: JSON.stringify({
                customer_id: Number(pickerCustomer.id),
                queue_id: qid,
                items: payload
              })
            })
            .done(() => {
              if (rowsFromNormals.length) {
                addToCart(pickerCustomer, rowsFromNormals.map(n => ({
                  id:n.service_id, item_name:n.name, variation_price_amount:n.price_cents, qty:n.qty
                })));
              }
              if (discountNegLines.length) {
                addToCartLocalOnly(Number(pickerCustomer.id), nameFrom(pickerCustomer), qid,
                  discountNegLines.map(nl => ({ service_id:nl.service_id, name:nl.name, price_cents:nl.price_cents, qty:nl.qty })));
              }
              pendingScans.length = 0; renderScanStrip();
              $('#servicePickerModal').modal('hide');
            })
            .fail(() => {
              const claimed = discountNegLines.reduce((s,nl)=> s + (Number(nl._qtokens||0) * Number(nl.qty||1)), 0);
              if (claimed > 0) {
                $.ajax({
                  url: window.location.pathname + '?action=customer_qtokens_add',
                  type:'POST', contentType:'application/json',
                  data: JSON.stringify({ customer_id: Number(pickerCustomer.id), amount: claimed })
                });
              }
              alert('Failed to add to cart.');
              unlock();
            });
          })
          .fail(() => unlock());
      })
      .fail(() => { alert('Could not load current cart state.'); unlock(); });
  });






/* ============================
   Staff Picker (Modal)
============================ */
let staffPickerResolved = false;
function openStaffPickerForCustomer(customer, onPicked, onCancel) {
  staffPickerResolved = false;
  $('#staffPickerFor').html(
    '<strong>Customer:</strong> ' +
    $('<div/>').text(customer.name || ('#' + customer.id)).html()
  );
  $('#staffPickerContainer').html('<div class="text-muted">Loading staff…</div>');

  fetchStaffSmart().done(function (resp) {
    let list = (resp && Array.isArray(resp.staff)) ? resp.staff : [];

    // 🧷 OFFLINE FALLBACK: if there are no staff and we are offline,
    // inject a synthetic "Offline staff" so POS can keep moving.
    if (!list.length && window.APP_ONLINE === false) {
      list = [{ id: 0, name: 'Offline staff (no timesheet)' }];
    }

    if (!list.length) {
      const msg = 'No staff found. Make sure staff have signed in on timesheet.';
      $('#staffPickerContainer').html('<div class="alert alert-warning mb-0">' + msg + '</div>');
      $('#staffPickerModal').modal('show');
      return;
    }

    const palette = [
      '#3390ff','#FF8D33','#8EDB70','#d7264c',
      '#26d7cc','#8e5bcb','#DCAF70','#c3c1c6',
      '#33FFB2','#0acbfa'
    ];
    const $grid = $('<div class="row"></div>');

    list.forEach(function (s, idx) {
      const color = palette[idx % palette.length];
      const isLight = (function () {
        let h = color.replace('#', '');
        if (h.length === 3) h = h.split('').map(c => c + c).join('');
        const r = parseInt(h.substr(0, 2), 16),
              g = parseInt(h.substr(2, 2), 16),
              b = parseInt(h.substr(4, 2), 16);
        return ((0.299 * r + 0.587 * g + 0.114 * b) / 255) > 0.7;
      })();
      const txtCls = isLight ? 'text-black' : 'text-white';
      const $col   = $('<div class="col-12"></div>');

      const secs   = Number(s.break_for_seconds || 0);
      const mins   = Math.floor(secs / 60);
      const durStr = mins >= 60 ? (Math.floor(mins / 60) + 'h ' + (mins % 60) + 'm')
                                : (mins + 'm');

      const isBreak           = Number(s.on_break || 0) === 1;
      const isOfflineFallback = (window.APP_ONLINE === false && (!s.id || s.id === 0));

      const $card = $(`
        <div class="staff-card ${txtCls} ${isBreak && !isOfflineFallback ? 'on-break' : ''}"
             style="background:${color}">
        </div>
      `).append($('<div/>').text(s.name));

      if (isBreak && !isOfflineFallback) {
        // Real staff on break → greyed out, not clickable
        $card
          .attr({ 'aria-disabled': 'true', 'tabindex': '-1', 'title': 'On break' })
          .append(`<div class="break-badge">On break · ${durStr}</div>`);
      } else {
        // Normal staff OR synthetic offline fallback
        $card.on('click', function () {
          // Synthetic offline-standin: do NOT hit the server, just resolve
          if (isOfflineFallback) {
            staffPickerResolved = true;
            $('#staffPickerModal').modal('hide');
            if (typeof onPicked === 'function') {
              onPicked({ id: 0, name: s.name });
            }
            return;
          }

          // Real staff – use sendOrQueueAjax so it queues when offline
          if ($card.data('busy')) return;
          $card.data('busy', true)
               .css('opacity', 0.6)
               .css('pointer-events', 'none');

          const payload = { customer_id: customer.id, staff_id: s.id };

          sendOrQueueAjax({
            url:  window.location.pathname + '?action=assign_staff',
            data: payload,
            description: 'Assign staff ' + s.name + ' to customer ' + customer.id,

            onSuccess: function (resp) {
              const savedName = (resp && resp.staff_name) ? resp.staff_name : s.name;
              staffPickerResolved = true;
              $('#staffPickerModal').modal('hide');

              if (typeof onPicked === 'function') {
                onPicked({ id: s.id, name: savedName });
              }
            },

            onError: function () {
              if (window.APP_ONLINE !== false) {
                alert('Failed to update staff assignment.');
                $card
                  .data('busy', false)
                  .css('opacity', '')
                  .css('pointer-events', '');
              } else {
                // Went offline mid-click: job is queued; still return locally
                staffPickerResolved = true;
                $('#staffPickerModal').modal('hide');
                if (typeof onPicked === 'function') {
                  onPicked({ id: s.id, name: s.name });
                }
              }
            }
          });
        });
      }

      $col.append($card);
      $grid.append($col);
    });

    $('#staffPickerContainer').empty().append($grid);
    $('#staffPickerModal').modal('show');
  })
  .fail(function () {
    $('#staffPickerContainer').html('<div class="text-danger">Failed to load staff list.</div>');
    $('#staffPickerModal').modal('show');
  });

  $('#staffPickerModal')
    .off('hidden.bs.modal')
    .on('hidden.bs.modal', function () {
      if (!staffPickerResolved && typeof onCancel === 'function') {
        onCancel();
      }
    });
}


// Pick a staff member (no auto-assign) — used by DELETE flow
function openStaffChooser(contextHtml, onPicked, onCancel){
  staffPickerResolved = false;
  $('#staffPickerLabel').text('Select Staff Member');
  $('#staffPickerFor').html(contextHtml || '');
  $('#staffPickerContainer').html('<div class="text-muted">Loading staff…</div>');

  fetchStaffSmart().done(function (resp) {
    let list = (resp && Array.isArray(resp.staff)) ? resp.staff : [];

    // 🔧 OFFLINE FALLBACK:
    // If we are offline and have no cached staff at all,
    // offer a local-only "Offline staff (no timesheet)" option.
    if (!list.length && window.APP_ONLINE === false) {
      list = [{ id: 0, name: 'Offline staff (no timesheet)' }];
    }

    if (!list.length){
      const msg = 'No staff are currently on shift. Ask a team member to tap Start in Timesheets.';
      $('#staffPickerContainer').html(
        '<div class="alert alert-info mb-0">' + msg + '</div>'
      );
      $('#staffPickerModal').modal('show');
      return;
    }

    const palette = ['#3390ff','#FF8D33','#8EDB70','#d7264c',
                     '#26d7cc','#8e5bcb','#DCAF70','#c3c1c6',
                     '#33FFB2','#0acbfa'];
    const $grid = $('<div class="row"></div>');

    list.forEach(function (s, idx) {
      const color = palette[idx % palette.length];
      const isLight = (function () {
        let h = color.replace('#','');
        if (h.length === 3) h = h.split('').map(c => c + c).join('');
        const r = parseInt(h.substr(0,2),16),
              g = parseInt(h.substr(2,2),16),
              b = parseInt(h.substr(4,2),16);
        return ((0.299*r + 0.587*g + 0.114*b)/255) > 0.7;
      })();
      const txtCls = isLight ? 'text-black' : 'text-white';
      const $col   = $('<div class="col-12"></div>');

      const secs   = Number(s.break_for_seconds || 0);
      const mins   = Math.floor(secs / 60);
      const durStr = mins >= 60 ? (Math.floor(mins/60) + 'h ' + (mins%60) + 'm')
                                : (mins + 'm');

      const isOfflineFallback = (window.APP_ONLINE === false && (!s.id || s.id === 0));
      const isBreak           = !isOfflineFallback && Number(s.on_break || 0) === 1;

      const $card = $(`
        <div class="staff-card ${txtCls} ${isBreak ? 'on-break' : ''}"
             style="background:${color}">
        </div>
      `).append($('<div/>').text(s.name));

      if (isBreak){
        // real staff on break -> show label, not clickable
        $card
          .attr({'aria-disabled':'true','tabindex':'-1', 'title':'On break'})
          .append(`<div class="break-badge">On break · ${durStr}</div>`);
      } else {
        $card.on('click', function () {
          staffPickerResolved = true;
          $('#staffPickerModal').modal('hide');

          // Offline fallback (id 0) – just return immediately, no server call
          if (isOfflineFallback) {
            if (typeof onPicked === 'function') {
              onPicked({ id: 0, name: s.name });
            }
            return;
          }

          // Normal staff – just return them; caller decides what to do
          if (typeof onPicked === 'function') {
            onPicked({ id: s.id, name: s.name });
          }
        });
      }

      $col.append($card);
      $grid.append($col);
    });

    $('#staffPickerContainer').empty().append($grid);
    $('#staffPickerModal').modal('show');
  })
  .fail(function () {
    $('#staffPickerContainer').html('<div class="text-danger">Failed to load staff list.</div>');
    $('#staffPickerModal').modal('show');
  });

  // call onCancel if closed without a selection
  $('#staffPickerModal')
    .off('hidden.bs.modal.deleteflow')
    .on('hidden.bs.modal.deleteflow', function(){
      if (!staffPickerResolved && typeof onCancel === 'function') onCancel();
    });
}



/* ============================
   Global "Add to Cart" → Target Picker
============================ */
function gatherTargetsForAdd() {
  const seen = new Set(); const out = [];

  function collect($scope) {
    $scope.find('.queue-item').each(function(){
      const $row = $(this);
      const $btn = $row.find('[data-id]').first();
      const qid  = Number($row.attr('data-queue-id') || 0);
      if (!$btn.length || !qid) return;
      const cid = Number($btn.attr('data-id'));
      if (!cid || seen.has(cid)) return;
      seen.add(cid);
      const name = ($row.find('.font-weight-bold').first().text() || 'Customer').trim();
      const status = cartStatusCache[cid] || null;
      out.push({ id: cid, name, queue_id: qid, status });
    });
  }
  collect($('#queueList')); collect($('#servedList'));

  cart.items.forEach(it => {
    if (it.customerId === QUICKSALE_ID) return;
    if (seen.has(it.customerId)) return;
    seen.add(it.customerId);
    out.push({ id: it.customerId, name: it.customerName || 'Customer', queue_id: it.queueId || businessId, status: cartStatusCache[it.customerId] || 'pending' });
  });

  out.sort((a,b) => {
    const ap = a.status==='pending'?0:(a.status==='paid'?2:1);
    const bp = b.status==='pending'?0:(b.status==='paid'?2:1);
    if (ap!==bp) return ap-bp;
    return (a.name||'').localeCompare(b.name||'');
  });
  return out;
}
function renderTargetPickerList(targets) {
  const $wrap = $('#targetPickerList').empty();
  const $list = $('<div class="list-group" />');

  const $qs = $(`
    <label class="list-group-item d-flex align-items-center justify-content-between">
      <div class="d-flex align-items-start">
        <input type="radio" name="pickTarget" class="mt-1 mr-2" value="QS">
        <div><div><strong>Quick Sale</strong> <span class="badge badge-secondary ml-2">No customer</span></div></div>
      </div>
    </label>
  `);
  $qs.data('target', { id: QUICKSALE_ID, name: 'Quick Sale', queue_id: businessId, status: null });
  $list.append($qs);

  if (!targets.length) {
    $list.append('<div class="list-group-item text-muted">No customers available yet.</div>');
  } else {
    targets.forEach(t => {
      const disabled = (t.status === 'paid') ? 'disabled' : '';
      const rowCls = disabled ? 'bg-light' : '';
      const badge = t.status === 'paid' ? '<span class="badge badge-success ml-2">Paid</span>'
                  : t.status === 'pending' ? '<span class="badge badge-info ml-2">In Cart</span>' : '';
      const $row = $(`
        <label class="list-group-item d-flex align-items-center justify-content-between ${rowCls}">
          <div class="d-flex align-items-start">
            <input type="radio" name="pickTarget" class="mt-1 mr-2" value="${t.id}" ${disabled}>
            <div><div><strong>${$('<div/>').text(t.name).html()}</strong>${badge}</div></div>
          </div>
        </label>
      `);
      $row.data('target', t);
      $list.append($row);
    });
  }
  $wrap.append($list);
  setTimeout(() => { const $first = $('#targetPickerList input[name="pickTarget"]:enabled').first(); if ($first.length) $first.prop('checked', true); }, 0);
}
$('#targetSearch').on('input', function(){
  const q = $(this).val().toString().toLowerCase();
  $('#targetPickerList .list-group-item').each(function(){
    const txt = $(this).text().toLowerCase();
    if ($(this).find('input[name="pickTarget"]').val() === 'QS') {
      $(this).toggle(true);
    } else {
      $(this).toggle(txt.indexOf(q) !== -1);
    }
  });
});

/* ============================
   Embedded Customer Profile (no navbar / no Save button)
============================ */
let profileAutosaveTimers = {};
function openCustomerProfileInline(customerId) {
  // Remember whose profile is open so we can refresh Family after edits
  CURRENT_PROFILE_CUSTOMER_ID = customerId;

  const isOffline = (window.APP_ONLINE === false);
  $('#customerProfileContent').html('<div class="text-muted">Loading profile…</div>');

  // ── OFFLINE: try cached snapshot (view-only) ──
  if (isOffline) {
    const cached = loadProfileCache(customerId);
    if (!cached) {
      $('#customerProfileContent').html(
        '<div class="text-muted">Customer profile is only available when LineUpz is online (no snapshot saved yet).</div>'
      );
    } else {
      renderProfileUI(customerId, cached, true); // true = offline snapshot (read-only)
      $('#customerProfileModal').modal('show');
    }
    return;
  }

  // ── ONLINE: fetch fresh + cache ──
  $.getJSON(window.location.pathname + '?action=customer_profile_data', { customer_id: customerId })
    .done(resp => {
      if (!resp || !resp.ok) {
        $('#customerProfileContent').html('<div class="text-danger">Failed to load profile.</div>');
        return;
      }
      // cache for offline view later
      saveProfileCache(customerId, resp);
      renderProfileUI(customerId, resp, false);
      $('#customerProfileModal').modal('show');
    })
    .fail(() => {
      // If server fails but we *do* have a cached snapshot, fall back to that
      const cached = loadProfileCache(customerId);
      if (cached) {
        renderProfileUI(customerId, cached, true);
        $('#customerProfileModal').modal('show');
      } else {
        $('#customerProfileContent').html('<div class="text-danger">Failed to load profile.</div>');
      }
    });
}



function renderProfileUI(customerId, data, isOfflineSnapshot) {
  const c = data.customer, b = data.business, h = data.header;
  const weeks = Math.floor((h.reminder_in_days || 0) / 7);
  const days  = (h.reminder_in_days || 0) % 7;
  const phonePretty = formatPhoneAU(c.phone);
  const readOnly = !!isOfflineSnapshot || (window.APP_ONLINE === false);

  
  // Build carousel HTML for past service images
    const images = Array.isArray(c.images) ? c.images : [];
    const imagesInner = images.length
      ? images.map((url, i) => `
          <div class="carousel-item ${i === 0 ? 'active' : ''}" style="position:relative;">
            <img src="${url}" class="d-block w-100" alt="Image ${i+1}">
            <button type="button" class="btn btn-delete btn-sm"
                    style="position:absolute;top:10px;left:50%;transform:translateX(-50%);background:transparent;border:none;color:#fff;"
                    data-img-idx="${i+1}">Delete</button>
          </div>
        `).join('')
      : `
          <div class="carousel-item active placeholder" style="position:relative;">
            <img src="images/profile_placeholder.jpg" class="d-block w-100" alt="Placeholder Image">
          </div>
        `;


 
    const qTokenFeature = Number(b.Q_token || 0) === 1;
    const plusQ        = Number(b.plus_qtokens || 0) === 1;
    const posEnabled   = Number(b.pos || 0) === 1;   // NEW
    
    // NEW: pull the loyalty program name from the business row
    const loyaltyNameRaw   = (b.loyalty_program_name || 'Q-tokens').trim();
    const walletLabelHtml  = $('<div/>').text(loyaltyNameRaw + ' Wallet').html();
    
    // Wallet block (adds spacing with mb-3)
    let qTokensBlock = '';
    if (qTokenFeature) {
      if (posEnabled) {
        // POS=1 → actions disabled; still add spacing under this card
        qTokensBlock = `
          <div class="profile-card mb-3">
            <h6>${walletLabelHtml}</h6>
            <div class="d-flex align-items-center">
              <strong class="mr-2">Balance:</strong>
              <span id="qTokensVal">${Number(c.Q_token || 0)}</span>
            </div>
          </div>
        `;
      } else {
        // POS=0 → interactive; neutral “Use Tokens” button
        qTokensBlock = `
          <div class="profile-card mb-3">
            <h6>${walletLabelHtml}</h6>
            <div class="d-flex align-items-center mb-2">
              <strong class="mr-2">Balance:</strong>
              <span id="qTokensVal">${Number(c.Q_token || 0)}</span>
            </div>
            <div class="input-group">
              <input
                type="number"
                class="form-control"
                id="qTokenAmount"
                placeholder="Amount"
                min="1"
                ${plusQ ? '' : 'max="' + Number(c.Q_token || 0) + '"'}
              >
              <div class="input-group-append">
                ${plusQ ? `
                  <button class="btn btn-pastel-success px-4 mx-1" id="addQTokensBtn">Add</button>
                ` : ``}
                <button class="btn btn-outline-secondary px-4 mx-1" id="claimQTokensBtn">Use Tokens</button>
              </div>
            </div>
          </div>
        `;
      }
    }





  const html = `
    <div class="profile-grid">
      <div>
        <!-- left column (unchanged) ... -->
        <div class="kpi mb-3">
          <h6>${$('<div/>').text(c.firstName || 'Customer').html()}</h6>
          <div class="small">Phone: ${$('<div/>').text(phonePretty || '').html()}</div>
          <div class="small">Last Visit: ${$('<div/>').text(h.second_most_recent).html()}</div>
          <div class="small">A.I SMS reminder in: ${weeks} week${weeks!==1?'s':''} and ${days} day${days!==1?'s':''}</div>
          <div class="small">Total Visits: ${Number(h.total_visits || 0)}</div>
        </div>

        <div class="profile-card mb-3">
          <div class="d-flex align-items-center">
            <strong class="mr-2">SMS Notifications:</strong>
            <div class="custom-control custom-switch">
              <input type="checkbox" class="custom-control-input" id="smsToggle" ${Number(c.sms_notification)?'checked':''}>
              <label class="custom-control-label" for="smsToggle"></label>
            </div>
          </div>
        </div>

        ${qTokensBlock}

        <div class="profile-card">
          <h6>Notes</h6>
          <textarea id="notesArea" class="form-control" rows="6" placeholder="Add notes...">${c.Notes ? $('<div/>').text(c.Notes).html() : ''}</textarea>
          <div id="notesSavedHint" class="text-success small mt-1" style="display:none;">Saved</div>
        </div>
      </div>

      <div>
        <!-- right column -->
        <div class="profile-card">
          <h6>Past Service Images</h6>
          <input type="file" id="profileHiddenImageInput" accept="image/*" capture style="display:none;">
          <button type="button" id="addImageBtn" class="btn btn-primary btn-block mb-2">Add Image</button>
          <div id="uploadingIndicator" style="display:none;">
            <div class="text-center">
              <div class="spinner-border text-primary" role="status"><span class="sr-only">Uploading...</span></div>
              <p>Uploading...</p>
            </div>
          </div>
          <div id="imageCarousel" class="carousel slide" data-ride="carousel">
            <div class="carousel-inner mt-2">${imagesInner}</div>
            <a class="carousel-control-prev" href="#imageCarousel" role="button" data-slide="prev">
              <span class="carousel-control-prev-icon" aria-hidden="true"></span><span class="sr-only">Previous</span>
            </a>
            <a class="carousel-control-next" href="#imageCarousel" role="button" data-slide="next">
              <span class="carousel-control-next-icon" aria-hidden="true"></span><span class="sr-only">Next</span>
            </a>
          </div>
        </div>

        <div class="profile-card mt-3">
          <h6>Reviews</h6>
          <div id="customerReviewsList" class="mini-list"></div>
        </div>
      </div>
    </div>
  `;

  $('#customerProfileContent').html(html);
    if (readOnly) {
        $('#customerProfileContent').prepend(
          '<div class="alert alert-warning small mb-2">' +
            'Offline snapshot – profile is view-only until LineUpz is back online.' +
          '</div>'
        );
      }

  /* === Family card host injection (Profile left column) === */
    (function insertFamilyHost(){
      // Left column (first child in the profile grid)
      const $leftCol = $('#customerProfileContent .profile-grid > div').first();
    
      // The SMS card is the one that contains #smsToggle — put Family right after it
      const $smsCard = $('#customerProfileContent #smsToggle').closest('.profile-card');
    
      const $host = $('<div id="familyCardHost" class="profile-card mb-3" style="display:none;"></div>');
    
      if ($smsCard.length) {
        $host.insertAfter($smsCard);
      } else {
        // Fallback: prepend at the top of left column if SMS card isn’t found
        $leftCol.prepend($host);
      }
    })();

    // after building the HTML and inserting it
    if (!readOnly) {
      loadCustomerReviews(customerId);
      loadProfileFamily(customerId);
    } else {
      // Offline snapshot – you can show a softer message if you like
      $('#customerReviewsList').html('<div class="text-muted">Reviews need LineUpz to be online.</div>');
    }



  // If we're in read-only mode, disable controls and bail out (no AJAX)
  if (readOnly) {
    $('#smsToggle').prop('disabled', true);
    $('#notesArea').prop('readonly', true);

    // Loyalty controls
    $('#qTokenAmount, #addQTokensBtn, #claimQTokensBtn').prop('disabled', true);

    // Image upload + delete
    $('#addImageBtn').prop('disabled', true);
    $('#imageCarousel .btn-delete').prop('disabled', true).addClass('disabled');

    return; // don’t attach any of the editing handlers below
  }

  // Handlers

  $('#smsToggle').off('change').on('change', function(){
    const status = $(this).prop('checked') ? 1 : 0;
    $.ajax({ url: window.location.pathname + '?action=customer_sms_toggle', type:'POST', contentType:'application/json',
             data: JSON.stringify({ customer_id: customerId, status }) });
  });

  $('#notesArea').off('input').on('input', function(){
    clearTimeout(profileAutosaveTimers[customerId]);
    const text = $(this).val();
    profileAutosaveTimers[customerId] = setTimeout(() => {
      $.ajax({ url: window.location.pathname + '?action=customer_notes_save', type:'POST', contentType:'application/json',
               data: JSON.stringify({ customer_id: customerId, notes: text }) })
        .done(() => { $('#notesSavedHint').stop(true,true).fadeIn(120).delay(800).fadeOut(300); });
    }, 700);
  });

    // Q-tokens
    $('#addQTokensBtn').off('click').on('click', function(){
      let amount = 0;
      const $amt = $('#qTokenAmount');
      if ($amt.length) {
        amount = parseInt($amt.val(), 10) || 0;
      } else {
        // No field present (e.g., POS=1 but you may still render Add in future) → prompt
        const v = prompt('Amount to add:');
        amount = parseInt((v||'').trim(), 10) || 0;
      }
      if (amount <= 0) { alert('Enter a valid amount.'); return; }
      if (!confirm(`Add ${amount} Q-token${amount>1?'s':''}?`)) return;
      $.ajax({ url: window.location.pathname + '?action=customer_qtokens_add', type:'POST', contentType:'application/json',
               data: JSON.stringify({ customer_id: customerId, amount }) })
        .done(() => {
          const cur = parseInt($('#qTokensVal').text(),10)||0;
          const n   = cur + amount;
          $('#qTokensVal').text(n);
          if ($amt.length){ $amt.val(''); $amt.attr('max', n); }
        });
    });
    
    $('#claimQTokensBtn').off('click').on('click', function(){
      const amount = parseInt($('#qTokenAmount').val(), 10) || 0;
      const cur = parseInt($('#qTokensVal').text(),10)||0;
      if (amount <= 0 || amount > cur) { alert('Invalid amount.'); return; }
      if (!confirm(`Use ${amount} Q-token${amount>1?'s':''}?`)) return;
      $.ajax({ url: window.location.pathname + '?action=customer_qtokens_claim', type:'POST', contentType:'application/json',
               data: JSON.stringify({ customer_id: customerId, amount }) })
        .done(() => { const n=cur-amount; $('#qTokensVal').text(n); $('#qTokenAmount').val(''); $('#qTokenAmount').attr('max', n); })
        .fail(() => alert('Error using Q-tokens.'));
    });


  // Images
  $('#addImageBtn').off('click').on('click', function(){
    const currentCount = $('#imageCarousel .carousel-item:not(.placeholder)').length;
    if (currentCount >= 3) { alert('Maximum number of photos reached. Please delete a photo before adding more.'); return; }
    $('#profileHiddenImageInput').val('').trigger('click');
  });
  $('#profileHiddenImageInput').off('change').on('change', function(e){
    const file = e.target.files[0]; if (!file) return;
    $('#uploadingIndicator').show();

    const reader = new FileReader();
    reader.onload = function(evt){
      const img = new Image();
      img.onload = function(){
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const maxW=900, maxH=700;
        const ratio = Math.max(maxW/img.width, maxH/img.height);
        const newW = img.width * ratio;
        const newH = img.height * ratio;
        canvas.width = newW; canvas.height = newH;
        ctx.drawImage(img, 0, 0, newW, newH);
        canvas.toBlob(function(blob){
          const fd = new FormData();
          fd.append('image', blob, 'resized.jpg');
          fd.append('customer_id', customerId);
          const xhr = new XMLHttpRequest();
          xhr.open('POST', 'upload_images.php', true);
          xhr.onload = function(){
            $('#uploadingIndicator').hide();
            if (xhr.status === 200) {
              try {
                const resp = JSON.parse(xhr.responseText);
                if (resp.url) {
                  prependProfileImage(resp.url);
                } else { alert('Upload failed.'); }
              } catch(e) { alert('Upload failed.'); }
            } else { alert('Upload failed.'); }
          };
          xhr.onerror = function(){ $('#uploadingIndicator').hide(); alert('Upload failed.'); };
          xhr.send(fd);
        }, 'image/jpeg', 0.9);
      };
      img.src = evt.target.result;
    };
    reader.readAsDataURL(file);
  });
  $('#imageCarousel').off('click', '.btn-delete').on('click', '.btn-delete', function(){
    const idx = Number($(this).attr('data-img-idx'));
    if (!idx) return;
    if (!confirm('Delete this image?')) return;
    $.post('delete_image.php', { imageNumber: idx, customer_id: customerId })
      .done(() => location.reload())
      .fail(() => alert('Failed to delete image.'));
  });
  function prependProfileImage(url) {
    const $inner = $('#imageCarousel .carousel-inner');
    const hasPlaceholder = $inner.find('.placeholder').length>0;
    if (hasPlaceholder) $inner.find('.placeholder').remove();
    const countExisting = $inner.children().length;
    const $item = $(`
      <div class="carousel-item ${countExisting===0?'active':''}" style="position:relative;">
        <img src="${url}" class="d-block w-100" alt="New Image">
        <button type="button" class="btn btn-delete btn-sm" style="position:absolute;top:10px;left:50%;transform:translateX(-50%);background:transparent;border:none;color:#fff;"
          data-img-idx="${countExisting+1}">Delete</button>
      </div>
    `);
    $inner.prepend($item);
    $('.carousel').carousel();
  }
}
function loadCustomerReviews(customerId){
  const $list = $('#customerReviewsList').empty().append('<div class="text-muted">Loading…</div>');

  $.getJSON(window.location.pathname + '?action=customer_reviews', { customer_id: customerId })
    .done(resp => {
      if (!resp || !resp.ok) { $list.html('<div class="text-danger">Failed to load reviews.</div>'); return; }
      const rows = resp.reviews || [];
      if (!rows.length) { $list.html('<div class="text-muted">No reviews yet.</div>'); return; }

      const frag = document.createDocumentFragment();
      rows.forEach(r => {
        const when = (r.ts || '').replace('T',' ').slice(0,16); // YYYY-MM-DD HH:MM
        const storeStars = Number(r.store_star || 0);
        const staffStars = Number(r.staff_star || 0);

        const html = `
          <div class="item">
            <div>
              <div><strong>${h(when)}</strong>${r.staff_name ? ` • <span class="muted">Served by:</span> ${h(r.staff_name)}` : ''}</div>
              ${r.store_review ? `<div class="meta" style="margin-top:2px;"><span class="muted">Store:</span> ${h(r.store_review)}</div>` : ''}
              ${r.staff_review ? `<div class="meta"><span class="muted">Staff:</span> ${h(r.staff_review)}</div>` : ''}
            </div>
            <div class="text-right" style="min-width:112px;">
              <div class="meta">Store ★ ${storeStars}/5</div>
              <div class="meta">Staff ★ ${staffStars}/5</div>
            </div>
          </div>`;
        const wrap = document.createElement('div');
        wrap.innerHTML = html;
        while (wrap.firstChild) frag.appendChild(wrap.firstChild);
      });

      $list.empty().append(frag);
    })
    .fail(() => $list.html('<div class="text-danger">Failed to load reviews.</div>'));
}
function loadProfileFamily(customerId){
  const $host = $('#familyCardHost');
  if (!$host.length) return;

  $host.hide().empty();

  // 1) Ask if THIS customer has a family
  $.getJSON(window.location.pathname + '?action=family_list_for', { ids: String(customerId) })
    .done(resp => {
      const entry = (resp && resp.ok && resp.map) ? resp.map[customerId] : null;
      const famKey = entry && entry.key ? String(entry.key) : '';
      const famLabelFromList = entry && entry.label ? String(entry.label) : '';
      if (!famKey) return; // no family → keep hidden

      // 2) Fetch members for that family
      $.getJSON(window.location.pathname + '?action=family_members', { family_key: famKey })
        .done(r2 => {
          const members = Array.isArray(r2 && r2.members) ? r2.members : [];
          const label   = (r2 && r2.label) || famLabelFromList || '';

          const chips = members.length
            ? members.map(m => `
                <span class="badge badge-light mr-1 mb-1">
                  ${h(m.firstName || 'Customer')}
                  <span class="text-muted small ml-1">#${m.id}</span>
                </span>
              `).join('')
            : '<span class="text-muted">No members</span>';

          const showName = label && label.toLowerCase() !== 'family' ? ` — ${h(label)}` : '';

          $host.html(`
            <h6 class="d-flex align-items-center justify-content-between mb-2" style="gap:8px;">
              <span>Family${showName}</span>
              <button type="button" class="btn btn-outline-secondary btn-sm" id="famProfileEditBtn">Edit</button>
            </h6>
            <div id="famProfileMembers" class="d-flex flex-wrap" style="gap:6px;">${chips}</div>
          `).show();

          $('#famProfileEditBtn').off('click').on('click', () => openFamilyEditModal(famKey));

          // If the edit modal closes while profile is open, refresh the card
          $('#familyEditModal')
            .off('hidden.bs.modal.profileRefresh')
            .on('hidden.bs.modal.profileRefresh', function(){
              if (CURRENT_PROFILE_CUSTOMER_ID === customerId) loadProfileFamily(customerId);
            });
        })
        .fail(() => { $host.html('<div class="text-danger">Failed to load family.</div>').show(); });
    })
    .fail(() => { /* keep hidden on failure */ });
}




/* ============================
   Manual Check-in (on-page)
============================ */
function mcNormalisePhoneAU(raw) {
  if (!raw) return '';
  let s = (raw+'').replace(/\s+/g,'').trim();
  if (/^0\d{9}$/.test(s)) s = '+61' + s.slice(1);
  if (/^\+61\d{9}$/.test(s)) return s;
  s = s.replace(/[^+\d]/g, '');
  if (s.startsWith('+61') && s.length === 12) return s;
  return s;
}
function mcValidAU(s) { return /^\+61\d{9}$/.test(s); }

function openManualCheckinModal(){
  $('#manualCheckinModal .step').removeClass('active').hide();
  $('#manualCheckinModal .step-1').addClass('active').show();
  $('#mcPhone').val('');
  $('#mcErr1,#mcErr2').hide().text('');
  $('#mcResults').empty();
  $('#mcPhoneDisplay').text('');
  $('#mcLoader1,#mcLoader2').hide();
  $('#manualCheckinModal').modal('show');
}
$('#addQueueButton').off('click').on('click', openManualCheckinModal);

$('#mcPhone').on('input', function(){
  let v = $(this).val();
  v = v.replace(/[^\d+ ]/g,'');
  if (v.length > 16) v = v.slice(0,16);
  $(this).val(v);
});

$('#mcNext').on('click', function(){
  const raw   = $('#mcPhone').val();
  const phone = mcNormalisePhoneAU(raw);
  $('#mcErr1').hide().text('');

  if (!mcValidAU(phone)) {
    $('#mcErr1')
      .text('Please enter a valid Australian mobile like 0412 345 678 or +61 412 345 678.')
      .show();
    return;
  }

  // 🔌 OFFLINE: skip lookup and go straight to "New Client" only
  if (window.APP_ONLINE === false) {
    $('#manualCheckinModal .step').removeClass('active').hide();
    $('#manualCheckinModal .step-2').addClass('active').show();
    $('#mcPhoneDisplay').text(phone);
    $('#mcResults').html(
      '<div class="text-muted mb-2">Offline mode: cannot search existing clients. Use "New Client" below to add a temporary offline check-in.</div>'
    );
    return;
  }

  // 🌐 ONLINE: original lookup
  $('#mcLoader1').show();

  $.ajax({
    url: 'lookup_client.php',
    type: 'POST',
    data: { phone: phone },
    dataType: 'json'
  }).done(function(resp){
    $('#mcLoader1').hide();
    $('#manualCheckinModal .step').removeClass('active').hide();
    $('#manualCheckinModal .step-2').addClass('active').show();
    $('#mcPhoneDisplay').text(phone);

    const $results = $('#mcResults').empty();
    if (Array.isArray(resp) && resp.length) {
      $results.append('<h6 class="mb-2">Matches</h6>');
      const $list = $('<div class="list-group mb-2"></div>');

      resp.forEach(client => {
        const label = $('<div/>').text(client.name || client.firstName || 'Customer').html();
        const btn = $(`
          <button type="button" class="list-group-item list-group-item-action d-flex justify-content-between align-items-center">
            <span>Add <strong>${label}</strong> to the queue</span>
            <span class="badge badge-primary badge-pill">Add</span>
          </button>
        `).on('click', function(){

          // If you go offline between Step 1 and here, protect it:
          if (window.APP_ONLINE === false) {
            $('#mcErr2')
              .text('You appear to be offline. Existing clients can only be checked in when LineUpz is online.')
              .show();
            return;
          }

          $('#mcErr2').hide().text('');
          $('#mcLoader2').show();

          $.ajax({
            url: 'add_client.php',
            type: 'POST',
            dataType: 'json',
            data: {
              customer_id: client.id,
              name:  client.name || client.firstName || '',
              phone: phone
            }
          }).done(function(resp2){
            $('#mcLoader2').hide();

            if (resp2 && resp2.ok === false) {
              $('#mcErr2').text(resp2.error || 'Failed to add existing client to the queue.').show();
              return;
            }

            $('#manualCheckinModal').modal('hide');
            clearAnchor(client.id);
            fetchQueueData();
          }).fail(function(){
            $('#mcLoader2').hide();
            $('#mcErr2').text('Failed to add existing client to the queue.').show();
          });
        });

        $list.append(btn);
      });

      $results.append($list);
    } else {
      $results.append('<div class="text-muted mb-2">No existing clients for this number. Add as a new client below.</div>');
    }
  }).fail(function(){
    $('#mcLoader1').hide();
    $('#mcErr1').text('Error looking up that number. Please try again.').show();
  });
});



$('#mcAddNew').on('click', function(){
  const phone = $('#mcPhoneDisplay').text().trim();
  const full  = ($('#mcNewName').val() || '').trim();
  $('#mcErr2').hide().text('');

  if (!mcValidAU(phone)) {
    $('#mcErr2').text('Phone is invalid. Go back to Step 1.').show();
    return;
  }
  if (!full) {
    $('#mcErr2').text('Please enter the client’s name.').show();
    return;
  }

  let firstName = full.split(/\s+/)[0] || full;
  firstName = firstName.charAt(0).toUpperCase() + firstName.slice(1).toLowerCase();

    // 🔌 OFFLINE: store as temporary offline check-in
      if (window.APP_ONLINE === false) {
          const entry = {
            tempId: 'off_' + Date.now() + '_' + Math.random().toString(36).slice(2, 6),
            name: firstName,
            phone: phone,
            createdAt: new Date().toISOString(),
            state: 'queued',     // queued | served
            staffId: null,
            staffName: null,
            servedAt: null,
            finished: false,
            finishedAt: null,
            serviceSecs: null,
            paid: false,
            paidAt: null
          };
          offlineCheckins.push(entry);
          saveOfflineCheckins();
          renderOfflineCheckins();
          $('#manualCheckinModal').modal('hide');
          showSnack('Offline check-in added', false, 1800);
          return;
        }




  // 🌐 ONLINE: normal behaviour
  $('#mcLoader2').show();
  $.ajax({
    url: 'add_client.php',
    type: 'POST',
    data: { name: firstName, phone: phone, queue_status: 'in-queue' }
  }).done(function(){
    $('#mcLoader2').hide();
    $('#manualCheckinModal').modal('hide');
    fetchQueueData();
  }).fail(function(){
    $('#mcLoader2').hide();
    $('#mcErr2').text('Failed to add new client.').show();
  });
});



/* ============================
   Init
============================ */

$(function() {
  updateOnlineBadge();
  updateTimesheetTabState();   // 👈 NEW: set disabled/enabled from the start
  fetchServicesFresh();
  prefetchLinklyTokenIfNeeded();   // 👈 warm Linkly token on initial load

  renderOfflineCheckins();
  replayOfflineJobs();
  trySyncOfflineCheckins().always(function () {
    trySyncOfflinePayments();
  });

  fetchQueueData();
  startLiveTimers();
  fetchServedData();
  hydrateQuickSaleFromServer();
  updateTimesheetBadge();
  setInterval(updateTimesheetBadge, 60 * 1000);
  // Precompute ESC/POS logo so printing is instant
  warmLogo();



  // Footer: Add to Cart (global)
  $('#cartAddGlobal').on('click', function() {
    const targets = gatherTargetsForAdd();
    renderTargetPickerList(targets);
    $('#targetPickerModal').modal('show');
  });

  $('#targetPickConfirm').on('click', function() {
    const $sel = $('#targetPickerList input[name="pickTarget"]:checked');
    if (!$sel.length) { alert('Please choose where to add items.'); return; }
    const val = $sel.val();

    let picked = null;
    $('#targetPickerList .list-group-item').each(function(){
      const data = $(this).data('target');
      if (!data) return;
      if ((val === 'QS' && data.id === QUICKSALE_ID) || String(data.id) === String(val)) {
        picked = data; return false;
      }
    });
    if (!picked) { alert('Selection not found.'); return; }

    $('#targetPickerModal').modal('hide');

    if (picked.id === QUICKSALE_ID) {
      openServicePickerForQuickSale();
    } else {
      openServicePickerForCustomer({ id: picked.id, first_name: picked.name, queue_id: picked.queue_id }, true);
    }
  });

    // Ensure the Add button is ALWAYS usable when the picker opens/closes
    $('#servicePickerModal')
      .off('shown.bs.modal._prep hidden.bs.modal._clear')
      .on('shown.bs.modal._prep', function () {
        // (you already re-enable the Add button here)
        $('#servicePickerAdd')
          .data('busy', false)
          .prop('disabled', false)
          .text(editMode ? 'Save Changes' : 'Add to Cart');
    
        // NEW: try to apply the most recent scan after paint (a few retries)
        setTimeout(tryApplyScanToOpenPicker, 0);
        setTimeout(tryApplyScanToOpenPicker, 60);
        setTimeout(tryApplyScanToOpenPicker, 180);
      })
      .on('hidden.bs.modal._clear', function () {
        // (your existing close reset code stays)
        pickerCustomer = null;
        editMode = false;
        editTarget = null;
        pickerTokenBudget   = 0;
        pickerTokenSelected = 0;
        pendingScans.length = 0;
        $('#scanStrip').hide();
        $('#servicePickerAdd').data('busy', false).prop('disabled', false).text('Add to Cart');
      });
    
    


        

    renderCart();            // existing

  
  /* ===== Idle auto-refresh (safety reset) ===== */
  // How long with no user interaction before we auto-reload (ms)
  const IDLE_RELOAD_MS = 6 * 60 * 60 * 1000; // 6 hours

  let lastUserAction = Date.now();

  function bumpActivity() {
    lastUserAction = Date.now();
  }

  // Anything that looks like a human using the POS updates the timestamp
  ['click','keydown','mousemove','touchstart','pointerdown'].forEach(function(ev){
    window.addEventListener(ev, bumpActivity, { passive: true });
  });

    // Every minute, see if we've been idle too long
    setInterval(function(){
      // If tab is in the background, don't auto-reload – wait until it's visible
      if (document.hidden) return;
    
      // 🔐 If we're offline, don't auto-reload. Wait until LineUpz is back online.
      if (window.APP_ONLINE === false || navigator.onLine === false) return;
    
      const idleFor = Date.now() - lastUserAction;
      if (idleFor < IDLE_RELOAD_MS) return;
    
      // Don't blow away something mid-flow:
      //  - if any modal is open
      //  - if a card transaction is in progress
      if ($('.modal.show').length) return;
      if (window.cardFlow && window.cardFlow.inProgress) return;
    
      // Hard reset the page
      location.reload();
    }, 60 * 1000);
    


// Scale-to-fit when the POS modal opens & when window resizes
$('#checkoutModal').on('shown.bs.modal', fitCheckoutToViewport);
$(window).on('resize', function(){
  if ($('#checkoutModal').hasClass('show')) fitCheckoutToViewport();
});

// Reset & cancel any running Card checkout when modal hides
$('#checkoutModal')
  .off('hidden.bs.modal.reset')
  .on('hidden.bs.modal.reset', function(){
    const provider = (window.PREFERRED_EFTPOS || '').toLowerCase();

    // For Square we actively cancel the in-flight checkout; Linkly is synchronous per call.
    if (provider === 'square' && cardFlow && cardFlow.inProgress) {
      cancelTerminalCheckout();
    }
    cardFlow.inProgress = false;
    cardFlow.checkoutId = null;
    clearCardFlowTimer && clearCardFlowTimer();

    $('#cardDeclinedBanner').hide();

    // reset transform
    $('#coContent').css('transform','');

    // fully restore the pre-record UI for the next customer
    const $totalRow = $('#coTotal').closest('.d-flex');
    $totalRow.show();
    $('.method-tiles').show();
    $('#coCashSection').show();
    $('.email-header, #coEmail, hr').show();
    $('#coCardAlert').hide();
    $('#coSuccess').hide().empty();

    if (typeof rebindPrimaryToRecord === 'function') rebindPrimaryToRecord();
  });



    // make sure primary is back to “Record Payment” next time
    rebindPrimaryToRecord();
 
    // === Insights drawer bindings ===
    $('#insightTab').on('click', function(){
      if (window.APP_ONLINE === false) {
        if (typeof showSnack === 'function') {
          showSnack('Insights are only available when LineUpz is online.', true, 2200);
        } else {
          alert('Insights are only available when LineUpz is online.');
        }
        return;
      }
      toggleInsights();
    });
    $('#insightClose').on('click', function(){ toggleInsights(false); });

    $('#insightClose').on('click', function(){ toggleInsights(false); });
    
    // Optional: refresh pies while open
    setInterval(function(){
      if ($('#insightDrawer').hasClass('open')) fetchInsights();
    }, 30000); // every 30s
    
        // ===== Real browser fullscreen (hide browser UI) =====
    (function(){
      const $btn = $('#fsBtn');
    
      function isFullscreen(){
        return document.fullscreenElement ||
               document.webkitFullscreenElement ||
               document.msFullscreenElement;
      }
    
      function enterFullscreen(){
        const el = document.documentElement; // whole page
        const req = el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen;
        if (req) {
          try { req.call(el, { navigationUI: 'hide' }); } catch (_) { req.call(el); }
        }
      }
    
      function exitFullscreen(){
        const exit = document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen;
        if (exit) exit.call(document);
      }
    
      function toggleFullscreen(){
        if (isFullscreen()) exitFullscreen();
        else enterFullscreen();
      }
    
      function syncIcon(){
        const fs = isFullscreen();
        $btn.attr('title', fs ? 'Exit fullscreen' : 'Enter fullscreen');
        $btn.find('i').toggleClass('fa-expand', !fs).toggleClass('fa-compress', fs);
      }
    
      // Click handler
      $btn.off('click.fs').on('click.fs', toggleFullscreen);
    
      // Update icon when user hits Esc / F11 / system UI
      document.addEventListener('fullscreenchange', syncIcon);
      document.addEventListener('webkitfullscreenchange', syncIcon);
      document.addEventListener('msfullscreenchange', syncIcon);
    
      // Initial icon state
      syncIcon();
    })();
    
    

    

  


});

function fitCheckoutToViewport(){
  const $content = $('#coContent');
  if (!$content.length) return;

  // Reset any previous scaling before measuring
  $content.css({ transform: '', 'transform-origin': 'center center' });

  // Measure natural content size
  const contH = $content.outerHeight();
  const contW = $content.outerWidth();

  // Available viewport space (little gutter)
  const maxH = window.innerHeight - 16;
  const maxW = window.innerWidth  - 16;

  // Compute scale to fit both height and width
  const scale = Math.min(1, maxH / contH, maxW / contW);

  // Apply scaling (centered → no weird "too high" look)
  $content.css({
    transform: 'scale(' + scale + ')',
    'transform-origin': 'center center'
  });
}
// --- Email autosave helpers ---
function debounce(fn, delay){ let t; return function(){ clearTimeout(t); const args=arguments, ctx=this; t=setTimeout(()=>fn.apply(ctx,args), delay); }; }
function looksLikeEmail(s){ return /^[^\s@]+@[^\s@]+\.[^\s@]{2,}$/.test((s||'').trim()); }

function saveEmailForAllActiveCustomers(email){
  if (!email || !looksLikeEmail(email) || !checkoutByCustomer) return $.Deferred().resolve().promise();
  const saves = Object.keys(checkoutByCustomer)
    .filter(k => k !== String(QUICKSALE_ID))
    .map(cid => $.ajax({
      url: window.location.pathname + '?action=customer_email_save',
      type:'POST',
      contentType:'application/json',
      data: JSON.stringify({ customer_id: Number(cid), email: email.trim() })
    }));
  if (!saves.length) return $.Deferred().resolve().promise();
  return $.when.apply($, saves);
}

// ===== Insights (pie charts + hourly) =====
let pieCutsChart = null, pieReviewsChart = null, barHourlyChart = null;
const PIE_COLORS = ['#60a5fa','#34d399','#fbbf24','#f472b6','#a78bfa','#22d3ee','#f87171','#10b981','#f59e0b','#3b82f6','#ef4444','#14b8a6'];

// --- GLOBAL helpers (so renderFeedback can use them) ---
function h(s){ return $('<div/>').text(s || '').html(); }
function hhmm(ts){ return (ts && typeof ts === 'string' && ts.length >= 16) ? ts.slice(11,16) : ''; }
/* ========== Barcode scanner (keyboard-wedge) ========== */
let pendingScans = [];   // [{code, qty, time, match, sid}]
let scanSessionId = 0;   // NEW: increments when a fresh scan session starts
let scanBuffer   = '';
let scanTimer    = null;
let scanLastTs   = 0;
const SCAN_MIN_LEN = 6;
const SCAN_GAP_MS  = 35;


function handleScanEnd(){
  if (!scanBuffer) return;
  const s = scanBuffer.trim();
  scanBuffer = ''; scanLastTs = 0;
  if (scanTimer) { clearTimeout(scanTimer); scanTimer = null; }
  if (s.length >= SCAN_MIN_LEN) queueScan(s);
}

window.addEventListener('keydown', function(e){
  // skip when user is typing in inputs/textareas/editable areas
  const t = e.target;
  if (t && (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA' || t.isContentEditable)) return;

  const k = e.key;
  const now = Date.now();

  if (k === 'Enter') { handleScanEnd(); return; }
  if (k.length !== 1) return;   // keep only characters

  if (scanLastTs && (now - scanLastTs) > 100) scanBuffer = '';  // human typing reset
  scanBuffer += k;
  scanLastTs = now;

  if (scanTimer) clearTimeout(scanTimer);
  scanTimer = setTimeout(handleScanEnd, SCAN_GAP_MS);
});

// increment + focus a tile by service id; returns true if tile was found/applied
function highlightSvcTileById(svcId, qtyDelta){
  const $tile = $('#servicesContainer .svc-cell').filter(function(){
    const svc = $(this).data('svc'); return svc && Number(svc.id) === Number(svcId);
  });
  if (!$tile.length) return false;

  const newQty = (Number($tile.data('count')||0) + (qtyDelta||1));
  $tile.data('count', newQty);
  $tile.find('.svc-ui').show().find('.svc-count').text(newQty);

  // visual feedback + bring into view
  const el = $tile[0];
  if (el && el.scrollIntoView) el.scrollIntoView({ block:'nearest', behavior:'smooth' });
  $tile.addClass('scan-flash');
  setTimeout(()=> $tile.removeClass('scan-flash'), 500);
  return true;
}

// Try to apply ALL resolved scans to the open picker.
// Consume scans as soon as they are successfully applied, so retries are harmless.
function tryApplyScanToOpenPicker(){
  if (!$('#servicePickerModal').hasClass('show') || !pendingScans.length) return;

  let appliedAny = false;
  const keep = [];

  for (const e of pendingScans) {
    if (e.sid !== scanSessionId) continue;                // ignore stale sessions
    if (!e.match || e.match.notFound) { keep.push(e); continue; }

    const ok = highlightSvcTileById(e.match.id, e.qty);   // bumps tile qty + flash + scroll
    if (!ok) keep.push(e);                                // tile not painted yet -> retry later
    appliedAny = appliedAny || ok;
  }

  // Keep only unresolved entries for this session
  pendingScans = keep;
  renderScanStrip();

  if (!appliedAny && pendingScans.length) {
    setTimeout(tryApplyScanToOpenPicker, 60);
  }
}


function queueScan(code){
  const now = Date.now();
  const pickerOpen = $('#servicePickerModal').hasClass('show');
  const targetOpen = $('#targetPickerModal').hasClass('show');

  if (!pickerOpen) {
    // New session: throw away any stale queue so only THIS scan goes in
    scanSessionId++;
    pendingScans = [{ code, qty: 1, time: now, match: null, sid: scanSessionId }];
  } else {
    // Same open session -> append/merge
    const last = pendingScans[pendingScans.length - 1];
    if (last && last.sid === scanSessionId && last.code === code && (now - last.time) < 1500) {
      last.qty += 1;
      last.time = now;
    } else {
      pendingScans.push({ code, qty: 1, time: now, match: null, sid: scanSessionId });
    }
  }

  // Kick off lookup for the tail scan
  resolveBarcode(pendingScans[pendingScans.length - 1]);

  // Open flows
  if (pickerOpen) {
    tryApplyScanToOpenPicker();
  } else if (!targetOpen) {
    $('#cartAddGlobal').trigger('click');
  }

  renderScanStrip();
}



function resolveBarcode(entry){
  $.getJSON(window.location.pathname + '?action=barcode_lookup', { code: entry.code })
    .done(resp => {
      const m = (resp && resp.matches) ? resp.matches : [];
      entry.match = m[0] || { notFound:true };

      if (entry.match.notFound) {
        // NEW: remove it right away so it can't be applied later
        pendingScans = pendingScans.filter(s => s !== entry);
        showSnack('Unknown barcode: ' + entry.code, true, 1800);
      } else if ($('#servicePickerModal').hasClass('show')) {
        // Apply now if the picker is open
        tryApplyScanToOpenPicker();
      }

      renderScanStrip();
    })
    .fail(() => showSnack('Barcode lookup failed', true, 1500));
}



function renderScanStrip(){
  const $mb = $('#servicePickerModal .modal-body');
  if (!$mb.length) return;
  let $strip = $('#scanStrip');
  if (!$strip.length){
    $strip = $('<div id="scanStrip" class="alert alert-light border mb-2" role="status" style="display:none;"></div>');
    $mb.prepend($strip);
  }

  const curr = pendingScans.filter(e => e.sid === scanSessionId);
  if (!curr.length){ $strip.hide(); return; }

  const chips = curr.map(e => {
    const label = (e.match && e.match.item_name) ? e.match.item_name : e.code;
    const bad   = (e.match && e.match.notFound);
    return `<span class="badge ${bad?'badge-danger':'badge-primary'} mr-2 p-2">${h(label)} × ${e.qty}</span>`;
  }).join(' ');

  $strip.html(`<strong>Scanned:</strong> ${chips} <button type="button" id="scanClear" class="btn btn-sm btn-outline-secondary ml-2">Clear</button>`).show();
}

$(document).on('click', '#scanClear', function(){ pendingScans.length = 0; renderScanStrip(); });

/* Push scans into the grid counts */
function applyScanEntriesToPicker(){
  if (!$('#servicePickerModal').hasClass('show') || !pendingScans.length) return;

  let appliedAny = false;
  const keep = [];

  for (const e of pendingScans) {
    if (e.sid !== scanSessionId) continue;                // ignore stale sessions
    if (!e.match || e.match.notFound) { keep.push(e); continue; }

    const ok = highlightSvcTileById(e.match.id, e.qty);
    if (!ok) keep.push(e);
    appliedAny = appliedAny || ok;
  }

  pendingScans = keep;
  renderScanStrip();
}

// Open from either Checked-in or Served card
$(document).on('click', '.btn-upsells', function (e) {
  e.stopPropagation();
  const $row = $(this).closest('.queue-item');
  openUpsellEditorForRow($row);
});

// Save selection back to kiosk_upsell_events
$('#upsellSaveBtn').on('click', function () {
  if (!upsellCustomerId) {
    $('#upsellModal').modal('hide');
    return;
  }

  const ids = $('#upsellOptions .upsell-opt:checked')
    .map(function () { return Number(this.value); })
    .get();

  const $btn = $(this).prop('disabled', true).text('Saving…');

  $.ajax({
    url: window.location.pathname + '?action=upsell_set',
    type: 'POST',
    contentType: 'application/json',
    data: JSON.stringify({
      customer_id: upsellCustomerId,
      service_ids: ids
    })
  }).done(function (resp) {
    if (resp && resp.ok) {
      // Let the normal polling bring in fresh badges / AI queue times
      fetchQueueData();
      fetchServedData();
      $('#upsellModal').modal('hide');
    } else {
      alert('Failed to save add-ons.');
    }
  }).fail(function () {
    alert('Failed to save add-ons.');
  }).always(function () {
    $btn.prop('disabled', false).text('Save');
  });
});



let pickerRedoAllowed = true;  // computed per-customer from profile header


// --- Pies ---
function buildOrUpdatePie(existingChart, canvas, labels, values, colors, title){
  const ctx = canvas.getContext('2d');
  if (existingChart){
    existingChart.data.labels = labels;
    existingChart.data.datasets[0].data = values;
    existingChart.data.datasets[0].backgroundColor = colors;
    existingChart.update();
    return existingChart;
  }
  return new Chart(ctx, {
    type: 'pie',
    data: { labels, datasets: [{ data: values, backgroundColor: colors }] },
    options: {
      responsive: true, maintainAspectRatio: true, aspectRatio: 1,
      plugins: { legend:{position:'bottom'}, title:{display:!!title, text:title} }
    }
  });
}

// --- Hourly combo chart (turnover by staff + wait line; NO cancellations) ---
function buildOrUpdateHourly(existingChart, canvas, labels, staffSeries, _cancelStaff, _cancelCust, avgWait){
  const ctx = canvas.getContext('2d');
  const palette = PIE_COLORS;
  const datasets = [];

  // Turnover by staff (grouped) – bars in dollars
  (staffSeries || []).forEach((s, i) => {
    datasets.push({
      type: 'bar',
      label: s.label,
      data: s.data,          // already dollars from PHP
      yAxisID: 'y',
      backgroundColor: palette[i % palette.length],
      borderColor: palette[i % palette.length],
      borderWidth: 0
    });
  });

  // Wait time line (minutes) on right axis
  datasets.push({
    type: 'line',
    label: 'Avg Wait (min)',
    data: (avgWait || new Array(labels.length).fill(0)),
    yAxisID: 'y2',
    borderColor: '#111111',
    backgroundColor: '#111111',
    fill: false,
    tension: 0.25,
    pointRadius: 2,
    borderWidth: 3
  });

  const cfg = {
    data: { labels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: 'index', intersect: false },
      scales: {
        x: {
          stacked: false,
          ticks: { maxRotation: 0, autoSkip: true }
        },
        // Left axis: turnover ($) – keep bars but hide numbers if you like
        y: {
          stacked: false,
          beginAtZero: true,
          title: { display: false },
          ticks: { display: false },          // set to true if you want $ values shown
          grid: { display: false, drawBorder: false }
        },
        // Right axis: visible minutes for wait-time
        y2: {
          position: 'right',
          beginAtZero: true,
          grid: { drawOnChartArea: false },
          title: { display: true, text: 'Minutes' }
        }
      },
      plugins: {
        legend: { position: 'bottom' },
        tooltip: { enabled: false } // you disabled tooltips globally anyway
      }
    }
  };

  if (existingChart) {
    existingChart.data = cfg.data;
    existingChart.options = cfg.options;
    existingChart.update();
    return existingChart;
  }
  return new Chart(ctx, cfg);
}

// --- Renderer: cancellations (compact cards) ---
function renderCancels(arr){
  const $root = $('#cancelList').empty();
  if (!arr || !arr.length){
    $root.append('<div class="text-muted">No cancellations today.</div>');
    return;
  }

  arr.forEach(row => {
    const whoBadge = (row.who === 'staff')
      ? '<span class="badge-pill badge-staff">By staff</span>'
      : '<span class="badge-pill badge-cust">By customer</span>';

    const serviceLine = row.service_item_name
      ? `<div class="meta">${h(row.service_item_name)}</div>`
      : '';

    const time = hhmm(row.ts); // "HH:MM"

    const $item = $(`
      <div class="item" role="button" tabindex="0"
           aria-label="Open profile for ${h(row.firstName || 'Customer')}">
        <div>
          <div><strong>${h(row.firstName || 'Customer')}</strong></div>
          <div class="meta" style="margin-top:2px;">${whoBadge}</div>
          ${serviceLine}
        </div>
        <div class="d-flex flex-column align-items-end">
          <div class="meta">${h(time)}</div>
          <button class="btn btn-outline-secondary btn-sm mt-1 view-profile">
            Profile
          </button>
        </div>
      </div>
    `);

    const openProfile = () => openCustomerProfileInline(Number(row.id));

    $item.on('click', openProfile);
    $item.on('keypress', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        openProfile();
      }
    });
    $item.find('.view-profile').on('click', (e) => {
      e.stopPropagation();
      openProfile();
    });

    $root.append($item);
  });
}



// --- Renderer: feedback (full detail like report page) ---
function renderFeedback(arr){
  const $root = $('#fbList').empty();
  if (!arr || !arr.length){ $root.append('<div class="text-muted">No feedback today.</div>'); return; }

    arr.forEach(r=>{
      const time       = hhmm(r.ts);
      const customer   = r.customer_name || 'Customer';
      const staffName  = r.staff_name || '—';
      const storeStars = Number(r.store_star || 0);
      const staffStars = Number(r.staff_star || 0);
    
      const storeTxt = (r.store_review && String(r.store_review).trim())
        ? `<div class="mt-1"><span class="muted">Store:</span> ${h(r.store_review)}</div>` : '';
      const staffTxt = (r.staff_review && String(r.staff_review).trim())
        ? `<div class="mt-1"><span class="muted">Staff:</span> ${h(r.staff_review)}</div>` : '';
    
      $root.append(
        `<div class="item" style="flex-direction:column; align-items:stretch;">
           <div class="d-flex justify-content-between" style="width:100%;">
             <div><strong>${h(customer)}</strong></div>
             <div class="meta">${h(time)}</div>
           </div>
           <div class="meta">Served by: ${h(staffName)}</div>
           <div class="meta">Store ★ ${storeStars}/5</div>
           <div class="meta">Staff ★ ${staffStars}/5</div>
           ${storeTxt}${staffTxt}
         </div>`
      );
    });

}

// --- Fetch + paint everything in the drawer ---
function fetchInsights(){
  return $.getJSON(window.location.pathname + '?action=staff_stats')
    .done(function(resp){
      if (!resp || !resp.ok) return;

      // TEMP: log what the server is sending
      console.log('staff_stats', resp);

      // 1) Turnover by staff (pie)
      var cuts = resp.turnover || [];
      pieCutsChart = buildOrUpdatePie(
        pieCutsChart,
        document.getElementById('pieCuts'),
        cuts.map(r => r.staff_name || '—'),
        cuts.map(r => Number(r.turnover_cents || 0) / 100),   // cents → dollars
        cuts.map((_, i) => PIE_COLORS[i % PIE_COLORS.length]),
        null
      );

      // 2) 5★ feedback (pie)
      var revs = resp.reviews || [];
      pieReviewsChart = buildOrUpdatePie(
        pieReviewsChart,
        document.getElementById('pieReviews'),
        revs.map(r => r.staff_name || '—'),
        revs.map(r => Number(r.reviews || 0)),
        revs.map((_, i) => PIE_COLORS[(i + 3) % PIE_COLORS.length]),
        null
      );

      // 3) Hourly – turnover by staff (grouped) + cancellations + wait
      var hourly = resp.hourly || {};
      barHourlyChart = buildOrUpdateHourly(
        barHourlyChart,
        document.getElementById('barHourly'),
        hourly.labels || [],
        hourly.series || [],
        hourly.cancel_staff || [],
        hourly.cancel_customer || [],
        hourly.avg_wait || []
      );

      // 4) Lists
      renderCancels(resp.cancellations || []);
      renderFeedback(resp.feedback || []);

      if (resp.date) $('#statDate').text('Date: ' + resp.date);
    });
}



// Drawer open/close
function toggleInsights(open){
  const $dr = $('#insightDrawer');
  const isOpen = (open != null) ? !!open : !$dr.hasClass('open');
  $dr.toggleClass('open', isOpen).attr('aria-hidden', !isOpen);
  $('#insightTab').attr('aria-expanded', isOpen);
  if (isOpen) {
    fetchInsights().always(() => {
      // Re-resolve Finish state for each served row (cooldowns might have expired)
      $('#servedList .queue-item').each(function(){
        const $row = $(this);
        const cid = Number($row.find('[data-id]').first().attr('data-id')||0);
        if (!cid) return;
        // mimic the resolveFinishState() logic used in buildServedItem:
        $.getJSON(window.location.pathname + '?action=finish_service_status', { customer_id: cid })
          .done(function(resp){
            const $btn = $row.find('.btn-finish');
            if (!$btn.length) return;
            if (resp && resp.ok && resp.allowed === false){
              const retry = Number(resp.retry_after_secs || 0);
              if (retry > 0){
                const mins = Math.ceil(retry/60);
                $btn.text('Finished').addClass('disabled').prop('disabled', true)
                   .attr('title','Available in ~' + mins + ' min');
              }
            } else {
              $btn.text('Finish Service').removeClass('disabled').prop('disabled', false).attr('title','');
            }
          });
      });
    });
  }
}

// Prevent double openings / double-clicks while picker is open
$('#servicePickerModal')
  .on('show.bs.modal', function () {
    // While the picker is open, no other “Add to Cart” buttons should fire.
    $('.btn-add-cart').prop('disabled', true);
  })
  .on('hidden.bs.modal', function () {
    // When the picker closes, restore each button based on its own cart status.
    $('.queue-item').each(function () {
      const $row = $(this);
      const $btn = $row.find('.btn-add-cart');
      if (!$btn.length) return;

      let key = null;

      // Offline-served rows use tempId instead of a numeric customer_id
      if ($row.hasClass('offline-served-item')) {
        const tempId = $row.data('temp-id');
        if (tempId) key = String(tempId);
      } else {
        const cidEl = $row.find('[data-id]').first();
        const cid   = cidEl.length ? Number(cidEl.attr('data-id') || 0) : 0;
        if (cid) key = cid;
      }

      const st   = (key !== null && key !== undefined) ? (cartStatusCache[key] || null) : null;
      const lock = (st === 'pending' || st === 'paid');

      $btn
        .prop('disabled', lock)
        .toggleClass('disabled btn-secondary', lock)
        .toggleClass('btn-outline-primary', !lock);
    });
  });


  
  /* ===== Timesheet tab badge (overdue sign-off) ===== */

    /* Sydney "now" in minutes since midnight */
    function tsNowSydneyMinutes(){
      const parts = new Intl.DateTimeFormat('en-AU', {
        timeZone: 'Australia/Sydney', hour: '2-digit', minute: '2-digit', hour12: false
      }).formatToParts(new Date());
      const H = parseInt(parts.find(p => p.type === 'hour').value, 10);
      const M = parseInt(parts.find(p => p.type === 'minute').value, 10);
      return H * 60 + M;
    }
    
    /* "HH:MM" -> minutes since midnight */
    function hmToMinutes(hm){
      if (!hm || typeof hm !== 'string') return null;
      const [H, M] = hm.split(':');
      const h = parseInt(H,10), m = parseInt(M||'0',10);
      if (Number.isNaN(h) || Number.isNaN(m)) return null;
      return h*60 + m;
    }
    
    /* Pull roster + sessions and update the badge + pulse */
    function updateTimesheetBadge(){
      const $tab   = $('#timesheetTab');
      const $badge = $('#tsBadge');
    
      if (window.APP_ONLINE === false) {
        // Clear any overdue indicator while offline
        $badge.removeClass('show').attr('aria-hidden','true');
        $tab.removeClass('pulse');
        return;
      }
    
      $.getJSON(window.location.pathname + '?action=ts_rostered_today')
        .done(resp => {
          let overdue = 0;
          const nowMin = tsNowSydneyMinutes();
          (resp.staff || []).forEach(r => {
            const sess  = r.session || null;
            const endHM = (r.roster_end || '').slice(0,5); // "HH:MM"
            if (sess && sess.on_shift && endHM){
              const endMin = hmToMinutes(endHM);
              if (endMin != null && nowMin > endMin) overdue++;
            }
          });
    
          if (overdue > 0){
            $badge.text(overdue).addClass('show').attr('aria-hidden','false');
            $tab.addClass('pulse');
          } else {
            $badge.removeClass('show').attr('aria-hidden','true');
            $tab.removeClass('pulse');
          }
        })
        .fail(() => {
          // On error, don't flash; just leave current state
        });
    }

  
    /* ============================
       Timesheets side drawer
    ============================ */
    function toggleTimesheets(open){
      const $dr = $('#timesheetDrawer');
      const isOpen = (open != null) ? !!open : !$dr.hasClass('open');
      $dr.toggleClass('open', isOpen).attr('aria-hidden', !isOpen);
      $('#timesheetTab').attr('aria-expanded', isOpen);
      if (isOpen) { fetchTimesheetData(); }
    }
    
    $('#timesheetTab').on('click', function () {
      // If offline, don’t open the drawer – just show a small message
      if (window.APP_ONLINE === false || $(this).hasClass('disabled')) {
        if (typeof showSnack === 'function') {
          showSnack('Timesheets are only available when LineUpz is online.', true, 2200);
        } else {
          alert('Timesheets are only available when LineUpz is online.');
        }
        return;
      }
      toggleTimesheets();
    });

    $('#timesheetClose').on('click', ()=> toggleTimesheets(false));
    
    $('#aiSupportClose').on('click', function () {
      toggleAiSupport(false);
    });

    
    // AI Support tab -> pop-out window
    $('#aiSupportTab').on('click', function () {
      openAiSupportWindow();
    });
    


    function secsToHMS(s){
      s = Math.max(0, Number(s)||0);
      const h = Math.floor(s/3600), m = Math.floor((s%3600)/60);
      return (h ? (h+'h ') : '') + m + 'm';
    }
    function hmToAmPm(hm){
      // expects "HH:MM" (24h). returns "h:mm am/pm"
      if (!hm || typeof hm !== 'string' || !/^\d{2}:\d{2}$/.test(hm)) return '—';
      let [H, M] = hm.split(':').map(Number);
      const ampm = H >= 12 ? 'pm' : 'am';
      H = H % 12; if (H === 0) H = 12;
      return `${H}:${String(M).padStart(2,'0')} ${ampm}`;
    }
    
    function renderTsRoster(list, today){
      const $root = $('#tsRosterList').empty();
      if (!list || !list.length){
        $root.append('<div class="text-muted">No staff found.</div>');
        return;
      }
    
      list.forEach(row => {
        const st  = row.session || null;
        const onS = !!(st && st.on_shift);
        const onB = !!(st && st.on_break);
    
        const status   = !onS ? 'Off shift' : (onB ? 'On break' : 'On shift');
        const breakTxt = st ? ` • Break: ${secsToHMS(st.break_seconds)}` : '';
    
        // roster times from API: "HH:MM:SS" or "HH:MM"
        const rStart = (row.roster_start || '').slice(0,5);
        const rEnd   = (row.roster_end   || '').slice(0,5);
    
        // AM/PM label
        const rosterLine = (rStart || rEnd)
          ? `<div class="meta">Roster: ${h(hmToAmPm(rStart))} – ${h(hmToAmPm(rEnd))}</div>`
          : '';
    
        let btns = '';
    
        if (!onS) {
          // Not on shift yet → single Start button
          btns = `
            <button class="btn btn-outline-success btn-sm ts-act"
              data-op="start"
              data-sid="${row.staff_id}"
              data-sname="${h(row.staff_name)}"
              data-rstart="${rStart||''}"
              data-rend="${rEnd||''}">
              Start
            </button>
          `;
        } else {
          // On shift
          if (onB) {
            // Currently on break → single "End break"
            btns += `
              <button class="btn btn-outline-info btn-sm ts-act"
                data-op="break_end"
                data-sid="${row.staff_id}"
                data-sname="${h(row.staff_name)}">
                End break
              </button>
            `;
          } else {
            // Not on break → centered label + 3 break buttons
            btns += `
              <div class="d-flex flex-column align-items-center mr-2">
                <div class="text-muted small mb-1 text-center">Start break</div>
                <div class="btn-group" role="group" aria-label="Start break">
                  <button class="btn btn-outline-secondary btn-sm ts-act"
                    data-op="break_start"
                    data-sid="${row.staff_id}"
                    data-sname="${h(row.staff_name)}"
                    data-rstart="${rStart||''}"
                    data-rend="${rEnd||''}"
                    data-break-min="15">
                    15m
                  </button>
                  <button class="btn btn-outline-secondary btn-sm ts-act"
                    data-op="break_start"
                    data-sid="${row.staff_id}"
                    data-sname="${h(row.staff_name)}"
                    data-rstart="${rStart||''}"
                    data-rend="${rEnd||''}"
                    data-break-min="30">
                    30m
                  </button>
                  <button class="btn btn-outline-secondary btn-sm ts-act"
                    data-op="break_start"
                    data-sid="${row.staff_id}"
                    data-sname="${h(row.staff_name)}"
                    data-rstart="${rStart||''}"
                    data-rend="${rEnd||''}"
                    data-break-min="60">
                    1h
                  </button>
                </div>
              </div>
            `;
          }
    
          // Finish button always available while on shift
          btns += `
            <button class="btn btn-outline-danger btn-sm ts-act"
              data-op="end"
              data-sid="${row.staff_id}"
              data-sname="${h(row.staff_name)}"
              data-rstart="${rStart||''}"
              data-rend="${rEnd||''}">
              Finish
            </button>
          `;
        }
    
        $root.append(`
          <div class="item">
            <div>
              <div><strong>${h(row.staff_name)}</strong></div>
              ${rosterLine}
              <div class="meta">${status}${breakTxt}</div>
            </div>
            <div class="d-flex align-items-center" style="gap:6px;">
              ${btns}
            </div>
          </div>
        `);
      });
    
      // Bind ONCE (delegated) — outside the loop
      $root.off('click.ts').on('click.ts', '.ts-act', function(){
        const $btn   = $(this);
        const sid    = Number($btn.data('sid')||0);
        const op     = String($btn.data('op')||'');
        const sname  = String($btn.data('sname')||'');
        const rStart = String($btn.data('rstart')||'');
        const rEnd   = String($btn.data('rend')||'');
    
        if (!sid || !op) return;
    
        // Prevent double taps
        if ($btn.prop('disabled')) return;
    
        if (op === 'break_start' || op === 'break_end'){
          $btn.prop('disabled', true);
          punchNoSignature(sid, op); // this will refresh the list
          return;
        }
    
        // Start / Finish → signature with roster info shown
        openSignatureThenPunch(sid, sname, op, rStart, rEnd);
      });
    }



    function renderTsToday(rows){
      const $root = $('#tsTodayList').empty();
      if (!rows || !rows.length){ $root.append('<div class="text-muted">No sessions yet today.</div>'); return; }
    
      rows.forEach(r=>{
        const started = utcToLocalHM(r.start_at);
        const ended   = r.end_at ? utcToLocalHM(r.end_at) : '—';
        
        const hasStart = !!r.start_at;
        const hasEnd   = !!r.end_at;
        const durTxt   = (hasStart && hasEnd)
          ? (function(){
              const endMs   = Date.parse(String(r.end_at  ).replace(' ','T') + 'Z');
              const startMs = Date.parse(String(r.start_at).replace(' ','T') + 'Z');
              const secs = Math.max(0, Math.floor((endMs - startMs)/1000) - Number(r.break_seconds||0));
              return secsToHMS(secs);
            })()
          : (hasStart && !hasEnd ? '…' : '—');

    
        const html = `
          <div class="item">
            <div>
              <div><strong>${h(r.staff_name)}</strong></div>
              <div class="meta">Start: ${h(started)} • End: ${h(ended)} • Break: ${secsToHMS(r.break_seconds)} • Net: ${durTxt}</div>
            </div>
          </div>
        `;
        $root.append(html);
      });
    }
    
    function fetchTimesheetData(){
      $('#tsHint').text('Loading…');
      $.getJSON(window.location.pathname + '?action=ts_rostered_today')
        .done(resp=>{
          if (!resp || !resp.ok){ $('#tsHint').text('Failed to load'); return; }
          renderTsRoster(resp.staff || [], resp.date);
          // also load the raw sessions list
          $.getJSON(window.location.pathname + '?action=ts_list', { date: resp.date })
            .done(r2=>{
              if (r2 && r2.ok) renderTsToday(r2.rows || []);
              $('#tsHint').text('Tap Start/Break/Finish to record punches.');
            })
            .fail(()=> $('#tsHint').text('Could not load session list.'));
        })
        .fail(()=> $('#tsHint').text('Failed to load.'));
    }
    
    // Keep refs to handlers so we can unbind cleanly
    let tsStartHandler, tsMoveHandler, tsEndHandler;
    
    function tsSignUnbind(){
      if (!tsSignCanvas) return;
      tsSignCanvas.removeEventListener('mousedown', tsStartHandler);
      window.removeEventListener('mousemove', tsMoveHandler);
      window.removeEventListener('mouseup', tsEndHandler);
      tsSignCanvas.removeEventListener('touchstart', tsStartHandler);
      window.removeEventListener('touchmove', tsMoveHandler);
      window.removeEventListener('touchend', tsEndHandler);
    }
    
    $('#tsSignModal')
      .off('shown.bs.modal.sig')
      .on('shown.bs.modal.sig', function(){
        // modal is now visible → correct sizes
        tsSignCanvas = document.getElementById('tsSignCanvas');
        tsSignFitCanvas();
        tsSignBind();   // attach handlers now that canvas is sized
      })
      .off('hidden.bs.modal.sig')
      .on('hidden.bs.modal.sig', function(){
        tsSignDrawing = false;
        tsSignUnbind();              // remove handlers
        tsSignCanvas = null;         // drop ref
      });


    function tsSignFitCanvas(){
      if (!tsSignCanvas) return;
      const rect = tsSignCanvas.getBoundingClientRect();
      tsSignDPR = Math.max(1, window.devicePixelRatio || 1);
      tsSignCanvas.width  = Math.floor(rect.width  * tsSignDPR);
      tsSignCanvas.height = Math.floor(Math.max(180, rect.width * 0.45) * tsSignDPR); // ~golden-ish box
      tsSignCtx = tsSignCanvas.getContext('2d');
      tsSignCtx.scale(tsSignDPR, tsSignDPR);
      // white bg
      tsSignCtx.fillStyle = '#fff'; tsSignCtx.fillRect(0,0,tsSignCanvas.width, tsSignCanvas.height);
      tsSignCtx.strokeStyle = '#111';
      tsSignCtx.lineWidth = 2;
      tsSignCtx.lineJoin = 'round';
      tsSignCtx.lineCap  = 'round';
      tsSignDirty = false;
    }
    
    function tsSignPointFromEvent(e){
      const rect = tsSignCanvas.getBoundingClientRect();
      const clientX = (e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX);
      const clientY = (e.touches && e.touches[0] ? e.touches[0].clientY : e.clientY);
      const x = (clientX - rect.left);
      const y = (clientY - rect.top);
      return { x, y };
    }
    
    function tsSignBind(){
      const drawTo = (x,y,move=false)=>{
        if (!tsSignCtx) return;
        if (!move){ tsSignCtx.beginPath(); tsSignCtx.moveTo(x,y); }
        else { tsSignCtx.lineTo(x,y); tsSignCtx.stroke(); }
        tsSignDirty = true;
      };
    
        tsStartHandler = function(e){
          if (e && e.cancelable) e.preventDefault();
          tsSignDrawing = true;
          const p = tsSignPointFromEvent(e);
          drawTo(p.x, p.y, false);
        };
        
        tsMoveHandler = function(e){
          if (!tsSignDrawing) return;
          if (e && e.cancelable) e.preventDefault();
          const p = tsSignPointFromEvent(e);
          drawTo(p.x, p.y, true);
        };
        
    tsEndHandler = function(e){
      if (!tsSignDrawing) return;                 // <-- don't block normal taps
      if (e && e.cancelable) e.preventDefault();  // only while drawing
      tsSignDrawing = false;
    };
    

    
      tsSignCanvas.addEventListener('mousedown', tsStartHandler);
      window.addEventListener('mousemove', tsMoveHandler);
      window.addEventListener('mouseup', tsEndHandler);
    
      tsSignCanvas.addEventListener('touchstart', tsStartHandler, {passive:false});
      window.addEventListener('touchmove', tsMoveHandler, {passive:false});
      window.addEventListener('touchend', tsEndHandler);
    }

    function openTsSignatureModal(staffId){
      tsSignStaffId = Number(staffId||0);
      $('#tsSignName').val('');
      $('#tsSignModal').modal('show');

    }
    
    // clear
    $('#tsSignClear').on('click', tsSignFitCanvas);
    

    // Resize canvas when modal resizes/orientation changes
    window.addEventListener('resize', function(){
      if ($('#tsSignModal').hasClass('show')) tsSignFitCanvas();
    });
        
    // Opens modal, shows roster HH:MM vs actual (now), captures signature,

    function openSignatureThenPunch(staffId, staffName, op, rosterStart, rosterEnd){
      $('#tsSignModal .modal-title').text(op === 'start' ? 'Confirm Start' : 'Confirm Finish');
      tsSignStaffId = Number(staffId || 0);
    
      // Build “now” in am/pm
      const nowAmPm = (() => {
        const d = new Date();
        let h = d.getHours(), m = d.getMinutes();
        const ampm = h >= 12 ? 'pm' : 'am';
        h = h % 12; if (h === 0) h = 12;
        return `${h}:${String(m).padStart(2,'0')} ${ampm}`;
      })();
    
      // Roster HH:MM strings from args
      const roStartHM = (rosterStart || '').slice(0,5); // "HH:MM" or ""
      const roEndHM   = (rosterEnd   || '').slice(0,5);
    
      // Info block (am/pm for roster + actual)
      let infoHtml = '';
      if (op === 'start') {
        infoHtml = `
          <div>
            <div><strong>Rostered start:</strong> ${h(hmToAmPm(roStartHM) || '—')}</div>
            <div><strong>Actual start (now):</strong> ${h(nowAmPm)}</div>
          </div>`;
      } else if (op === 'end') {
        infoHtml = `
          <div>
            <div><strong>Rostered end:</strong> ${h(hmToAmPm(roEndHM) || '—')}</div>
            <div><strong>Actual end (now):</strong> ${h(nowAmPm)}</div>
          </div>`;
      } else {
        // Fallback (shouldn't hit here for start/end ops)
        infoHtml = `<div><strong>Time:</strong> ${h(nowAmPm)}</div>`;
      }
      $('#tsSignTimes').html(infoHtml);
    
      // Show modal (canvas sizing/binding happens on shown.bs.modal)
      $('#tsSignModal').modal('show');
    
      // One-shot Confirm handler per open
      $('#tsSignSave').off('click.flow').on('click.flow', function(){
        if (!tsSignCanvas) return;
        if (!tsSignDirty){ alert('Please sign to confirm.'); return; }
    
        const $me = $(this).prop('disabled', true).text('Saving…');
    
        // 1) Punch first
        $.ajax({
          url: window.location.pathname + '?action=ts_punch',
          type: 'POST',
          contentType: 'application/json',
          data: JSON.stringify({ staff_id: tsSignStaffId, op })
        })
        .done(function(){
          // 2) Save PNG to the session
          const dataUrl = tsSignCanvas.toDataURL('image/png');
          $.ajax({
            url: window.location.pathname + '?action=ts_sign',
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({
              staff_id: tsSignStaffId,
              signed_name: staffName || null,
              image_base64: dataUrl
            })
          })
        .always(function(){
          $('#tsSignModal').modal('hide');
          $me.prop('disabled', false).text('Confirm');
          fetchTimesheetData();          // refresh roster + sessions
          updateTimesheetBadge();        // <<< add this
        });

        })
        .fail(function(xhr){
          const msg = (xhr && xhr.responseJSON && xhr.responseJSON.error) ? xhr.responseJSON.error : 'server';
          alert('Punch failed: ' + msg);
          $me.prop('disabled', false).text('Confirm');
        });
      });
    }
    
    // Breaks without signature (start / end)
    function punchNoSignature(sid, op){
      return $.ajax({
        url: window.location.pathname + '?action=ts_punch',
        type: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({ staff_id: Number(sid||0), op: String(op||'') })
      })
      .done(() => {
        // refresh the roster + today list so the UI flips from "Break" → "End break" (or vice versa)
        fetchTimesheetData();
        updateTimesheetBadge();
      })
      .fail(xhr => {
        const msg = (xhr && xhr.responseJSON && xhr.responseJSON.error) ? xhr.responseJSON.error : 'server';
        alert('Punch failed: ' + msg);
      });
    }


</script>
<style>@keyframes mcspin { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);} }</style>

<!-- PWA: register service worker -->
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function () {
      navigator.serviceWorker.register('/sw.js')
        .catch(function (err) {
          console.log('Service worker registration failed:', err);
        });
    });
  }
</script>
</body>
</html>

